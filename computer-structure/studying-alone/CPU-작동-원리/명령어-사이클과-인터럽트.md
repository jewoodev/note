# 명령어 사이클과 인터럽트
CPU는 메모리로부터 명령어나 데이터들을 가져와서 실행한다. CPU가 그렇게 메모리에 저장되어 있는 프로그램을 실행하는 이 과정이 일정한 패턴을 갖는다. 그 정해진 흐름, 주기를 **명령어 사이클**이라고 부른다. 그렇게 CPU는 메모리에 있는 프로그램을 정해진 흐름대로만 처리하는데 간혹 그 흐름을 방해하는 신호가 CPU에게 올 수 있다. 그렇게 CPU의 정해진 흐름을 끊는 신호를 **인터럽트**라고 부른다.

## 명령어 사이클의 종류
- 인출 사이클: CPU가 메모리에 있는 프로그램을 실행하기 위해 메모리에 저장된 값을 CPU 내부로 가져오는 작업을 인출이라고 한다.
- 간접 사이클: 추가적인 메모리 접근이 필요한 경우에만 돌입
- 실행 사이클: 갖고 왔으면 실행해야 한다.

인출-실행-인출-실행-인출-... 이게 명령어 사이클의 일부라고 생각하면 된다. 

근데 CPU로 명령어를 가져와도 바로 실행이 불가능한 경우도 있다. 추가적으로 메모리에 접근해야 하는 간접 주소 지정 방식의 명령어가 있기 때문이다. 그렇게 추가적인 메모리 접근이 필요한 경우엔 간접 사이클에 돌입하게 된다.

## 인터럽트
- 'CPU가 꼭 주목해야 할 때', 'CPU가 얼른 처리해야 할 다른 작업이 생겼을 때' 발생
- 인터럽트에는 크게 두 가지가 있음
  - 동기 인터럽트: 예외, CPU가 예기치 못한 상황을 접했을 때 발생. 종류로 폴트, 트랩, 중단, 소프트웨어 인터럽트가 있음 
  - 비동기 인터럽트: 하드웨어 인터럽트, 주로 입출력장치에 의해 발생

### 하드웨어 인터럽트
- 알림과 같은 인터럽트
- 입출력 작업 도중에도 효율적으로 명령어를 처리하기 위해 하드웨어 인터럽트 사용
  - 입출력 장치는 CPU에 비해 느림
  - 인터럽트가 없다면 CPU는 프린트 완료 여부를 확인하기 위해 주기적으로 "다 됐나? 아니네.", 사람이 확인하는 듯한 늬앙스로 확인해야 함
  - 인터럽트가 있다면 입출력 작업 동안 CPU는 다른 일을 할 수 있음

### 하드웨어 인터럽트 처리 순서
인터럽트의 종류를 막론하고 인터럽트 처리 순서는 대동소이하다.

1. 입출력장치는 CPU에 **인터럽트 요청 신호**를 보낸다.
   - CPU의 정상적인 실행 흐름을 끊고, 지금 끼어들어도 되는지 확인하기 위해 보내는 신호 
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인한다.
3. CPU는 인터럽트 요청을 확인하고 **인터럽트 플래그**를 통해 현재 인터럽트를 받아들일 수 있는지의 여부를 확인한다.
   - CPU가 인터럽트 요청 신호를 받아들였으면 인터럽트 플래그를 확인
   - 인터럽트 플래그는 현재 인터럽트를 받아들일 수 있는지 여부를 나타냄
4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업한다.
   - 받아들일 수 없다면 요청 신호가 오더라도 해당 인터럽트는 처리하지 않음
   - 모든 인터럽트를 인터럽트 플래그로 막을 수는 없음
   - 인터럽트 플래그로 막을 수 없는 인터럽트를 Non-maskable interrupt, NMI라고 부르기도 함
5. CPU는 **인터럽트 벡터**를 참조하여 **인터럽트 서비스 루틴**을 실행한다.
   - 인터럽트 서비스 루틴은 해당 인터럽트를 어떻게 처리하면 되는지 적혀있는 프로그램
   - 프로그램이기에 메모리에 저장되어 있음
   - 인터럽트 주체에 따라서 각기 다른 인터럽트 서비스 루틴의 '시작 주소'를 가지고 있음
     - 그 시작 주소, 인터럽트를 구분할 수 있는, 하기 위한 정보를 '인터럽트 벡터'라고 부름
     - 인터럽트 벡터를 표의 형태로 모아놓은 인터럽트 벡터 테이블도 메모리에 있음 
6. 인터럽트 서비스 루틴 실행이 끝나면 4. 에서 백업해둔 작업을 복구하여 실행을 재개한다.

- `4.` 에서 백업을 하기 위해 지금까지의 작업 내역을 스택 영역에 스택 구조로 백업함