# 레지스터는 무엇인가
레지스터는 CPU 내부의 '작은 임시저장장치'이다.

이런 레지스터에 프로그램 속 명령어와 데이터는 실행 전후로 저장된다. 그래서 프로그래머 입장에서는 조금 더 중요하고 직접적이다. 프로그래머가 레지스터에 담긴 값들을 관찰하는 것도 가능하다. 이를 통해 개발하고 실행하는 프로그램의 가장 낮은 단계에서부터, 기초적인 단계에서부터 실행되는 순서나 원리를 관찰할 수 있다. 

사실 ALU와 제어 장치는 프로그래머가 직접적으로 다룰 일은 (레지스터에 비해)적다. 근데 레지스터 안에 있는 값을 관찰하는 일은 생각보다 많다. 특히 로우 레벨 개발자들은 조금 더 많다.

# 레지스터의 역할
CPU 내부에는 다양한 레지스터들이 있고, 그 것들은 각기 다른 역할을 가진다. 그리고 CPU 종류에 따라 레지스터 종류도 달라진다. 그 중 대부분의 전공서가, 그리고 대부분의 CPU가 공통적으로 사용하는 레지스터들을 살펴보자.

- 프로그램 카운터: 메모리에서 가져올 명령어의 주소, Instruction Pointer라고 부르는 CPU도 있음
- 명령어 레지스터: 해석할 명령어(방금 메모리에서 읽어 들인 명령어), 제어장치가 해석
- 메모리 주소 레지스터: CPU가 읽어 들이고자 하는 메모리 주소를 주소 버스로 보낼 때 거치는 레지스터 
- 메모리 버퍼 레지스터: CPU가 정보를 데이터 버스로 주고받을 때 거치는 레지스터

1. 프로그램 카운터에 1000이 들어있는 상태에서 CPU 작동이 시작된다면,
2. 메모리 주소 레지스터에 1000이 복사되고
3. 메모리 주소 레지스터에서 주소 버스로 1000번지 메모리 주소로, 제어장치에서 제어 신호(메모리 읽기)를 제어 버스를 통해 보내면
4. 메모리는 1000번지에 저장된 값을 데이터 버스를 통해 메모리 버퍼 레지스터로 전달하고
5. 프로그램 카운터가 1 증가한다.
   - 다음으로 실행할 명령어는 그 다음 주소라는 논리를 갖는 것이 프로그램 카운터의 개념. 하지만 실행 흐름이 매번 순차적이진 않음.
   - 프로그램을 순차적으로 실행할 수 있는 원리가 됨
6. 가지고 온 '메모리 1000번지에 저장되어 있던 명령어'를 해석하기 위해 명령어 레지스터에 복사

## 순차적인 실행 흐름이 끊기는 경우
- 특정 메모리 주소로 실행 흐름을 이동하는 명령어 실행 시
  - e.g) JUMP, CONDITIONAL, JUMP, CALL, RET
- 인터럽트 발생시
- 등등

## 나머지 4개의 '알아볼 레지스터'
- 플래그 레지스터: 연산 결과 또는 CPU 상태에 대한 부가적인 정보
- 범용 레지스터: 다양하고 일반적인 상황에서 자유롭게 사용
  - 주소, 명령어, 데이터 모두 담을 수 있음
  - 여러 개가 있음
- 스택 포인터: 스택의 꼭대기를 가리킴
- 베이스 레지스터: 기준 주소 저장

스택 포인터와 베이스 레지스터는 특별한 '주소 지정'에 사용된다.

### 스택 주소 지정 방식
- 스택과 스택 포인터를 이용한 주소 지정 방식
- 스택 포인터: 스택의 꼭대기를 가리키는 포인터(스택이 어디까지 차 있는지를 표시)
- 스택 포인터를 이용해서 다음 명령어를 저장할 메모리 주소를 지정한다고 보면 됨
- 메모리 공간 중에 스택처럼 쓸 수 있는 공간으로 미리 지정된 구역이 있음
  - 이를 '스택 영역'이라고 부름

## 변위 주소 지정 방식
- 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻는 방식
  - 이 방식에는 크게 두 가지 방식이 있음, 그 두 가지는 특정 레지스터가 무엇이 되는지에 따라 나뉨
    - 이것 또한 CPU 종류에 따라 양상이 많이 다름
  - 하나는 프로그램 카운터, 나머지는 베이스 레지스터
    - 전자는 상대 주소 지정 방식
    - 후자는 베이스 레지스터 주소 지정 방식
      - 베이스 레지스터는 일종의 '기준 주소'의 역할을 함 
- 변위 주소 지정 방식을 사용하는 명령어는 명령어가 다음의 형태를 가짐
  - 연산 코드: 이런 내용을 수행해라
  - 레지스터: 이 레지스터 값과
  - 오퍼랜드: 이 주소를 더한 곳에 있는 데이터로