Mockito의 `any()`와 `eq()` 매처(matcher)에 대해 알아보자.

1. `any()` 매처:
    - 메서드의 특정 파라미터에 대해 어떤 값이 들어오든 상관없이 매칭되도록 할 때 사용한다.
    - 예: `any(String.class)`, `any(Integer.class)` 등
    - 모든 타입에 대해 `any()`를 사용할 수 있다.
2. `eq()` 매처: 
    - 메서드의 특정 파라미터에 대해 정확히 일치하는 값이 들어올 때만 매칭되도록 할 때 사용한다.
    - 예: `eq("test")`, `eq(123)` 등
    - 실제 값과 정확히 비교하여 매칭한다.
3. 중요한 규칙
    - Mockito에서는 하나의 메서드 호출에 대해 매처를 사용할 때, 모든 파라미터를 매처로 처리하거나 모든 파라미터를 실제 값으로 처리해야 한다.
    - 매처와 실제 값을 혼합해서 사용할 수 없다.

예를 들어, 다음과 같은 경우는 잘못된 사용이다.

```java
// 잘못된 사용
when(someMethod(any(), "raw value")).thenReturn(something);
```

올바른 사용법은 다음과 같다.

```java
// 올바른 사용 1: 모든 파라미터를 매처로
when(someMethod(any(), eq("raw value"))).thenReturn(something);

// 올바른 사용 2: 모든 파라미터를 실제 값으로
when(someMethod("actual value", "raw value")).thenReturn(something);
```

## 매처를 사용하면 모든 파라미터에 매처를 사용해야 하는 이유

stubbing을 할 때 하나의 파라미터라도 매처를 사용하면 모든 파라미터에 매처를 사용해야 한다.

```java
// 잘못된 사용
when(someMethod(any(), "raw value")).thenReturn(something);
```

이렇게 사용하면 두 개의 매처가 expected 되는데 하나만 있다고 `InvalidUseOfMatchersException`이 발생한다. Mockito가 이런 규칙을 만든 이유는 매처의 동작 방식과 관련이 있다.

1. **매처의 내부 동작 방식**
    - Mockito는 메서드 호출을 기록할 때 매처를 사용하는 순서를 추적한다.
    - 각 매처는 호출 스택에 기록되며, 이 기록은 메서드 호출이 완료된 후에 처리된다.
    - 매처와 실제 값을 혼합해서 사용하면, Mockito가 어떤 매처가 어떤 파라미터에 해당하는지 정확히 판단하기 어려워진다.
2. **일관성 보장**
    - 모든 파라미터를 매처로 처리하거나 실제 값으로 처리하는 규칙을 통해, Mockito는 메서드 호출을 더 예측 가능하고 안정적으로 처리할 수 있다.
    - 이는 테스트의 신뢰성을 높이고, 예상치 못한 동작을 방지한다.
3. **디버깅 용이성**
    - 모든 파라미터가 동일한 방식으로 처리되면, 테스트 실패 시 문제를 더 쉽게 파악할 수 있다.
    - 혼합된 사용을 허용하면, 어떤 파라미터가 잘못되었는지 파악하기 어려울 수 있다.

예를 들어, 다음과 같은 코드가 있다고 가정해보자.

```java
// 잘못된 사용
when(someMethod(any(), "test", any())).thenReturn(something);
```

이 경우 Mockito는 

1. 첫 번째 `any()`가 첫 번째 파라미터에 해당하는지
2. "test"가 두 번째 파라미터에 해당하는지
3. 두 번째 `any()`가 세 번째 파라미터에 해당하는지

정확히 판단하기 어려울 수 있다. 특히 메서드 오버로딩이 있는 경우 더 복잡해질 수 있다.

반면, 다음과 같이 작성하면:

```java
when(someMethod(any(), eq("test"), any())).thenReturn(something);
```

모든 파라미터가 명확하게 매처로 처리되므로, Mockito는 각 매처가 어떤 파라미터에 해당하는지 정확히 알 수 있다.

이러한 규칙은 Mockito의 설계 철학과도 일치한다. Mockito는 테스트 코드를 가능한 한 명확하고 예측 가능하게 만들기 위해 노력하며, 이 규칙은 그 목적을 달성하는 데 도움이 된다.



