# `@ContextConfiguration`으로 여러 Config 명시

```java
// TestConfigA.java
@Configuration
public class TestConfigA {
    @Bean
    public UserRepository userRepository() {
        return new MockUserRepository();
    }
}

// TestConfigB.java
@Configuration
public class TestConfigB {
    @Bean
    public UserService userService(UserRepository userRepository) {
        // ✅ TestConfigA의 빈을 주입받음
        return new UserService(userRepository);
    }
}

// 테스트
@SpringBootTest
@ContextConfiguration(classes = {TestConfigA.class, TestConfigB.class})
class UserServiceTest {
    @Autowired
    private UserService userService; // ✅ 정상 동작
}
```

# `@Import`로 다른 Config 가져오기

```java
@Configuration
public class TestConfigA {
    @Bean
    public UserRepository userRepository() {
        return new MockUserRepository();
    }
}

@Configuration
@Import(TestConfigA.class)  // ✅ A를 포함
public class TestConfigB {
    @Bean
    public UserService userService(UserRepository userRepository) {
        return new UserService(userRepository);
    }
}

@SpringBootTest
@ContextConfiguration(classes = TestConfigB.class)
class UserServiceTest {
    // TestConfigB만 명시해도 TestConfigA도 함께 로드됨
}
```

# `@TestConfiguration`과 `@Configuration` 혼합

```java
// 프로덕션 설정
@Configuration
public class AppConfig {
    @Bean
    public UserRepository userRepository() {
        return new JpaUserRepository();
    }
}

// 테스트 설정
@TestConfiguration
public class TestConfig {
    @Bean
    public UserService userService(UserRepository userRepository) {
        // ✅ AppConfig의 userRepository를 주입받음
        return new UserService(userRepository);
    }
}

@SpringBootTest
@Import(TestConfig.class)
class UserServiceTest {
    // AppConfig + TestConfig 빈 모두 사용 가능
}
```

# 서로 구성 정보가 연결되지 못할 때
```java
@Configuration
public class TestConfigA {
    @Bean
    public UserRepository userRepository() {
        return new MockUserRepository();
    }
}

@Configuration
public class TestConfigB {
    @Bean
    public UserService userService(UserRepository userRepository) {
        return new UserService(userRepository);
    }
}

// 테스트 1
@SpringBootTest
@ContextConfiguration(classes = TestConfigA.class)
class TestA {
    // TestConfigA의 빈만 존재
}

// 테스트 2
@SpringBootTest
@ContextConfiguration(classes = TestConfigB.class)  // ❌ 에러!
class TestB {
    // TestConfigB만 로드했는데 UserRepository가 없어서 실패
}
// 참고! SpringBootTest는 ContextConfiguration이 없는 경우에만 스프링 부트스트랩핑을 진행함
```

# 실무 패턴
## 패턴 1: Base Config + 특화 Config

```java
// 공통 테스트 설정
@Configuration
public class BaseTestConfig {
    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.H2)
            .build();
    }
    
    @Bean
    public UserRepository userRepository(DataSource dataSource) {
        return new JdbcUserRepository(dataSource);
    }
}

// 서비스 테스트용 설정
@Configuration
@Import(BaseTestConfig.class)
public class ServiceTestConfig {
    @Bean
    public UserService userService(UserRepository userRepository) {
        // ✅ BaseTestConfig의 userRepository 주입
        return new UserService(userRepository);
    }
}

// 컨트롤러 테스트용 설정
@Configuration
@Import(ServiceTestConfig.class)  // ServiceTestConfig가 BaseTestConfig도 포함
public class ControllerTestConfig {
    @Bean
    public UserController userController(UserService userService) {
        // ✅ ServiceTestConfig의 userService 주입
        return new UserController(userService);
    }
}
```

## 패턴 2: 계층별 Config 분리

```java
// 저장소 계층
@Configuration
public class RepositoryTestConfig {
    @Bean
    public UserRepository userRepository() {
        return Mockito.mock(UserRepository.class);
    }
    
    @Bean
    public OrderRepository orderRepository() {
        return Mockito.mock(OrderRepository.class);
    }
}

// 서비스 계층
@Configuration
@Import(RepositoryTestConfig.class)
public class ServiceTestConfig {
    @Bean
    public UserService userService(UserRepository userRepository) {
        return new UserService(userRepository);
    }
    
    @Bean
    public OrderService orderService(
            OrderRepository orderRepository,
            UserRepository userRepository) {  // ✅ 둘 다 주입 가능
        return new OrderService(orderRepository, userRepository);
    }
}

// 테스트
@SpringBootTest
@ContextConfiguration(classes = ServiceTestConfig.class)
class OrderServiceTest {
    // 모든 빈이 정상적으로 주입됨
}
```

## 패턴 3: @TestConfiguration 체이닝

```java
@TestConfiguration
public class MockRepositoryConfig {
    @Bean
    public UserRepository userRepository() {
        return Mockito.mock(UserRepository.class);
    }
}

@TestConfiguration
@Import(MockRepositoryConfig.class)
public class ServiceConfig {
    @Bean
    public UserService userService(UserRepository userRepository) {
        // ✅ MockRepositoryConfig의 빈 주입
        return new UserService(userRepository);
    }
}

@SpringBootTest
@Import(ServiceConfig.class)
class IntegrationTest {
    // 프로덕션 설정 + MockRepositoryConfig + ServiceConfig 모두 로드
}
```

# 정리
1. 같은 ApplicationContext에 있으면 다른 Config의 빈도 주입 가능 
2. `@Import`나 `@ContextConfiguration`으로 함께 로드하면 됨 
3. 순환 참조만 조심하면 됨

```java
// 이런 구조는 문제없음
ConfigA → 빈A 생성
ConfigB → 빈B 생성 (빈A 주입받음)
ConfigC → 빈C 생성 (빈A, 빈B 주입받음)

// 순환 참조는 에러
ConfigA → 빈A 생성 (빈B 필요)
ConfigB → 빈B 생성 (빈A 필요)  // 순환 참조!
```

실무에서는 보통 Base Config를 만들어두고 필요에 따라 Import하는 방식을 많이 사용한다.