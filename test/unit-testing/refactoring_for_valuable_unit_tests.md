이번엔 좋은 단위 테스트를 작성하기 위한 코드베이스 설계 방법에 대해 더 공부한다. 함수형 아키텍터를 사용할 수 없는 애플리케이션을 포함해 넓은 범위의 애플리케이션에 대한 '코드베이스 기반 테스트 리팩터링 방법' 을 살펴볼 것이다. 

# 리팩터링할 코드 식별하기
기반 코드를 리팩터링 하지 않고서는 테스트 스위트를 크게 개선할 수 없다. 테스트 코드와 제품 코드는 본질적으로 관련되어 있기 때문이다. 이 절에서는 리팩터링의 방향을 설명하고자 코드를 네 가지 유형으로 분류하는 방법을 설명한다.

## 코드의 네 가지 유형
모든 제품 코드는 2차원으로 분류할 수 있다.

1. 복잡도 또는 도메인 유의성
2. 협력자 수

코드 복잡도(code complexity)는 코드 내 의사 결정(분기) 지점의 수로 정의한다. 이 숫자가 클수록 복잡도는 더 높아진다.

도메인 유의성은 코드가 프로젝트의 문제 도메인에 대해서 얼마나 의미를 갖는지를 나타낸다. 

복잡한 코드와 도메인 유의성을 갖는 코드가 단위 테스트에서 가장 이롭다. 그러한 테스트가 회귀 방지에 뛰어나기 때문이다. 도메인 코드는 복잡할 필요가 없으며, 복잡한 코드는 도메인 유의성이 나타나지 않아도 테스트할 만하다. 이 두 요소는 서로 독립적이다. 

두 번째 차원은 클래스 또는 메서드가 가진 협력자 수이다. 협력자는 가변 의존성이거나 프로세스 외부 의존성(또는 둘 다)이다. 협력자가 많은 코드는 테스트 비용이 많이 든다. 테스트 크기에 따라 달라지는 유지 보수성 지표 때문이다. 협력자를 예상되는 조건으로 두고 상태나 상호 작용을 확인하게끔 코드를 작성해야 한다. 협력자가 많으면 많을수록 테스트가 커진다.

테스트 대상 시스템(SUT)이 협력자를 인수로 받거나 정적 메서드를 통해 암시적으로 참조해도 상관없지만, 테스트에서 협력자를 설정해야 한다. 반대로 불변 의존성(값 또는 값 객체 등)은 해당하지 않는다. 불변 의존성은 설정과 검증이 훨씬 쉽다.

단위 테스트 대상으로는 도메인 모델과 알고리즘이 노력 대비 가장 이로운 대상이다. 그런 단위 테스트는 매우 가치있고 저렴하다. 그리고 컨트롤러의 경우, 포괄적인 통합 테스트의 일부로서 간단히 테스트해야 한다.

가장 문제가 되는 코드 유형은 지나치게 복잡한 코드다. 이를 단위 테스트하기는 어렵겠지만, 테스트 커버리지 없이 내버두는 건 너무 위험하다. 이런 코드때문에 많은 사람들이 단위 테스트하기 어려워하게 된다. 때때로 실제 구현이 까다로울 수 있지만, 지나치게 복잡한 코드를 알고리즘과 컨트롤러라는 두 부분으로 나누는 것이 일반적이다.

지나치게 복잡한 코드를 피하고 도메인 모델과 알고리즘만 단위 테스트하는 것은 매우 가치 있고 유지 보수하기 쉬운 테스트 스위트를 만드는 일이다. 하지만 이 방법으로도 테스트 커버리지를 100% 달성할 순 없으며, 이를 목표로 해서도 안 된다. 목표는 각각의 테스트가 프로젝트 가치를 높이는 테스트 스위트다. 다른 모든 테스트를 리팩터링하거나 제거해라. 테스트 스위트의 크기를 부풀리지 말자.

하지만 지나치게 복잡한 코드를 제거하는 건 쉬운 일이 아니다. 그럼에도 불구하고 도움이 되는 기법이 있다. 

## 험블 객체 패턴을 사용해 지나치게 복잡한 코드 분할하기
지나치게 복잡한 코드를 쪼개려면, 헙블 객체 패턴을 써야 한다.

나는 코드가 프레임워크 의존성에 결합되어 있기 때문에 테스트가 어렵다는 사실을 깨달은 적이 종종 있다. 테스트 대상 코드의 로직을 테스트하려면, 테스트가 가능한 부분을 추출해야 한다. 결과적으로 코드는 테스트 가능한 부분을 둘러싼 험블 래퍼가 된다. 험블 래퍼가 테스트하기 어려운 의존성과 새로 추출된 구성 요소를 붙이지만, 자체적은 로직이 거의 없거나 전혀 없어 테스트할 필요가 없다.

험블 객체 패턴을 보는 또 다른 방법은 단일 책임 원칙을 지키는 것이다. 책임 중 하나로 늘 비즈니스 로직이 있는데, 이 패턴을 사용하면 비즈니스 로직을 거의 모든 것과 분리할 수 있다.

험블 객체 패턴의 다른 예로 DDD에 나오는 집계 패턴(Aggregate pattern)이 있다. 이 패턴의 목표 중 하나는 클래스를 클러스터(집계)로 묶어서 클래스 간 연결을 줄이는 것이다. 클래스는 해당 클러스터 내부에 강결합돼 있지만, 클러스터 자체는 느슨하게 결합되어 있다. 그러한 구조는 코드베이스의 총 통신 수를 줄인다. 그 결과 연결이 줄어들고 테스트 용이성이 향상된다.

# 가치 있는 단위 테스트를 위한 리팩터링
험블 객체 패턴을 사용해 모든 엔타프라이즈급 애플리케이션에 대한 리팩터링 방법을 학습해보자.

## 1단계, 암시적 의존성을 명시적으로 만들기
테스트 용이성을 개선하는 일반적인 방법은 암시적 의존성을 명시적으로 만드는 것이다. 즉, 암시적 의존성에 대한 인터페이스를 두고, 그 인터페이스를 암시적 의존성을 대신해서 주입하고 테스트에서 목으로 처리한다. 이 방법은 도움이 되지만 충분하지는 않다.

일단 그런 의존성을 갖는 클래스를 테스트하려면 복잡한 목 체계가 필요한데, 그로인해 테스트 유지비가 증가한다. 그리고 목을 데이터베이스 의존성에 사용하면 테스트 취약성을 야기할 수 있다.

결국 도메인 모델은 직접적으로든 간접적으로든 프로세스 외부 협력자에게 의존하지 않는 것이 훨씬 더 깔끔하다. 그게 바로 육각형 아키텍처에서 바라는 바다. 

## 2단계, 애플리케이션 서비스 계층 도입
도메인 모델이 외부 시스템과 직접 통신하는 문제를 극복하려면 다른 클래스인 험블 컨트롤러(육각형 아키텍처의 분류에서 애플리케이션 서비스)로 책임을 옮겨야 한다. 일반적으로 도메인 클래스는 다른 도메인 클래스나 단순 값과 같은 프로세스 내부 의존성에만 의존해야 한다. 

이를 수행하면 도메인 객체는 협력자 수가 줄어들어 더 우수해지지만 험블 컨트롤러의 로직이 꽤 복잡해지게 된다.

## 3단계, 애플리케이션 서비스 복잡도 낮추기
험블 컨트롤러의 복잡도를 낮추려면 재구성 로직을 추출해야 한다. ORM 라이브러리를 사용해 데이터베이스를 도메인 모델에 매핑하면, 그게 곧 재구성 로직을 옮기기 작업으로 적합할 수 있다. ORM을 사용하지 않거나 할 수 없으면, 도메인 모델에 '원시 데이터베이스 데이터로 도메인 클래스를 인스턴스화하는 팩토리 클래스'를 작성해라. 

이를 수행하면 험블 컨트롤러가 모든 협력자와 완전히 격리되어 테스트가 쉬워진다. 

## 4단계, 각 도메인 클래스의 단일 책임 원칙 재정비하기
각 도메인 클래스에 적절히 책임이 분배 되었는지, 또 각 도메인 클래스의 API는 '묻지 말고 답하라(tell-don't-ask)'라는 원칙을 준수하는지 확인하자. 이를 통해 험블 컨트롤러의 복잡한 로직에 스며들어 있던 각 도메인 클래스의 책임들이 정리되어 도메인 클래스도, 험블 컨트롤러도 복잡도가 완화된다. 특히 험블 컨트롤러는 도메인 클래스 마저 의존성화 하여 각 외존성을 묶어 비즈니스 로직을 구성하는 훌륭한 오케스트레이션 역할을 할 수 있게 될 것이다. 

험블 컨트롤러에서 모든 협력자를 모아 처리할 때, 협력자는 '도메인 계층 협력자'와 '외부 협력자(e.g. 데이터베이스)'로 분류된다. 두 협력자 간의 차이는 사이드 이펙트 처리에 있다. 함수형 코어는 어떠한 사이드 이펙트도 일으키지 않는다. 도메인 모델은 사이드 이펙트를 일으키지 않거나 일으킬 수도 있지만, 그런 사이드 이펙트는 변경된 도메인 모델 내부에 남아있다. 험블 컨트롤러가 도메인 모델을 데이터베이스에 저장할 때만 사이드 이펙트가 도메인 모델의 경계를 넘는다.

마지막 순간까지 모든 사이드 이펙트가 메모리에 남아있다는 사실 덕분에 테스트하기가 훨씬 쉬워진다.

# 최적의 단위 테스트 커버리지 분석
## 전제 조건을 테스트해야 하는가?
일반적으로 권장하기를 도메인 유의성에 있는 모든 전체 조건을 테스트하라. 그러나 도메인 유의성이 없는 전제 조건은 테스트하는 데에 비용을 들이지 말라.

# 컨트롤러에서 조건부 로직 처리
조건부 로직을 처리하면서 프로세스 외부 협력자 없이 도메인 계층을 유지 보수하는 것은 까다로운 일이다. 이게 무슨 말이냐, 통상적으로 애플리케이션 동작이 다음과 같이 흘러간다는 걸 염두해두고 이야기를 시작하자.

1. 저장소에서 데이터 검색
2. 비즈니스 로직 실행
3. 데이터를 다시 저장소에 저장

그리 이상한 이야기는 아닐 것이다. 보통은 이렇게 흘러가기 때문이다. 하지만 여기서 얼마든지 예외가 있을 수 있다. 그 예시로, 프로세스의 중간 결과를 기반으로 프로세스 외부 의존성에서 추가로 데이터를 조회해야 하는 일이 있을 수 있다. 그리고 그 추가 조회 결과로 인해 쓰기 작업의 결과도 달라지는 형태로 말이다.

이전 장에서 말했듯, 이런 상황에선 다음과 같이 세 가지 방법이 있다.

1. 외부에 대한 모든 읽기와 쓰기를 가장자리로 밀어낸다. 이는 '읽고-결정하고-실행하기' 구조를 유지하지만 성능이 저하된다. 필요 없는 경우에도 컨트롤러가 프로세스 외부 의존성을 호출하므로.
2. 도메인 모델에 프로세스 외부 의존성을 주입하고 비즈니스 로직이 해당 의존성을 호출할 시점을 직접 결정할 수 있게 한다.
3. 의사 결정 프로세스 단계를 더 세분화하고, 각 단계별로 컨트롤러를 실행하도록 한다.

문제는 다음 세 가지 특성의 균형을 맞추는 일이다.

1. 도메인 모델 테스트 유의성: 도메인 클래스의 협력자 수와 유형에 따른 함수
2. 컨트롤러 단순성: 의사 결정(분기) 지점이 있는지에 따라 달라지는 것
3. 성능: 프로세스 외부 의존성에 대한 호출 수로 달라지는 것

위에서 언급한 방법은 세 가지 특성 중 두 가지 특성만 갖는다.

1. 외부~ : 컨트롤러를 단순화하고 프로세스 외부 의존성을 도메인 모델과 분리하지만 성능이 저하된다.
2. 도메인~ : 성능을 유지함녀서 컨트롤러를 단순하게 하지만, 도메인 모델 테스트 유의성을 저하시킨다.
3. 의사~ : 성능과 도메인 모델 테스트 유의성에 도움을 주지만, 컨트롤러가 단순하지 않다.

소프트웨어 프로젝트에서 성능은 매우 중요하므로 첫 번째 방법은 고려할 필요가 없다. 두 번째는 대부분 코드를 지나치게 복잡하게 만든다. 

따라서 세번째 방법만 남게 되는데, 컨트롤러를 지나치게 복잡하게 만드는 점이 문제이다. 그러나 이 문제는 완화할 수 있는 방법이 있다.

## CanExecute/Execute 패턴 사용
그 방법의 첫 번째는 CanExecute/Execute 패턴을 사용해서 의사 결정 프로세스를 컨트롤러에서 없애는 것이다. 이 패턴을 사용하면 컨트롤러는 의사 결정 프로세스를 알 필요가 없어지고, 도메인 계층의 모든 결정을 통합할 수 있다.

## 도메인 이벤트를 사용해 도메인 모델 변경 사항 추적
도메인 모델을 현재 상태로 만든 단계를 빼내기 어려울 때가 있다. 그러나 애플리케이션에서 무슨 일이 일어나는지 외부 시스템에 알려야 하는 경우가 있기에 그런게 중요할 수도 있다. 

그런 책임이 컨트롤러에게 부여되면 더 복잡해진다. 이를 피하려면, 도메인 모델에서 중요한 변경 사항을 주적하고 비즈니스 연산이 완료된 후 해당 변경 사항을 프로세스 외부 의존성 호출로 변환하라. 그런 추적은 도메인 이벤트로 구현할 수 있다.