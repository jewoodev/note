# 좋은 단위 테스트의 4대 요소
여기서는 가치 있는 데스트를 식별하는 방법을 알아본다. 

## 좋은 단위 테스트의 4대 요소 자세히 살펴보기
### 첫 번째 요소: 회귀 방지
회귀 방지 지표에 대한 테스트 점수가 얼마나 잘 나오는지 평가하려면 다음 사항을 고려해야 한다.

- 테스트 중에 실행되는 코드의 양
- 코드 복잡도
- 코드의 도메인 유의성

일반적으로 실행되는 코드가 많을수록 회귀가 나타날 가능성이 높다. 많은 양의 코드가 예외를 발생시키지 않고 실행된다는 것을 알아내는 테스트에서 멈추지 말고, 코드가 생성하는 결과가 유효한지도 확인해야 한다.

복잡도와 도메인 유의성도 중요하다. 복잡한 비즈니스 로직을 나타내는 코드가 보일러플레이트 코드보다 훨씬 중요하다. 반면 단순한 코드를 테스트하는 것은 가치가 거의 없다. 

마지막으로 우리가 작성한 코드가 아닌 라이브러리, 프레임워크, 외부 시스템도 중요하다. 이러한 것도 우리가 작성한 코드만큼이나 소프트웨어 작동에 영향을 미치기 때문이다. 최상의 보호를 위해선 테스트가 해당 라이브러리, 프레임워크, 외부 시스템을 테스트 범주에 포함시켜서 검증을 해야 한다.

### 두 번째 요소: 리팩터링 내성
이 요소는 테스트를 실패시키지 않으면서 애플리케이션 코드를 리팩터링 할 수 있는지에 대한 척도를 의미한다. 

이러한 상황을 상상해보자. 새로운 기능을 개발했고 모든게 잘 작동한다. 여기에 리팩터링을 조금 하고나면 모든 게 훨씬 좋아보인다. 그런데 리팩터링을 하고 나니 테스트가 실패한다. 무엇이 고장난 것인지 살펴봤지만, 알고 보니 아무것도 고장나지 않았다. 기능도 예전과 같이 완벽하게 동작한다. 문제는 기반 코드를 수정하면 테스트가 실패하게 작성됐다는 것이다. 

이러한 상황을 거짓 양성이라고 한다. 이는 허위 경보다. 이런 거짓 양성은 일반적으로 코드를 리팩터링할 때, 즉 구현을 수정하지만 식별할 수 있는 동작은 유지시킬 때 발생한다.

거짓 양성은 전체 테스트 스위트에 치명적인 영향을 줄 수 있다.

- 테스트가 타당한 이유없이 실패하면, 코드 문제에 대응하는 능력과 의지가 희석된다. 시간이 흐르면서 그러한 실패를 무시하게 된다. 
- 거짓 양성이 빈번하면 테스트 스위트에 대한 신뢰가 서서히 떨어져서, 더 이상 믿을 만한 안전망으로 인식되지 않는다. 신뢰가 부족해지면 리팩터링이 줄어든다. 회귀를 피하기 위해 코드 변경을 최소화하기 때문이다.

### 무엇이 거짓 양성의 원인인가?
무엇이 거짓 양성의 원인일까? 어떻게 피할 수 있을까? 테스트에서 발생하는 거짓 야엇ㅇ의 수는 테스트 구성 방식과 직접적인 관련이 있다. 테스트와 테스트 대상 시스템(SUT)의 구현 세부 사항이 많이 결합될 수록 허위 경보가 더 많이 생긴다. 거짓 양성이 생길 가능성을 줄일 방법은 해당 구현 세부 사항에서 테스트를 분리하는 것 뿐이다.

테스트가 SUT가 생성한 결과가 아니라 SUT의 구현 세부 사항과 결합하게 되면 최종 결과가 바뀌지 않을지라도, 테스트는 실패하게 된다. 따라서 SUT의 구현 세부 사항과 결합된 테스트는 리팩터링 내성이 없다. 

### 구현 세부 사항 대신 최종 결과를 목표로 하기
테스트를 깨지지 않게 하고 리팩터링 내성을 높이는 방법은 SUT의 구현 세부 사항과 테스트 간의 결합도를 낮추는 것 뿐이다. 즉, 코드의 내부 작업과 테스트 사이를 가능한 한 멀리 떨어뜨리고 최종 결과를 목표로 하는 것이다. 따라서 SUT를 블랙박스로 취급하고 식별할 수 있는 동작에만 신경을 쓰는 것이 좋다.

### 용어 정리
- 거짓 양성: 문제가 있는 것이 거짓이다.
- 거짓 음성: 문제가 없는 것이 거짓이다.
- 참 양성: 문제가 있는 것이 참이다.
- 참 음성: 문제가 없는 것이 참이다.

## 첫 번째 특성과 두 번째 특성 간의 본질적인 관계
두 요소 사이에는 본질적인 관계가 있다. 둘 다 정반대의 관점에서도 테스트 스위트의 정확도에 기여한다. 이 두 가지 특성은 시간이 흐르면서 프로젝트에 영향을 다르게 미치는 경향이 있다. 프로젝트가 시작된 직후에는 회귀 방지를 훌륭히 갖추는 것이 중요한 데 반해, 리팩터링 내성을 필요하지 않다. 이 절에서 다룰 내용은 다음과 같다.

- 테스트 정확도 극대화
- 거짓 양성과 거짓 음성의 중요성

### 테스트 정확도 극대화
한 번 테스트 결과를 넓은 관점으로 살펴봐보자. 테스트는 통과하거나 실패할 수 있고 기능이 잘 작동할 수도 고장날 수도 있다.

테스트가 통과하고 기능이 잘 작동하는 상황은 올바른 추론이다. 작동 기능과 테스트 통과의 조합에 대한 용어로 '참 음성'이라고 한다.

마찬가지로 기능이 고장나서 테스트가 실패해도 올바른 추론이다. 기능이 제대로 작동하지 않으면 테스트가 실패할 것으로 예상하기 때문이다. 이것이 단위 테스트의 핵심이다. 이 상황에 해당하는 용어는 '참 양성'이다.

역으로 테스트에서 오류가 발생하지 않으면 문제가 된다. 이는 '거짓 음성'이고, 이를 피하는 데 좋은 테스트의 첫 번째 특성인 회귀 방지가 도움이 된다. 

반면에 기능이 올바르지만 테스트가 여전히 실패하는 대칭적인 상황이 있다. 이는 '거짓 양성', 즉 허위 경보다. 거짓 양성을 피하는 데 두 번째 특성인 리팩터링 내성이 도움이 된다.

여기서 언급한 모든 용어는 통계학에 뿌리를 두고 있지만, 테스트 스위트를 분석하는 데도 적용할 수 있다. 거짓 양성과 거짓 음성의 확률은 테스트의 수준을 나타낸다. 즉, 확률이 낮을 수록 테스트가 더 정확하다.

이 정확도는 좋은 단위 테스트의 두 가지 특성에 대한 것이다.

1. 테스트가 버그 있음을 얼마나 잘 나타내는가(거짓 음성(회귀 방지 영역) 제외)
2. 테스트가 버그 없음을 얼마나 잘 나타내는가(거짓 양성(리팩터링 내성 영역) 제외)

$테스트\ 정확도\ = \frac{신호(발견된\ 버그\ 수)}{소음(허위\ 경보\ 발생\ 수)}$

위의 공식으로 테스트 정확도를 구할 수 있다. 이걸 향상시키는 방법은 두 가지가 있다. 

1. 신호를 증가시키는 것
   1. = 회귀를 더 잘 찾아내는 테스트로 개선하는 것
2. 소음을 줄이는 것
   1. = 허위 경보를 발생시키지 않는 테스트로 개선하는 것

### 거짓 양성과 거짓 음성의 중요성: 역학 관계
프로젝트가 시작될 때, 잘못된 경고를 받는 건 경고를 전혀 받지 않아 버그가 운영 환경에 들어갈 위험을 감수하는 것에 비하면 큰 문제가 아니다. 그러나 프로젝트가 성장하면 할수록 거짓 양성은 테스트 스위트에 점점 더 큰 영향을 미치기 시작한다. 

처음엔 리팩터링이 중요하지 않다. 막 작성된 코드는 완벽하고 생생하다. 그렇기에 잘못된 경보가 발생하더라도 쉽게 리팩터링을 할 수 있다. 그러나 시간이 흐를 수록 코드베이스는 나빠진다. 점점 복잡해지고 체계적이지 않게 된다. 따라서 정기적인 리팩터링이 필요하다. 그러지 않으면 새로운 기능에 드는 비용이 결국 엄청나게 커진다. 

리팩터링이 점점 필요해짐에 따라서 테스트에서의 리팩터링 내성도 점점 더 중요해진다. 이를 무시하면 테스트는 신뢰를 빠르게 잃고, 신뢰할 수 잇는 피드백의 역할을 하지 못하게 된다.

거짓 양성으로부터 코드를 보호하는 게 이렇게 중요하지만 신경을 기울이는 개발자는 거의 없다. 대부분은 회귀 방지에만 중점을 두는 경향이 있는데, 그것으로는 부족하다. 중대형 프로젝트에서 작업하면 거짓 음성(알려지지 않은 버그)과 거짓 양성(허위 경보)에 똑같은 주의를 기울여야 한다.

## 세 번째 요소와 네 번째 요소: 빠른 피드백과 유지 보수성
빠른 피드백은 중요하다. 테스트 속도가 빨라야 테스트 스위트에서 더 많은 테스트를 수행할 수 있고 더 자주 실행할 수 있다. 테스트가 빠르게 실행되면 코드에 결함이 생기자마자 버그에 대해 경고하기 시작할 정도로 피드백 루프를 대폭 줄여서, 버그를 수정하는 비용을 거의 0까지 줄일 수 있다. 반면 느린 테스트는 피드백을 느리게 하고 잠재적으로 버그를 뒤늦게 발견하게 만들어 버그 수정 비용을 증가시킨다. 

마지막으로 유지 보수성은 유지비를 말한다. 이건 다음 두 가지 주요 요소로 구성된다.

1. 테스트가 얼마나 이해하기 어려운가: 이건 테스트의 크기와 관련이 있다. 테스트는 코드 라인이 적을수록 더 읽기 쉽다. 작은 테스트는 필요한 시기에 변경하기도 쉽다. 물론 이건 라인 수를 줄이려고 인위적으로 코드를 압축하지 않는 상황 아래서다. 테스트 코드의 품질은 제품 코드만큼 중요하다. 테스트를 작성할 때 절차를 생략하지 말라. 테스트 코드를 일급 시민으로 취급하라.
2. 테스트가 얼마나 실행하기 어려운가: 테스트가 외부 종속성으로 작동하면 데이터베이스 서버를 재부팅하고 네트워크 연결 문제를 해결하는 등 의존성을 상시 운영하는데 시간을 들여야 한다.

## 이상적인 테스트를 찾아서
4대 특성의 점수를 0점부터 1점까지로 매기고 각 점수를 곱한 것을 테스트의 가치 추정치가 된다. 따라서 어떤 것도 0점이 되어서는 안 된다.

### 이상적인 테스트를 만들 수 있는가?
이상적인 테스트가 되려면 각 속성의 점수를 모두 1이어야 한다. 하지만, 안타깝게도 그런 테스트를 만드는 건 불가능하다. 첫 세 가지 특성인 회귀 방지, 리팩터링 내성, 빠른 피드백은 상호 베타적이기 때문이다.

### 이상적인 테스트를 찾아서: 결론


> **_CAP 정리_**
> 
> 좋은 단위 테스트의 처음 세 가지 특성 간의 상충 관계는 CAP theorem과 유사하다. CAP 정리는 분산 데이터 저장소가 다음의 세 가지 특성을 모두 동시에 보증할 수 없다는 것을 나타낸다.
> 
> 1. 일관성(consistency): 모든 읽기가 가장 최근의 쓰기 또는 오류를 수신하는 것을 의미한다.
> 2. 가용성(availability): 모든 요청이 (시스템 내의 전체 노드 중단은 제외하고)응답을 수신하는 것을 의미한다.
> 3. 분할 내성(partition tolerance): 네트워크 분할(네트워크 노드 간 연결 끊김)에도 시스템이 계속 작동함을 의미한다.
> 
> 두 가지 비슷한 점은 다음과 같다.
> 
> 1. 세 가지 중 두 가지를 선택하는 절충안을 선택해야 한다.
> 2. 대규모 분산 시스템의 분할 내성도 타협할 수 없다. 예를 들어, 아마존 웹 사이트와 같은 대규모 애플리케이션은 단일 머신에서 작동할 수 없다. 분할 내성을 희생하면서 일관성과 가굥성을 선호하는 옵션은 고려하지 않는다. 아마존의 경우 아무리 큰 서버일지라도 서버 한 대에 저장하기에는 데이터가 너무 많다.
> 
> 그렇다면 결국 선택은 일관성과 가용성 간의 절충으로 귀결된다.

## 대중적인 테스트 자동화 개념 살펴보기
앞서 살펴본 좋은 단위 세트스의 네 가지 특성은 기초에 해당한다. 기존에 알려즌 모든 테스트 자동화 개념은 이 네 가지 특성으로 거슬러 올라갈 수 있다. 이번 절에서는 '테스트 피라미드'와 '화이트박스 테스트 대 블랙박스 테스트', 두 가지 개념을 공부해보자.

### 테스트 피라미드 분해
테스트 피라미드는 테스트 스위트에서 테스트 유형 간의 일정한 비율을 일컫는 개념이다.

테스트 피라미드는 종종 세 가지 유형의 테스트가 있는 피라마드로 표현한다. 이 피라미드는 단위 테스트 → 통합 테스트 → 엔드 투 엔드 테스트 순으로 가장 보편적인 것부터 덜 보편적인 것을 표현한다. 즉, 단위 테스트가 가장 많다. 그리고 엔드 투 엔드 테스트 → 통합 테스트 → 단위 테스트 순으로, 가장 위부터 아래로 위치하는데 이러한 층의 높이는 "최종 사용자의 동작을 얼마나 유사하게 흉내내는지"를 나타내는 척도이다. 따라서 엔드 투 엔드 테스트가 가장 사용자 경험에 가깝게 흉내낸다. 

이러한 피라미드 내의 테스트 유형에 따라 파른 피드백과 회귀 방지 사이에서 선택을 한다. 피라미드 상단의 테스트는 회귀 방지에 유리한 반면, 하단은 실행 속도에 유리하다.

하지만 어떤 계층도 리팩터링 내성을 포기하지는 않는다. 

테스트 피라미드에는 예외가 있다. 예를 들어 모든 애플리케이션이 비즈니스 규칙이나 기타 복잡도가 거의 없다면, 피라미드는 단위 테스트와 통합 테스트의 수가 같고 엔드 투 엔드 테스트가 없는 직사각형이 되버릴 것이다.

단위 테스트는 알고리즘이나 비즈니스 복잡도가 없는 환경에선 유용하지 않으므로 간단한 테스트 수준까지 빠르게 내려간다. 반면 통합 테스트는 그 가치가 잘 지켜진다. 코드가 아무리 단순하더라도 데이터베이스와 같은 외부 시스템과 통합되어 잘 작동하는지 확인하는 것은 중요하기 때문이다. 

### 블랙박스 테스트와 화이트박스 테스트 간의 선택
화이트박스 테스트는 회귀 방지에 강력하고 리팩터링 내성이 나쁘다. 반대로 블랙박스 테스트는 회귀 방지가 나쁘며 리팩터링 내성이 좋다.

리팩터링 내성은 타협할 수 없다. 즉, 테스트는 리팩터링 내성이 있거나 아예 없다. 따라서 블랙박스 테스트를 기본으로 선택하라. 그리고 문제 영역에 의미 있는 동작을 검증하자. 테스트를 통해 비즈니스 요구 사항으로 거슬러 올라갈 수 없다면, 이는 테스트가 깨지기 쉽다는 신호이다. 그런 테스트를 재구성하거나 삭제하라. 기존 테스트 스위트로 두지 마라. 유일한 예외는 알고리즘 복잡도가 높은 유틸리티 코드를 다루는 경우다.

