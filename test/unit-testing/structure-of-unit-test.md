# 단위 테스트 구조
## 단위 테스트를 구성하는 방법
준비, 실행, 검증 패턴을 사용해 단위 테스트를 구성하는 방법과 피해야 할 실수들, 그리고 테스트를 가능한 한 읽기 쉽게 만드는 방법 등을 살펴보자.

### AAA 패턴
AAA 패턴은 Arrange-Act-Assert 패턴의 약자로, 단위 테스트를 구성하는 데 사용되는 일반적인 패턴이다.

AAA 패턴은 스위트 내 모든 테스트가 단순하고 균일한 구조를 갖게 만든다. 이런 일관성이 이 패턴의 가장 큰 장점 중 하나다. 이 일관성에 익숙해지면 모든 테스트를 쉽게 읽을 수 있고 이해할 수 있다. 이 효과는 전체 테스트 스위트의 유지 보수 비용을 줄이는 것으로 이어진다. 구조는 다음과 같다.

1. 준비 구절에서는 테스트 대상 시스템(SUT)과 해당 의존성을 원하는 상태로 만든다.
2. 실행 구절에서는 SUT에서 메서드를 호출하고 준비된 의존성을 전달하고, 출력이 있으면 출력값을 캡쳐한다.
3. 검증 구절에서는 결과를 검증한다. 결과는 반환 값이나 SUT와 협력자의 최종 상태, SUT가 협력자에 호출한 메서드 등으로 표시될 수 있다.

테스트는 때때로 검증 구절로 시작하는 것도 가능하다. TDD를 실천할 때는 아직 기능이 어떻게 동작할지 충분히 알지 못한다. 따라서 먼저 기대하는 동작으로 윤곽을 잡은 다음, 그 기대에 부응하기 위한 시스템을 어떻게 구현할지 고민해보는 순서로 작업해도 좋다. 이 순서로의 테스트 작성이 적합한 경우는 TDD를 실천할 때, 즉 제품 코드를 작성하기 전에 테스트를 먼저 작성할 때 뿐이다.

### 여러 개의 준비, 실행, 검증 구절 피하기
> 여러 개의 준비, 실행, 검증 구절이 하나의 테스트 안에 있다는 건, 하나의 테스트가 너무 많은 것을 한 번에 검증한다는 신호이다. 그러한 테스트는 여러 테스트로 나누도록 하자.

여러 개의 준비, 실행, 검증 구절이 하나의 테스트에 있는, 그런 테스트는 더 이상 단위 테스트가 아닌 통합 테스트이다. 그런 테스트 구조는 피하는 것이 좋다. 실행이 하나면 테스트가 단위 테스트로써 남아있도록 보장하고, 간단하고, 빠르며, 이해하기 쉽다.

통합 테스트에선 실행 구절을 여러 개 두는 것이 괜찮을 때도 있다. 통합 테스트는 느릴 수 있다. 속도를 높이는 한 가지 방법은 여러 개의 통합 테스트를 여러 실행과 검증이 있는 단일한 테스트로 묶는 것이다. 시스템 상태의 흐름이 자연스럽다면, 즉 실행이 동시에 후속 실행을 위한 준비가 될 때 이런 방법은 특히나 좋은 효과를 낸다. 그러나 이런 최적화 기법은 통합 테스트에서만 적용될 수 있다는 걸 유의하자. 그리고 그 중에서도 이미 느리고 더 느려지게 하고 싶지 않은 테스트들만 한해서이다. 통합 테스트는 너무 느려지지 않게 관리하는 것이 많은 비용을 소모하게 하므로 항상 다단계 단위 테스트를 여러 개의 테스트로 나누는 것을 권장한다.

### 테스트 내 if 문 피하기
단위 테스트에는 if 문이 생길 수 있다. 하지만 그런 코드는 안티 패턴이다. 단위 테스트이던 통합 테스트 이던 분기가 없는 간단한 일련의 단계이어야 한다.

if 문이 테스트에 생겨난다면 그건 테스트가 한 번에 너무 많은 것을 검증한다는 신호이다. 만약 생겨난다면 그런 테스트는 반드시 여러 개의 테스트로 나뉘어야 한다. 여러 AAA 구절과 달리 통합 테스트에도 예외는 없다. 테스트에 분기가 있어서 얻는 이점은 없다. 단지 추가 유지비만 불어난다. if 문은 테스트를 읽고 이해하기 어렵게 만들기 때문이다.

### 각 구절은 얼마나 커야 하는가?


### 지침에 따른 테스트 이름 변경

> **_테스트명에 테스트 대상 메서드?_**
> 
> 테스트 이름에 SUT의 메서드 이름을 포함하지 마라.
> 
> 테스트 코드는 코드를 테스트하는 것이 아니라 애플리케이션 동작을 테스트하는 것임을 잊지말자.


## 테스트 간 테스트 픽스처 재사용
테스트에서 언제 어떻게 코드를 재사용해야할지 아는 것이 중요하다. 준비 구절에서 코드를 재사용하는 것이 테스트를 줄이면서 단순화하기 좋은 방법이다. 준비 구절에서의 코드 재사용은 테스트 픽스처를 활용하는 것이 좋을 것이다. 하지만 테스트 픽스처를 만드는데 코드를 너무 많이 작성해야 하는 데서 오는 위험도 있다. 

이러한 준비는 별도의 메서드나 클래스를 도출한 후 테스트 간에 재사용하는 것이 좋다. 재사용하는 방법은 두 가지가 있는데, 그 중 하나만 유용하다. 다른 하나는 유지비를 증가시킨다.

> **_잠깐!_**
> 
> 여기서 말하는 테스트 픽스처는 테스트 실행 대상 객체다. 즉, SUT로 전달되는 인수다. 이러한 객체는 각 테스트 실행 전에 알려진 고정 상태로 유지하기 때문에 동일한 결과를 생성한다. 그래서 픽스처라는 이름이 붙었다.

테스트 픽스처를 재사용하는 첫 번째 올바르지 않은 방법은 다음과 같이 테스트 클래스의 생성자에서 픽스처를 초기화하는 것이다.

```java
// 코드-1
class BuyerTest {
    private final Store store;
    private final Buyer sut; // 테스트 대상 시스템
    
    public BuyerTest() {
        store = new Store();
        store.addProduct(new Product("Widget", 10));
        sut = new Buyer();
    }
    
    // ...
}
```

위의 상황은 테스트의 메소드에 공통된 준비 구절이 존재해서 생성자로 추출한 상황이다. 따라서 테스트에는 준비 구절이 없다. 

이 방법은 테스트 코드의 양을 크게 줄일 수 있고, 테스트에서 테스트 픽스처 구성을 전부 또는 대부분 제거할 수 있는 방법이다. 그러나 두 가지 중요한 단점이 있다.

1. 테스트 간 결합도가 높아진다.
2. 테스트 가독성이 떨어진다. 

### 테스트 간의 높은 결합은 안티 패턴이다
코드-1에선 모든 테스트가 서로 결합되어 있다. 테스트의 준비 로직을 수정하면 클래스의 모든 테스트에 영향이 가기 때문이다. 

이는 중요한 지침을 위반한다. 테스트를 수정해도 다른 테스트에 영향을 주어서는 안된다. 이 지침은 테스트가 서로 격리되어 실행되어야 한다는 것과 비슷하다. 하지만 완전히 같진 않다. 여기서는 테스트의 독립적인 수정이지, 독립적인 실행이 아니기 때문이다. 하지만 둘 다 잘 설계된 테스트의 중요한 특성이다.

이 지침을 따르려면 테스트 클래스에 공유 상태를 두지 않아야 한다.

### 테스트 가독성을 떨어뜨리는 생성자 사용
준비 코드를 생성자에 둘 때의 또 다른 단점은 테스트 가독성을 떨어뜨리는 것이다. 그렇게 되면 테스트만 보고 전체 그림을 볼 수 없게 된다. 

준비 로직이 별로 없더라도 테스트 메소드로 바로 옮기는 것이 좋다. 

