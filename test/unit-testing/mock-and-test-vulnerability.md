이번에는 좋은 단위 테스트라고 할 수 있는 기준틀을 실제로 적용해보며 목의 약점과 강점에 대해 공부해볼 것이다.

미리 말하지만 목을 사용하는 건 논란의 여지가 있다. 어떤 사람들은 목이 훌륭한 도구라고 여기고, 어떤 사람들은 테스트 취약성을 초래하기에 목을 사용하는 것은 위험하다고 여긴다. 각각의 관점을 바라볼 때에 고전파와 런던파에 대한 논쟁을 다룰 것이다. 요컨대 두 분파 간 의견 차이는 테스트 격리 문제에 대한 견해에서 비롯된다. 런던파는 테스트 대상 코드 조각을 분리하고 불변 의존성을 제외한 모든 의존성에 테스트 대역을 써서 격리하자고 한다. 고전파는 단위 테스트를 분리해서 병렬로 실행할 수 있게 하자고 한다. 테스트 간에 공유하는 의존성에 대해서만 테스트 대역을 사용한다. 

목과 테스트 취약성 사이에는 깊고 불가피한 관련이 있다. 리팩터링 내성 저하 없이 목을 사용하는 방법을 살펴보자.

# 목과 스텁 구분
목은 테스트 대상 시스템(SUT)과 그 협력자 사이의 상호 작용을 검사할 수 있는 테스트 대역이다. 테스트 대역엔 또 다른 유형이 있는데, 바로 스텁(Stub)이다. 

## 테스트 대역 유형
테스트 대역은 모든 유형의 '비운영용 가짜 의존성'을 설명하는 포괄적인 용어다. 테스트 대역의 주 용도는 테스트를 편리하게 하는 것이다. 하지만 SUT으로 실제 의존성 대신 전달되므로 설정이나 유지보수가 어려울 수 있다. 

제라드 메스자로스에 의하면 테스트 대역에는 더미, 스텁, 스파이, 목, 페이크 라는 다섯 가지 유형이 있다. 이렇듯 여러 가지 유형이 있지만, 실제론 목과 스텁으로 두 가지 유형으로 나눌 수 있다. 두 유형의 차이점은 다음과 같다.

- 목은 외부로 나가는 상호 작용을 모방하고 검사하는 데에 쓰임이 있다. 이런 상호 작용은 SUT가 상태를 변경하기 위해 의존성을 호출하는 것에 해당한다.
- 스텁은 내부로 들어오는 상호 작용을 모방하는데에 있다. 이러한 상호 작용은 SUT가 입력 데이터를 얻기 위한 의존성을 호출하는 것에 해당한다.

여기서 중요한 점은 차이점에 있다. 목은 상호 작용을 모방하고 검사하는데, 스텁은 모방만 한다.

## 도구로서의 목과 테스트 대역으로서의 목
목은 테스트 대역의 의미로 사용되긴 하지만 테스트 대역의 일부일 뿐이다. 목 라이브러리의 클래스도 목으로 볼 수 있다. 이 클래스는 실제 목을 만드는 데 도움이 되지만, 그 자체로는 목이 아니다. 

테스트는 목 라이브러리의 클래스를 사용할 수 있다. 이 클래스는 테스트 대역(목)을 만들 수 있는 도구다. 다시 말해 Mock 클래스는 도구로서의 목인데, 해당 클래스의 오브젝트인 mock은 테스트 대역으로서의 목이다. 도구로서의 목을 사용해 목과 스텁, 두 가지 유형의 테스트 대역을 생성할 수 있기 때문에 '도구로서의 목'과 '테스트 대역으로서의 목'을 혼동하지 않는 것이 중요하다.

```java
public void creatingAReport() {
    var stub = new Mock<MyDatabase>();
    when(stub.getNumberOfReport()).thenReturn(10);
    var sut = new ReportController(stub);
    
    Report report = sut.createReport();
    assertThat(report.getNumberOfReport()).isEqualTo(10);
}
```
위의 테스트 대역은 내부로 들어오는 상호 작용, 즉 SUT에 입력 데이터를 제공하는 호출을 모방한다. 외부로 나가는 상호 작용을 모방하는, 사이드 이펙트를 일으키는 호출을 모방하는 테스트 대역과는 다르다.

## 스텁으로 상호 작용을 검증하지 마라
목은 상호 작용을 모방하고 검사하는 반면, 스텁은 상호 작용만 모방하고 검사는 하지 않는다. 이 차이는 스텁과의 상호 작용을 검증하지 말라는 지침에서 비롯된다. SUT에서 스텁으로의 호출은 SUT가 생성하는 최종 결과가 아니다. 최종 결과를 산출하기 위한 수단일 뿐이다.

테스트에서 거짓 양성을 피하고 리팩터링 내성을 향상시키는 방법은 구현 세부 사항이 아닌 최종 결과를 검증하는 것 뿐이다. 최종 결과가 아닌 사항을 검증하는 관행을 과잉 명세(overspecification)라고 부른다. 과잉 명세는 상호 작용을 검사할 때 가장 흔하게 발생한다. 스텁의 상호 작용은 쉽게 발견되기에 관리가 어렵지 않지만 목은 더 복잡하다. 

## 목과 스텁은 명령과 조회에 어떻게 관련돼 있는가?
목과 스텁의 개념은 명령 조회 분리(CQS, Command Query Separation) 원칙과 관련이 있다. 이 원칙에 따르면 모든 메소드는 명령이거나 조회이어야 하며, 둘을 혼용해서는 안 된다.

명령은 사이드 이펙트를 일으키고 어떤 값도 반환하지 않는 메소드이다. 조회는 그 반대로, 사이드 이펙트가 없고 값을 반환한다.

이 원칙을 따르고자 한다면 메서드가 사이드 이펙트를 일으키면 반환 타입이 void인지 확인하라. 그게 아니라 메서드가 값을 반환하면 사이드 이펙트가 없어야 한다. 즉, 질문을 할 때 답이 달라져서는 안 된다. 이렇게 명확하게 분리하면 코드를 읽기 쉬워진다. 구현 세부 사항을 보지 않고 시그니처만 봐도 메서드가 뭘 하는 건지 알 수 있기 때문이다.

물론 항상 이 원칙을 딸르 수 있는 것은 안디ㅏ. 그래도 가능할 때마다 따르는 것이 좋다.

명령을 대체하는 건 목이다. 조회를 대체하는 건 스텁이다.

# 식별할 수 있는 동작과 구현 세부 사항
테스트 취약성은 '좋은 단위 테스트'의 두 번째 특성인 리팩터링 내성에 해당한다. 단위 테스트에 리팩터링 내성 지표가 있는지 여부는 대부분 이진 선택이므로 리팩터링 내성 지표가 가장 중요하다. 따라서 테스트가 단위 테스트 영역에 있고 엔드 투 엔드 테스트 범주로 바뀌지 않는 한 리팩터링 내성을 최대한 활용하는 것이 좋다. 엔드 투 엔드 테스트 범주로 넘어가면, 리팩터링 내성이 뛰어나도 유지보수가 훨씬 까다로워진다.

테스트에 거짓 양성이 있는 주요한 원인은 구현 세부 사항과의 강결합에 있다. 이런 강결합을 피하는 방법은 코드가 생성하는 최종 결과를 검증하고 구현 세부 사항과 테스트를 가능한 한 멀리 떨어뜨리는 것뿐이다. 즉, 테스트는 '어떻게'가 아닌 '무엇'에 중점을 두어야 한다. 그렇다면 구현 세부 사항은 정확히 무엇이며 식별할 수 있는 동작과 어떻게 다를까?

## 식별할 수 있는 동작은 공개 API와 다르다
모든 제품 코드는 2차원으로 분류할 수 있다.

- 공개 API와 비공개 API
- 식별할 수 있는 동작과 구현 세부 사항

그리고 각 차원의 범주는 겹치지 않는다. 

식별할 수 있는 동작과 구현 세부 사항은 미묘한 차이가 있다. 코드가 시스템의 식별할 수 있는 동작이려면 다음 중 하나를 해야 한다.

- 클라이언트가 목표를 달성하는 데 도움이 되는 연산을 노출하라. 연산은 계산을 수행하거나 사이드 이펙트를 초래하거나 둘 다 하는 메서드다.
- 클라이언트가 목표를 달성하는 데 도움이 되는 상태를 노출하라. 이는 시스템의 현재 상태다.

구현 세부 사항은 이 두 가지 중 무엇도 하지 않는다.

이상적으로 공개 API는 식별할 수 있는 동작과 일치해야 하며, 모든 구현 세부 사항은 클라이언트 눈에 보이지 않아야 한다. 그런 API를 "설계가 잘 되어 있다." 라고 한다.

## 잘 설계된 API와 캡슐화
잘 설계된 API를 유지보수 하는 것은 캡슐화 개념과 관련이 이다. 캡슐화는 불변성 위반을 방지하는 조치다. 불변성은 항상 참이어야 하는 조건이다. 

불변성 위반으로 구현 세부 사항을 노출할 수 있다. 즉, 구현 세부 사항을 노출하면 불변성 위반을 가져온다. 클라이언트는 불변성을 우회해서 이름 길이에 대한 불변성을 지키지 않고 이름을 할당할 수 있기 때문이다. 

장기적으로 코드베이스 유지 보수에서는 캡슐화가 중요하다. 복잡도 때문이다. 코드 복잡도는 소프트웨어 개발해서 가장 큰 어려움 중 하나다. 코드베이스가 복잡해질수록 작업하기가 더 어려워지고, 개발 속도가 느려지고, 버그 수가 증가하게 된다.

계속해서 증가하는 코드 복잡도에 대처할 수 있는 방법은 실질적으로 캡슐화 말고 없다. 코드 API가 해당 코드로 할 수 있는 것과 할 수 없는 것을 알려주지 않으면 코드가 변경됐을 때 모순이 생기지 않도록 많은 정보를 염두에 두어야 한다. 이는 프로그래밍 과정에 정신적 부담을 증대시킨다. 최대한 부담을 덜어내자. 개발자 스스로 항상 옳게만 한다고 믿을 수 없으니 실수할 가능성을 최대한 없애라. 그렇게 하는 데에 가장 좋은 방법이 캡슐화를 올바르게 유지해 코드베이스에서 잘못할 수 있는 옵션조차 제공하지 않도록 하는 것이다. 캡슐화는 궁극적으로 단위 테스트와 동일한 목표를 달성한다. 즉, 소프트웨어의 지속적인 성장을 가능하게 한다.

'묻지 말고 답하라, tell-don't-ask'라는 유사한 원칙이 있다. 이는 마틴 파울러가 고안한 것으로, 데이터를 연산 기능과 결합하는 것을 의미한다. 이 원칙을 캡슐화 실천의 귀결로 볼 수 있다. 코드 캡슐화가 목표이지만, 구현 세부 사항을 숨기고 데이터와 기능을 결합하는 것이 해당 목표를 달성하기 위한 수단이다.

# 목과 테스트 취약성 간의 관계
## 시스템 내부 통신과 시스템 간 통신
시스템 내부 통신은 식별할 수 있는 동작이 아니므로 구현 세부 사항에 해당한다. 이에 반해 시스템 외부 환경과 통신하는 방식은 전체적으로 해당 시스템의 식별할 수 있는 동작을 나타낸다. 이는 애플리케이션에 항상 있어야 하는 계약이다. 

시스템 간 통신의 특성은 별도 애플리케이션과 함께 성장하는 방식에서 비롯된다. 성장의 주요 원칙 중 하나로 하위 호환성을 지켜야 한다는 것이 있다. 시스템 내부에서 하는 리팩터링과는 다르게, 외부 애플리케이션과 통신할 때 사용하는 통신 패턴은 항상 외부 애플리케이션이 이해할 수 있도록 유지해야 한다. 예를 들어 애플리케이션이 메세지 버스로 전송하는 메세지는 구조를 지키고, SMTP 서비스 호출은 매개변수의 유형과 개수 등을 맞춰야 한다.

목을 사용하면 시스템과 외부 애플리케이션 간의 통신 패턴을 확인할 때 좋다. 반대로 시스템 내 클래스 간의 통신을 검증하는 데에 사용하면 테스트가 구현 세부 사항과 결합되며, 그에 따라 리팩터링 내성 지표가 미흡해진다.

# 단위 테스트의 고전파와 런던파 재고
런던파는 불변 의존성을 제외한 모든 의존성에 목 사용을 권장하며 시스템 내 통신과 시스템 간 통신을 구분하지 않는다. 그 결과, 테스트는 애플리케이션과 외부 시스템 간의 통신을 확인하는 것처럼 클래스 간 통신도 확인한다. 이렇게 런던파를 따라 목을 무분별하게 사용하면 종종 구현 세부 사항에 결합돼 테스트에 리팩터링 내성이 없게 된다. 리팩터링 내성은 대부분 이진 선택이다. 내성이 있거나 아예 없다. 그리고 리팩터링 내성이 저하되면 테스트는 가치가 없어진다.

고전파는 테스트 간에 공유하는 의존성만 목으로 교체하자고 하므로 이 문제에 대해서 훨씬 유리하다. 그러나 고전파 역시 시스템 간 통신에 대한 처리에 이상적이진 않다. 런던파만큼은 아니지만, 고전파도 목 사용을 지나치게 장려한다.

## 모든 프로세스 외부 의존성을 목으로 대체해야 하는 것은 아니다
프로세스 외부 의존성과 목을 설명하기 전 의존성 유형에 대해서 다시 훑어보자.

- **공유 의존성**: 테스트 간에 공유하는 의존성( 제품 코드가 아님 )
- **프로세스 외부 의존성**: 프로그램의 실행 프로세스 외에 다른 프로세스를 점유하는 의존성( 예를 들어 데이터베이스, 메세지 버스, SMTP 서비스 등 )
- **비공개 의존성**: 공유하지 않는 모든 의존성

고전파에서는 공유 의존성을 피하라고 권고한다. 테스트가 실행 컨텍스트를 서로 방해하고 결국 병렬 처리를 할 수 없게 되기 때문이다. 테스트를 병렬적, 순차적 또는 임의의 순서로 실행될 수 있는 걸 테스트 격리라고 한다.

공유 의존성이 프로세스 외부에 있는 게 아니면 각 테스트 실행 시 해당 의존성을 새 인스턴스로 사용해 재사용을 피하기 쉽다. 그게 아니라 외부에 있으면, 테스트가 더 복잡해진다. 각 테스트 실행 전에 데이터베이스를 인스턴스화하거나 메세지 버스를 새로 준비할 수가 없기 때문이다(그렇게 하면 너무 느려지기 때문). 일반적인 접근법은 이런 의존성을 테스트 대역, 즉 목과 스텁으로 대체하는 것이다.

그러나 모든 프로세스 외부 의존성을 목으로 대체해야 하는 건 아니다. 프로세스 외부 의존성에 애플리케이션을 통해서만 접근할 수 있다면, 그러한 의존성과의 통신은 시스템에서 식별할 수 있는 동작이 아니다. 실제로 외부에서 관찰할 수 없는 프로세스 외부 의존성은 애플리케이션의 일부로 작용한다.

애플리케이션과 외부 시스템 간의 통신 패턴을 항상 지켜야 하는 요구사항은 하위 호환성을 지켜야 한다는 점에서 비롯된다. 애플리케이션이 외부 시스템과 통신하는 방식을 지켜야 한다. 애플리케이션과 외부 시스템을 동시에 변경할 수 없기 때문이다. 또한 배포 주기가 다르거나 단순히 제어 권한이 없을 수 있기 때문이다. 

그러나 애플리케이션이 외부 시스템에 대한 프록시 같은 역할을 하고 클라이언트가 직접 접근할 수 없으면, 하위 호환성 요구사항은 사라진다. 이제 이 외부 시스템과 애플리케이션을 같이 배포할 수 있으면 클라이언트에 영향을 미치지 않을 것이다. 이런 시스템의 통신 패턴은 구현 세부 사항이된다. 

완전히 통제권을 가진 프로세스 외부 의존성에 목을 사용하면 깨지기 쉬운 테스트로 이어진다. 데이터베이스와 애플리케이션은 하나의 시스템으로 취급해야 한다.

## 목을 사용한 동작 검증
종종 목이 동작을 검증한다고 한다. 하지만 대부분의 경우 그렇지 않다. 목표를 달성하고자 각 개별 클래스가 이웃 클래스와 소통하는 방식은 식별할 수 있는 동작과 아무 관계가 없다.

클래스 간의 통신을 검증하는 것은 너무 세밀한 것을 시도하는 작업이다. 그보다 중요한 것은 클라이언트의 목표로 거슬러 올라갈 수 있는 능력이 테스트에 부여됐는지이다. 클라이언트는 도움을 청할 때 구현 세부 사항을 신경쓰지 않는다. 클라이언트에게 중요한 건 도움뿐이다. 물론 신뢰할 수 있고 전문적인 방식일 것이다. 목은 애플리케이션의 경계를 넘나드는 상호 작용을 검증할 때와 이런 상호 작용의 사이드 이펙트가 외부 환경에서 보일 때만 동작과 관련이 있다.

