단위 테스트 스타일에는 출력 기반, 상태 기반, 통신 기반이라는 세 가지 유형이 있다. 출력 기반이 가장 품질이 좋고, 그 다음으로 상태 기반, 마지막으로 통신 기반이다. 하지만 출력 기반 스타일을 아무데서나 사용할 수는 없고, 순수 함수 방식으로 작성된 코드에서만 가능하다. 그러나 걱정하진 말자. 출력 기반 스타일로 변환하는 데에 도움이 될 기법들이 있다. 이를 위해 함수형 프로그래밍 원칙을 사용해 기반 코드가 함수형 아키텍처를 지향하게끔 구성해야 한다.

# 단위 테스트의 세 가지 스타일
## 출력 기반 테스트란
이 스타일은 테스트 대상 시스템(SUT)에 입력을 넣고 생성되는 출력을 검증하는 방식이다. 이 스타일은 전역 상태나 내부 상태를 변경하지 않는 코드에만 적용되므로 반환 값만 검증하면 된다.

이러한 스타일을 띄는 메서드는 내부 컬렉션에 인스턴스를 추가하거나 데이터베이스에 데이터를 저장하지 않는다. 결과는 반환된 값 뿐이다.

출력 기반 단위 테스트 스타일은 함수형이라고도 한다. 이 이름은 사이드 이펙트 없는 코드 선호를 강조하는 프로그래밍 방식인 함수형 프로그래밍(funtional programming)에 뿌리를 두고 있다.

## 상태 기반 스타일이란
이 스타일은 작업이 완료된 후 시스템 상태를 확인하는 것이다. 이 스타일에서 '상태'라는 용어는 SUT나 협력자 중 하나, 또는 데이터베이스나 파일 시스템 등과 같은 프로세스 외부 의존성의 상태 등을 의미할 수 있다. 

## 통신 기반 스타일 정의
마지막으로 살펴볼 세 번째 단위 테스트 스타일은 통신 기반 테스트다. 이 스타일은 목을 사용해 SUT와 협력자 간의 통신을 검증한다.

# 단위 테스트 스타일 비교
각 스타일을 좋은 단위 테스트의 4대 요소로 비교해보자.

## 회귀 방지와 피드백 속도 지표로 스타일 비교하기
먼저 회귀 방지 지표는 다음 세 가지 특성으로 결정된다.

1. 테스트 중에 실행되는 코드의 양
2. 코드 복잡도
3. 도메인 유의성

보통 실행하는 코드의 양이 어찌됐건 원하는 대로 테스트를 작성할 수 있다. 어떤 스타일도 이 부분에서 도움이 되지 않는다. 코드 복잡도와 도메인 유의성도 마찬가지다. 

다음으로, 테스트 스타일과 테스트 피드백 속도 사이에도 상관관계가 거의 없다. 테스트가 프로세스 외부 의존성과 떨어져 단위 테스트 영역에 있는 한, 모든 스타일은 테스트 실행 속도가 거의 동일하다. 목은 런타임에 지연 시간이 생기는 편이라 통신 기반 테스트가 약간 나쁠 순 있다.

## 리팩터링 내성 지표로 비교하기
리팩터링 내성은 리팩터링 중 발생하는 거짓 양성(허위 경보) 수에 대한 척도다. 결국 거짓 양성은 식별할 수 있는 동작이 아니라 코드 구현 세부 사항에 결합된 테스트의 결과다.

출력 기반 테스트는 테스트가 SUT에만 결합되므로 거짓 양성 방지가 가장 우수하다. 이런 테스트가 구현 세부 사항과 결합하는 경우는 SUT가 구현 세부 사항일 때 뿐이다.

상태 기반 테스트는 일반적으로 거짓 양성이 되기 쉽다. 이런 테스트는 테스트 대상 메서드 외에도 클래스 상태와 함께 작동한다. 상태 기반 테스트는 큰 API 노출 영역에 의존하므로, 구현 세부 사항과 결합할 가능성도 더 높다.

통신 기반 테스트가 허위 경보에 가장 취약하다. 테스트 대역으로 상호 작용을 확인하는 테스트는 깨지기 쉽기 때문이다. 이는 항상 스텁과 상호 작용하는 경우다. 이런 상호 작용을 확인해선 안 된다. 애플리케이션 경계를 넘는 상호 작용을 확인하거나 해당 상호 작용의 사이드 이펙트가 외부 환경에 보이는 경우에만 목이 괜찮다. 리팩터링 내성을 잘 지키렴녀 통신 기반 테스트를 사용할 때 더 신중해야 한다.

그러나 피상적인 테스트가 통신 기반 테스트의 결정적인 특징이 아닌 것처럼, 불안정성도 통신 기반 테스트의 결정적인 특성이 아니다. 캡슐화를 잘 지키고 테스트를 식별할 수 있는 동작에만 결합하면 거짓 양성을 최소로 줄일 수 있다.

## 유지 보수성 지표로 비교하기
마지막으로 유지 보수성 지표는 단위 테스트 스타일과 밀접한 관련이 있다. 그러나 리팩터링 내성과 달리 완화할 수 있는 방법이 많지 않다. 유지 보수성은 단위 테스트의 유지비를 측정하며, 다음 두 가지 특성으로 정의한다.

1. 테스트를 얼마나 이해하기 어려운가?
2. 테스트를 얼마나 실행하기 어려운가?

테스트가 크면, 필요할 때 파악하기도 변경하기도 어려우므로 유지 보수가 쉽지 않다. 테스트가 하나 이상의 프로세스 외부 의존성을 가지면 데이터베이스 서버 재부팅, 네트워크 연결 문제 등 운영하는 데 비용이 많이 필요해 유지 보수가 어렵다.

## 출력 기반 테스트의 유지 보수성
다른 두 가지 스타일과 비교하면, 출력 기반 테스트가 가장 유지 보수하기 용이하다. 출력 기반 테스트는 거의 항상 짧고 간결하다. 이런 점은 메서드를 입력을 공급하는 것과 해당 출력을 검증하는 두 가지로 요약할 수 있다는 점에서 비롯된다. 

출력 기반 테스트의 기반 코드는 전역 상태나 내부 상태를 변경할리 없으므로, 프로세스 외부 의존성을 다루지 않는다. 따라서 두 가지 유지 보수성 측면 모두에서 출력 기반이 가장 우수하다.

## 상태 기반 테스트의 유지 보수성
상태 기반 테스트는 일반적으로 출력 기반 테스트보다 유지 보수가 쉽지 않다. 상태 검증은 종종 출력 검증보다 더 많은 공간을 차지하기 때문이다. 예시로 글에 댓글을 추가한 후 댓글 목록에 댓글이 나타나는지 확인하는 테스트는 단순하고 댓글이 하나만 있음에도, 검증부는 (댓글 수, 내용, 저자, 생성 날짜) 등등 여러 줄에 걸쳐 작성된다. 상태 기반 테스트는 종종 훨씬 많은 데이터를 확인해야 하므로 크기가 대폭 커질 수 있다.

그런 코드를 숨기고 테스트 크기를 축소시키는 헬퍼 메서드로 문제를 완화할 수 있지만 그런 메서드를 작성하고 유지하는 데에 들어가는 비용이 크다. 여러 테스트에서 그런 메서드를 재사용할 때만 그런 노력에 명분이 생기지만, 그런 경우가 드물다. 

상태 기반 테스트를 단축하는 또 다른 방법으로, 검증 대상 클래스의 동등 멤버를 정의할 수 있다. 하지만 이는 본질적으로 클래스가 값에 해당하고 값 객체로 변환할 수 있을 때만 효과적이다. 그렇지 않으면 코드 오염(code pollution)으로 이어진다.

그런 두 가지 기법은 가끔만 적용할 수 있다. 그리고 적용할 수 있다 하더라도 상태 기반 테스트는 출력 기반 테스트보다 공간을 더 많이 차지하므로 유지 보수성이 떨어진다.

## 통신 기반 테스트의 유지 보수성
이 친구는 상태 기반 테스트보다도 더 점수가 낮다. 통신 기반 테스트에는 테스트 대역과 상호 작용 검증을 설정해야 하며, 이는 공간을 많이 차지 않다. 목이 사슬 형태로 있을 때(mock chain, 목이 다른 목을 반환하고 그 다른 목이 또 다른 목을 반환하는 식), 테스트는 더 커지고 유지 보수하기 어려워진다.

# 함수형 아키텍처 이해
## 함수형 프로그래밍이란?
함수형 프로그래밍은 수학적 함수를 사용한 프로그래밍이다. 수학적 함수는 숨은 입출력이 없는 함수다. 수학적 함수의 모든 입출력은 메서드 이름, 인수, 반환 타입으로 구성된 메서드 시그니처에 명시해야 한다. 수학적 함수는 호출 횟수에 상관없이 주어진 입력에 대해 동일한 출력을 생성한다. 

입출력을 명시한 수학적 함수의 테스트는 짧고 간결하며 이해와 유지 보수가 쉬워 테스트하기가 쉽다. 출력 기반 테스트를 적용할 수 있는 메서드 유형은 수학적 함수뿐이다. 이는 유지 보수성이 뛰어나고 거짓 양성 빈도가 낮다.

반면 숨은 입출력은 코드를 테스트하기 힘들게 한다. 숨은 입출력의 유형은 다음과 같다. 

- **사이드 이펙트**: 사이드 이펙트는 메서드 시그니처에 표시되지 않은 출력으로, 따라서 숨어있다. 연산은 클래스 인스턴스의 상태를 변경하고 디스크의 파일을 업데이트 하는 등 사이드 이펙트를 발생시킨다.
- **예외**: 메서드가 예외를 던지면 프로그램 흐름에 '메서드 시그니처에 설정된 계약을 우회하는 경로'를 만든다. 호출된 예외는 호출 스택의 어느 곳에서도 발생할 수 있으므로, 메서드 시그니처가 전달하지 않는 출력을 추가한다.
- **내외부 상태에 대한 참조**: 클래스 중엔 정적 속성을 사용해 어떤 값을 가져오는 메서드가 있을 수 있다. 데이터베이스에 데이터를 질의할 수 있고, 비공개 변경 가능 필드를 참조할 수도 있다. 이것들 모두 메서드 시그니처에 없는 실행 흐름에 대한 입력이며, 따라서 숨어있다. 

## 함수형 아키텍처란?
함수형 프로그래밍의 목표는 사이드 이펙트를 완전히 제거하는 것이 아니라 비즈니스 로직을 처리하는 코드와 사이드 이펙트를 일으키는 코드를 분리하는 것이다. 이 두 가지 책임은 각각만 보더라도 충분히 복잡하다. 모두 고려하면 복잡도가 배가 되고 장기적으로 코드의 유지 보수성을 방해한다. 함수형 아키텍처는 바로 그런 곳에 적용된다. 사이드 이펙트를 비즈니스 연산 끝으로 몰아서 비즈니스 로직을 사이드 이펙트와 분리한다. 

> 함수형 아키텍처는 사이드 이펙트를 다루는 코드를 최소화하면서 순수 함수(불변) 방식으로 작성한 코드의 양을 극대화한다. 

다음 두 가지 코드 유형을 구분지어 비즈니스 로직과 사이드 이펙트를 분리할 수 있다.

1. **결정을 내리는 코드**: 이 코드는 사이드 이펙트가 필요 없기 때문에 수학적 함수를 사용해 작성할 수 있다.
   1. '결정을 내리는 코드'를 **함수형 코어**라고도 부른다.
2. **해당 결정에 따라 작용하는 코드**: 이 코드는 수학적 함수에 의해 이뤄진 모든 결정을 데이터베이스의 변경이나 메세지 버스로 전송된 메세지와 같이 가시적인 부분으로 변환한다.
   1. '해당 결정에 따라 작용하는 코드'를 **가변 셸**이라고도 부른다. 

함수형 코어와 가변 셸은 다음과 같은 방식으로 협력한다.

- 가변 셸은 모든 입력을 수집한다.
- 함수형 코어는 결정을 생성한다.
- 셸은 결정을 사이드 이펙트로 변환한다.

이 두 계층을 계속 잘 분리하려면, 가변 셸이 의사 결정을 추가하지 않게끔 결정을 나타내는 클래스에 정보가 충분히 있는지 확인해야 한다. 목표는 출력 기반 테스트로 함수형 코어를 두루 다루고 가변 셸을 훨씬 더 적은 수의 통합 테스트에 맡기는 것이다.

### 캡슐화와 불변성
캡슐화처럼 일반적으로 함수형 아키텍처와 (특히) 불변성은 단위 테스트와 같은 목표가 있다. 소프트웨어 프로젝트의 지속적인 성장을 가능케 하는 것이다. 실제로 캡슐화 개념과 불변성 개념 사이에는 깊은 연관성이 있다.

캡슐화는 코드에 모순이 생기지 않도록 보호하는 행위이다. 캡슐화는 다음을 통해 클래스 내부가 변질되지 않도록 보호한다.

- 데이터 수정이 가능한 API 노출 영역 축소
- 나머지 API를 철저히 조사

불변성은 다른 각도에서 존재하는 불변을 해결한다. 불변 클래스를 사용하면 변경할 수 없는 것을 처음부터 변형할 수 없으므로 상태 변질에 대해 걱정할 필요가 없다. 결과적으로 함수형 프로그래밍에서 캡슐화를 할 필요가 없으며, 인스턴스를 만들 때 클래스의 상태를 한 번만 확인하면 된다. 그 후에 그 인스턴스를 자유롭게 전달할 수 있다. 모든 데이터가 불변일 때 캡슐화가 되지 않아 생긴 문제는 모두 간단히 사라진다.

그런 점에서 마이클 페더스의 훌륭한 문장을 다음과 같이 인용할 수 있다.

"""
객체 지향 프로그래밍은 작동 부분을 캡슐화해 코드를 이해할 수 있게 한다. 함수형 프로그래밍은 작동 부분을 최소화해 코드를 이해할 수 있게 한다.
"""

## 함수형 아키텍처와 육각형 아키텍처 비교
둘은 비슷한 점이 많다. 둘 다 관심사 분리라는 아이디어를 기반으로 한다. 그러나 분리를 둘러싼 구체적인 내용은 다양하다.

그리고 결정과 실행을 분리하는 함수형 아키텍처와 육각형 아키텍처는 매우 유사하다.

또 다른 유사점은 의존성 간의 단방향 흐름이다. 함수형 아키텍처의 불변 코어는 가변 셸에 의존하지 않는다. 이로 인해 함수형 아키텍처를 테스트하기 쉽다. 가변 셸에서 불변 코어를 완전히 떼어내 셸이 제공하는 입력을 단순한 값으로 모방할 수 있기 때문이다.

이 둘의 차이점은 사이드 이펙트에 대한 처리에 있다. 함수형 아키텍처는 모든 사이드 이펙트를 불변 코어에서 비즈니스 연산 가장자리로 밀어낸다. 그 가장자리는 가변 셸이 처리한다. 반면 육각형 아키텍처는 도메인 계층에 제한해서, 도메인 계층으로 인한 사이드 이펙트가 없다. 육각형 아키텍처의 모든 수정 사항은 도메인 계층 내에 있어야 하며, 계층의 경계를 넘어선 안 된다. 

# 함수형 아키텍처와 출력 기반 테스트로의 전환
## 함수형 아키텍처로 리팩터링 하기
함수형 코어가 생성한 명령은 항상 값이거나 값 집합이다. 값은 내용이 일치하는 한, 두 인스턴스를 서로 바꿀 수 있다. 이 사실을 활용하면, 테스트 대상 메서드가 반환하는 타입을 값 객체로 전환해서 테스트 가독성을 더욱 향상시킬 수 있다. 