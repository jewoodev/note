# 목 처리에 대한 모범 사례
목은 테스트 대상 시스템과 의존성 관의 상호 작용을 모방하고 검사하는데 도움이 되는 테스트 대역이다. 그리고 목은 비관리 의존성에만 적용해야 한다. 다른 것에 적용하면 깨지기 쉬운(리팩터링 내성이 없는) 테스트가 된다. 

목 처리에 대한 모범 사례를 알아보며 리팩터링 내성과 회귀 방지가 최대화될 수 있게 만드는 연습을 해보자.

## 목의 가치를 극대화하기
비관리 의존성에만 목을 사용하는 관습은 목의 가치를 극대화하기 위한 첫 번째 단계일 뿐이다. 

### 시스템 끝에서 상호 작용 검증하기
애플리케이션의 외부 의존 관계가 있는 상황을 떠올리자. 이 때 우리의 애플리케이션은 다음과 같이 작성되어 있다.

1. 이메일에 관련된 이메일 회사의 SDK 라이브러리 위에 있는 래퍼 인터페이스 `MySender`가 있다.
   1. 이 래퍼는 연결 자격 증명처럼 꼭 필요하지는 않은 기술 세부 사항을 캡슐화하고, 임의의 텍스트 데이터를 전송할 수 있는 인터페이스다.
2. `MySender` 타입의 멤버 변수를 갖는 래퍼 인터페이스 `MyEmailSender`가 있다.
   1. 이 래퍼는 도메인과 관련한 메세지를 정의한다.

이런 구조를 육각형 아키텍처 관점에서 바라보면 외부 클라이언트 육각형과 가장 먼저 만나는 것이 컨트롤러이고, 메세지 버스 육각형과 가장 먼저 만나는 것이 `MySender`이다. `MySender`는 컨트롤러와 메세지 버스 사이의 타입 사슬에서 마지막 고리이며, `MyEmailSender`는 중간이다.

`MyEmailSender` 대신 `MySender`를 목으로 처리하면 회귀 방지를 극대화할 수 있다. 회귀 방지는 테스트 중에 실행되는 코드 양에 대한 함수다. 비관리 의존성과 통신하는 마지막 타입을 목으로 처리하면 통합 테스트가 거치는 클래스의 수가 증가하게 되기에 보호가 강력해진다. `MySender`는 `MyEmailSender` 보다 더 시스템 끝에 위치한다.

회귀 방지가 좋아질 뿐만 아니라 리팩터링 내성도 향상된다. 그 이유는 사용자 정의 클래스에 대한 호출을 검증하는 것과 외부 시스템에 전송하는 실제 텍스트 사이의 큰 차이에 있다. 외부 시스템은 애플리케이션으로부터 텍스트 메세지를 수신할 뿐, `MyEmailSender` 같은 클래스를 호출하지 않는다. 실제 텍스트 메세지만이 외부에서 식별할 수 있는, 유일한 사이드 이펙트이다. 이런 메세지를 생성하는 데에 참여하는 클래스는 단지 구현 세부 사항에 지나지 않는다. 결국 테스트는 잠재적인 거짓 양성에 노출될 가능성이 낮아진다. 리팩터링을 하더라도 메세지 구조를 유지하는 한, 테스트는 실패하지 않는다.