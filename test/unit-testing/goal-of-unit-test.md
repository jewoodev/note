# 단위 테스트의 목표
1. 더 나은 설계: 흔히 단위 테스트 작성이 더 나은 설계로 이어진다고 이야기되어진다. 하지만 이건 주목표는 아니다. 단지 좋은 사이드 이펙트일 뿐이다.
2. 지속 가능한 성장을 가능하게: 처음에는 잘못된 기술적 결정이 없고, 걱정할만한 코드도 없다. 빨리 시작할 수 있는 상황에서 테스트는 발목을 잡는 것처럼 보인다. 하지만 프로젝트가 진행될 수록 개발 속도가 현저히 느려지고, 심지어 아예 진행하지 못할 정도로 느려질 수도 있다.
   1. 지속적인 정리와 리팩터링 등과 같은 적절한 관리 없이 방치되면 시스템이 점점 더 복잡해지고 무질서해진다. 
   2. 하나의 버그를 수정하면 더 많은 버그를 양산하고, 소프트웨어의 한 부분을 수정하면 다른 부분이 고장난다. 결국 코드베이스를 신뢰할 수 없게 된다.
3. 지속성과 확장성이 핵심이며, 이를 통해 장기적으로 개발 속도를 유지할 수 있다.

# 커버리지 지표
프로그래머가 특정 커버리지 숫자를 목표로 하는 것은 해로우며 테스트 스위트 품질을 결정하는데에 커버리지 지표에 의존할 수 없다. 그 이유를 알아보자.

커버리지 지표가 너무 적을 때는 테스트가 충분치 않다는 좋은 증거이다. 그러나 반대의 경우는 그렇지 않다. 100% 커버리지라고 해서 반드시 양질의 테스트 스위트라고 보장하지는 않는다. 높은 커버리지의 테스트 스위트도 품질이 떨어질 수 있다. 

### 코드 커버리지 지표에 대해 
가장 많이 사용되는 커버리지 지표로 코드 커버리지가 있으며, 이는 테스트 커버리지라고도 알려져 있다. 이 지표는 하나 이상의 테스트로 실행된 코드 라인 수 와 제품 코드베이스의 전체 라인 수의 비율을 나타낸다. 

$$
코드\ 커버리지\ =\ \frac{실행\ 코드\ 라인\ 수}{전체\ 라인\ 수}
$$

코드 커버리지가 위와 같이 계산되기 때문에, 여러 줄로 이루어진 if 문이 있는 메서드를 한 줄의 expression으로 리팩터링했을 때 코드 커버리지가 올라가게 된다. 그런데 코드를 더 작게 만드는 것이 테스트 스위트의 가치나 기반 코드베이스의 유지보수성에 영향을 주는 것은 아니다. 

### 분기 커버리지 지표에 대해
분기 커버리지는 코드 커버리지의 단점을 극복하는데에 도움이 되어 코드 커버리지보다 더 정확한 결과를 제공한다. 분기 커버리지 지표는 원시 코드 라인 수를 사용하는 대신 if 문과 switch 문과 같은 제어 구조에 중점을 둔다. 

$$  
분기\ 커버리지\ =\ \frac{통과\ 분기}{전체\ 분기\ 수}  
$$

분기 커버리지 지표를 계산하려면 코드베이스에서 모든 가능한 분기를 합산하고 그 중 테스트에서 얼마나 많이 실행되는지를 확인해야 한다.

```java
public static <T> boolean isString(T input) {
    return T instanceof String;
}

void test() {
    var result = this.isString("Haha");
    Assertions.assertThat(result).isTrue();
}
```

`isStringLengthOver5(T input)` 메소드에 두 개의 분기가 있는데, 하나는 문자열 인수의 타입이 String 타입인 경우에 대한 것이고, 다른 하나는 그렇지 않은 경우이다. 테스트는 이런 분기 중 하나에 대해서만 적용되므로 분기 커버리지 지표는 1/2 = 50% 이다. 코드 커버리지와는 다르게 해당 분기를 구현하는 데 얼마나 많은 코드가 필요한지는 고려하지 않는다. 

### 커버리지 지표의 문제점
분키 커버리지로 코드 커버리지보다 더 나은 결과를 얻을 수 있지만, 테스트 스위트 품질을 결정하는 데에 어떤 커버리지 지표도 의존할 수 없는 이유는 다음과 같다.

1. 테스트 대상 시스템의 모든 가능한 결과를 검증한다고 보장할 수 없다. 
2. 외부 라이브러리의 코드 경로를 고려할 수 있는 커버리지 지표는 없다.

각각의 이유를 자세히 살펴보자.

#### 가능한 모든 결과를 검증한다고 보증할 수 없음
코드 경로를 탐색하는 게 아니라 실질적인 테스트를 하려면 단위 테스트에는 반드시 적절한 검증이 있어야 한다. 즉, 테스트 대상 시스템이 낸 결과가 정확히 예상하는 결과인지 확인해야 한다.

테스트 대상 코드를 모두 철저히 검증한다고 하자. 그럼 분기 커버리지 지표를 신뢰할 수 있는 구조라고 할 수 있을까? 그리고 테스트 스위트 품질을 결정하는데 사용할 수 있을까? 안타깝게도 아니다.

#### 외부 라이브러리 코드 경로를 고려할 수 없음

```java
public static int parse(String input) {
    return Integer.parseInt(input);
}

public void test() {
    var result = this.parse("123");
    Assertions.assertThat(result).isEqualTo(123);
}
```

이 테스트는 메소드 결과의 모든 구성 요소를 검증하지만, `Integer.parseInt()` 메서드가 수행하는 코드 경로를 고려하지 않는다. 즉, 외부 라이브러리에 숨겨져 있는 많은 분기들은 체크하지 못한다.

이렇듯 테스트에서 모든 예외 상황을 다루는지 확인할 방법이 없는 경우가 허다하다. 따라서 이러한 지표로는 단위 테스트의 품질을 판단할 수 없다는 것이다.

> **_Tip!_**
> 
> 시스템의 핵심 부분은 커버리지를 높게 두는 것이 좋다. 하지만 커버리지 퍼센티지를 높게 유지하는 걸 요구 사항으로 두는 것은 좋지 않다. 이 차이는 조금의 차이처럼 보이지만 매우 중요하다.

## 무엇이 성공적인 테스트 스위트를 만드는가?

1. 개발 주기에 통합되어 있다.
2. 코드베이스에서 가장 중요한 부분만을 대상으로 한다.
3. 최소한의 유지비로 최대의 가치를 끌어낸다.

### 개발 주기에 통합되어 있음
자동화된 테스트를 할 수 있는 방법은 끊임없이 실행하는 것 뿐이다. 모든 테스트는 개발 주기에 통합되어야 한다. 이상적으로는 코드가 변경될 때마다 아주 작은 것이라도 실행해야 한다.

### 코드베이스에서 가장 중요한 부분만을 대상으로 함
코드베이스의 모든 부분에 똑같이 테스트 작성 비용을 들일 필요는 없다. 테스트가 주는 가치는 테스트 구조 뿐만 아니라 검증하는 코드에도 있다. 

시스템의 가장 중요한 부분에 단위 테스트 노력을 들이고, 다른 부분은 간략하게 또는 간접적으로 검증하는 것이 좋다. 대부분의 애플리케이션에서 가장 중요한 부분은 비즈니스 로직이 있는 부분이다. 그리고 이 곳에서 시간 대비 최고의 수익을 낼 수 있다.

나머지 부분은 인프라 코드, 데이터베이스나 외부 서비스 및 종속성, 모든 것을 하나로 묶는 코드로 나뉜다. 이 중 복잡하고 중요한 알고리즘이 있는 인프라 코드가 있다면 테스트를 많이 하는 것이 좋다. 하지만 일반적으로 도메인 모델에 더 많은 노력을 기울이는 것이 옳다.

### 최소 유지비로 최대 가치를 끌어냄
단위 테스트에서 가장 어려운 부분은 최소 유지비로 최대 가치를 달성하는 것이다. 테스트를 빌드 시스템에 통합하는 것만으로는 충분하지 않으며 도메인 모델에 높은 테스트 커버리지를 유지하는 것으로도 충분하지 않다. 가치가 유지비를 상회하는 테스트에만 스위트를 유지하는 것이 중요하다. 이는 두 가지 작업으로 달성될 수 있다. 

- 가치 있는 테스트 식별하기
- 가치 있는 테스트 작성하기

이 두 작업은 비슷해보이지만 선천적으로 다른 것이다. 가치가 높은 테스트를 식별하려면 기준틀이 필요하다. 반면에 가치 있는 테스트를 작성하라면 코드 설계 기술도 알아야 한다.