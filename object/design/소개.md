# 기능 구현과 설계 원칙
## 프로그래밍을 바라보는 두 가지 관점, 설계의 가치
개발자로써 프로그래밍을 개발하는 행위를 두 가지 관점으로 나눠 바라볼 수 있다. 첫 번째 관점은 기능으로 시스템이 외부에 제공하는 행동을 의미한다. 개발자가 코드를 작성하는 가장 큰 이유는 "우리가 만든 프로그램을 사용할 사용자에게 기능을 통해 유용한 가치를 제공하기 위해서"이다. 따라서 개발자의 첫 번째 덕목은 유용한 기능을 버그 없이 구현하는 것이다. 프로그래밍의 두 번째 관점은 기능을 구현하기 위해 코드를 어떤 구조로 배치할지를 결정하는 것이다. 이 관점에서 개발자의 목적은 "나중에 코드를 읽을 개발자가 쉽게 이해하고 수정할 수 있는 코드를 작성" 하는 것이다. 

프로그래밍의 두 가지 관점은 개발자가 코드를 작성할 때 고려해야 하는 두 가지 종류의 클라이언트를 의미한다. 기능 관점에서 클라이언트는 기능을 사용할 사용자를 의미한다. 구조 관점에서 클라이언트는 코드를 유지 보수할 개발자를 의미한다. 개발자는 사용자에게 제공할 기능을 버그 없이 구현하는 동시에 다른 개발자가 유지 보수할 코드를 수정하기 쉽게 만드는 두 가지 목적을 동시에 달성해야 한다. 

여기에서 설계의 가치가 드러난다. 설계는 '어떤 기능을 구현하는데 적합한 코드의 구조를 결정하는 작업'이다. 다시 말하면 '유지 보수 가능하게 코드를 배치하는 방법'을 의미한다.

## 객체지향 패러다임의 '책임'과 '협력'
객체지향 패러다임을 사용할 경우에 기능은 메세지를 주고받는 객체들 사이의 **협력**을 통해 구현된다. 기능을 구현하는데 필요한 행동들은 객체들에게 **책임**으로써 분배되고, 그러한 객체들의 책임 간의 협력이 **더 큰 책임**을 구현하게 된다. 그리고 그렇게 **결정된 객체들의 협력**을 기반으로 **코드의 구조를 결정**한다. 객체지향 설계는 기능을 객체들 간의 책임과 협력으로 분해하고, 형성된 협력 관계를 바탕으로 변경과 확장이 쉬운 코드 구조를 설계한다.

가장 대표적인 객체지향 설계 방법인 **책임 주도 설계 방법**은 애플리케이션의 기능을 시스템의 책임을 해석하고 다시 이 시스템의 책임을 '협력을 설계하기 위한 문맥'으로 설정한다. 그리고나서 그 문맥 안에서 '시스템의 책임'을 '더 작은 객체의 책임' 으로 분할하고 할당하면서 '기능 구현에 필요한 객체 사이의 협력'을 설계한다. 그렇게 설계된 '객체들의 책임과 협력'을 '코드의 구조를 설계하기 위한 기반'으로 활용한다. 

클래스 기반의 언어에서 '런타임의 객체와 협력'은 '컴파일 타임의 클래스와 관계'로 구현할 수 있다.

## 구조를 설계하는 일을 대하는 자세는 어때야 할까
책임 주도 설계에서 가장 중요하면서도 어려운 것은 책임을 선택하고 그 책임을 적절한 객체에게 할당하는 방법이다. 그리고 책임을 할당하는 기본적인 가이드를 따르고 많은 경험을 쌓았다고 하더라도 구조를 설계하는 일은 여전히 어렵고 난해한 작업이다. 

설계가 어려운 첫 번째 이유는 동일한 구조를 구현할 수 있는 구조는 수도 없이 많기 때문이다. 두 번째 이유는 설계가 '요구사항 변경'과 관련이 있기 때문이다. 

개발자마다 설계가 달라지는, 다른 설계가 만들어지는 이유는 개발자마다 코드에서 어떤 변경될지에 대한 가정이 서로 다르기 때문이다. 각각의 설계는 그 코드를 설계한 개발자가 가정한 변경을 수용하는 데는 최적화되어 있을지 몰라도, 다른 개발자가 가정한 변경을 수용하기에는 부적합할 수 밖에 없다. 

개발자는 현재 어떤 방식으로 요구사항이 변경되고 있는지를 이해하고, 여러 가지 설계 중에서 **그러한 변경**에 적합한 설계를 선택해야 한다. 따라서 좋은 설계를 가장 좋은 방법은 **다양한 변경 방식을 이해**하고 각각의 변경에 따라 **적합한 방식**으로 객체 사이의 **책임을 할당하는 방법을 익히는 것**이다. 

## 책임 주도 설계에 관한 일반적인 오해, 그리고 리팩터링
"책임 주도 설계를 하면 처음부터 모든 변경을 수용할 수 있다." 는 오해를 많은 사람들이 하는 것 같다. 이는 사실과 다른데, 책임 주도 설계는 단지 "좀 더 안정적으로 변경할 수 있는 구조를 선택할 수 있도록" **책임을 중심에 두는 설계 방법**일 뿐이지 미래를 예측할 수 있는 방법은 아니기 때문이다.

어떤 부분에서 요구사항이 변경되고 어떤 방식으로 요구사항이 변경될지 예측하는 것은 바람직하지도 않고, 현실적으로 불가능하다. 따라서 우리가 선택할 수 있는 유일한 방법은 **현재 시점에서 가장 단순한 설계를 선택**하고 실제로 **변경이 일어났을 때 변경에 적합한 설계로 개선**하는 것이다.

그렇게 개선하는 것은 '겉으로 보이는 소프트웨어의 동작은 그대로 유지하고, 내부의 구조를 재구성하는 과정' 을 통해 이루어져야 한다. 그렇게 개선하는 것을 **리팩토링**이라고 부른다. 즉, 최대한 단순하면서 충분히 유연한 설계를 얻는 방법은 요구사항이 변경될 때마다 코드를 리팩토링하는 것이다.

리팩토링을 잘하기 위해선 코드에서 어디를 리팩토링할지, 그리고 리팩토링한 설계가 단순하면서도 충분히 유연한지를 판단할 기준이 필요하다. 그런 기준으로 설계 원칙을 사용할 수 있다.  