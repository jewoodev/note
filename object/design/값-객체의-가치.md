# 값 객체를 도입하면 얻게 되는 이점
## 별칭 문제 방지
`Sales`(매출) 클래스에 `int` 타입의 `totalAmount`가 멤버 변수로 있으면 바로 이 변수가 무엇인지 파악하는게 불가능하다. totalAmount는 총량으로 해석될 수도, 총 금액으로 해석될 수도 있기 때문이다.

다른 코드에 `quantity`(양)을 파라미터로 갖는 `addSale` 메서드에 `quantity * productPrice`를 `this.totalAmount`에 더하는 문맥이 확인되면, 그 문맥으로 `totalAmount`가 총 매출 금액인 것을 알 수 있을 것이다. 

만약 값 객체로 `Money` 클래스를 선언하고 `totalAmount`의 타입으로써 사용하면 코드를 확인하지 않고도 총 매출 금액인 것을 알 수 있게 된다.

## 중복 코드 제거
여러 참조 객체 사이에 값을 리턴하는 로직이 중복되어 있다면 그 로직을 값 객체로 이동시켜 중복을 제거할 수 있다. 위의 '별칭 문제 방지'에서 살펴본 예시 로직처럼 총 금액을 최신화하는 `addSale` 메서드가 다른 곳에서도 있을 수 있다. 총 금액의 개념을 값 객체로 대체하고, 중복된 로직을 값 객체로 옮겨 메서드를 호출하게 하면 중복 코드를 제거할 수 있다.

### DRY (Don't Repeat Yourself): 반복하지 마라
- 모든 지식 조각은 시스템 내에서 하나의 모호하지 않고 권위있는 표현을 가져야 한다. 

중복 개념이나 중복 코드가 존재해서는 안 된다는 원칙이다. 여기에서 **중복 코드**는 단순히 모양이 같은 코드가 아니라, 요구사항이 변경될 때 함께 수정되는 코드를 말한다.  
모양이 동일하더라도 함꼐 수정되지 않는다면 중복 코드로 간주하지 않는다.

## 값 객체는 합성(Composition) 관계로 연결
_값 객체는 자신이 포함되는 객체의 생명주기에 종속됨_

값 객체는 합성 관계로 표현한다. **합성 관계**는 '포함되는 객체의 생명주기'가 '포함하는 객체의 생명주기'에 종속된다는 것을 의미한다. 즉, 합성 관계를 갖는 객체들은 함께 생성되고 함께 삭제된다.

"표현한다."는 말은 객체간의 관계도를 그릴 때 속이 칠해진 마름모를 가진 연결선으로 합성 관계를 표현한다는 걸 의미한다.

값 객체는 단순한 값을 표현하기 때문에 독립적인 클래스로 표현하지 않고, 다른 객체의 속성으로 표현하기도 한다. 객체의 속성으로 표현하면 생명주기가 종속된다는 사실을 직관적으로 표현할 수 있는 이점이 있다.
