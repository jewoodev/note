코틀린은 함수형 프로그래밍에서 아이디어를 얻어왔고 가변을 사용했을 때 발생하는 문제점들을 줄이기 위해 불변을 사용한다.

default final, 상속과 관련해서는 이펙티브 자바 17의 내용이 이에 대한 견해를 보여준다.

- 오버라이딩이 가능한 메소드는 반드시 문서화를 해야한다. 상황에 따라 다르게 구현할 수도 있음을 포함한 자세한 내용을 알려줘야 한다. 
- 오버라이딩이 가능한 메소드는 하위 클래스를 만들어서 반드시 테스트해봐야 한다. 
- 생성자에서는 오버라이딩이 가능한 메소드를 호출하면 안된다. 초기화가 아직 안된 필드에 접근해서 동작을 수행하면 원치 않는 결과가 나올 수 있다. 
- Cloneable이나 Serializable을 구현하는 클래스는 생성자때와 같은 이유로 clone과 readObject에서 오버라이딩이 가능한 메소드를 호출하면 안된다. 
- 상속을 이용할 때는 위의 사항들을 잘 지켜서 설계와 문서화를 잘하거나 아니면 허용하지 말아라.

여기서 우리는 개발자들이 상속을 올바르게 사용하지 못하거나 실수를 해서 부작용을 일으킬 가능성이 있다는 것을 배울 수 있다. 이는 객체지향의 의도나 목적과는 다른 설계로 이어질 수 있으며,  코드의 복잡성과 가독성이 저하될 수 있다.

# final을 default로 함으로써
1. kotlin에서는 이러한 문제를 방지하기 위해 final을 default로 가지게 함으로써 상속과 오버라이딩을 허용하지 않는다. 이를 통해 코드의 예측 가능성을 높이고 안정성을 챙길 수 있다. (상속을 통한 동작의 변경이나 오버라이딩에 따른 부작용을 방지하여 코드의 의도를 명확하게 보여줌)
2. 컴파일 시점에 결정되는 정적 바인딩(static binding)을 사용하므로 런타임에 발생할 수 있는 동적 바인딩(dynamic binding)에 따른 오류 가능성을 줄인다. 이는 런타임에서의 예기치 않은 동작을 방지하여 안정성을 향상시킨다.
3. 더 효율적인 컴파일러 최적화를 가능하게 한다. 컴파일러는 final 클래스의 인스턴스 생성과 호출된 final 멤버 함수의 동작을 미리 알고 있기 때문에 불필요한 가상 호출 메커니즘을 건너뛰고 직접 호출할 수 있다. 이로 인해 성능 향상을 기대할 수 있다.

## 좀 더 깊게
kotlin의 final 클래스와 프로퍼티, 그리고 멤버 함수는 컴파일 시점에 정적 바인딩(static binding)을 사용하여 다형성을 처리한다. 즉, 런타임에 다형성을 체크하지 않는다.

final 클래스는 상속이 금지되어 있으므로 컴파일러는 해당 클래스의 인스턴스를 생성할 때 정적으로 결정된 생성자를 호출한다. 또한, final 멤버 함수는 오버라이딩이 금지되어 있으므로 컴파일러는 해당 멤버 함수의 호출시에 정적으로 바인딩하여 해당 클래스의 구현을 직접 호출한다.

이러한 정적 바인딩은 런타임(실행시점)에 동적으로 다양한 구현을 결정하는 동적 바인딩과 달리 컴파일 시점에 이미 결정되어 있기 때문에 일종의 최적화이다. 정적 바인딩은 가상 호출의 오버헤드를 피하고 직접 호출을 통해 실행 속도를 향상시킬 수 있다.

Kotlin은 필요시에 open 키워드를 사용하여 상속을 가능하게 한다. 이 경우에는 다형성을 위해 동적 바인딩이 발생한다. 동적 바인딩은 런타임(실행시점)에 실제 객체의 타입에 따라 호출될 메소드를 결정하므로 런타임에 다형성 체크가 이뤄진다.