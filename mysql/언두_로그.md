# 언두 로그
InnoDB 스토리지 엔진은 트랜잭션과 격리 수준을 보장하기 위해 **DML**(INSERT, UPDATE, DELETE)로 변경되기 이전 버전의 데이터를 별도로 백업한다. 여기서 백업되는 데이터를 언두 로그라고 한다. 

- **트랜잭션 보장**:  
    트랜잭션이 롤백되면 변경 전 데이터로 복구해야 하는데, 이때 언두 로그에 백업해둔 이전 버전의 데이터를 이용해 복구한다.
- **격리 수준 보장**:
    특정 커넥션에서 데이터를 변경하는 도중 다른 커넥션이 해당 데이터를 조회하면 트랜잭션 격리 수준에 맞게 변경 중인 레코드를 읽지 않고 언두 로그에 백업해둔 데이터를 읽어서 반환한다.

## 언두 로그로 인한 비용
그럼 DML이 일어날 때마다 언두 로그에 변경 내역들을 기록하게 될텐데, 1억 건의 레코드가 저장된 100GB 크기의 테이블을 DELETE로 삭제한다면 어떻게 되겠는가? 
언두 로그에 100GB 크기의 데이터가 쌓이게 되는 것이다. 

> MySQL 5.5 버전 이전에는 한 번 증가한 언두 로그 공간은 다시 줄어들지 않았다. 

앞서 이야기한 경우와 같은 대용량 데이터를 처리하는 트랜잭션이 아니라 트랜잭션이 오랜 시간 동안 실행되는 경우에도 언두 로그의 양은 급격히 증가할 수 있다.  
트랜잭션이 오래 지속되는 일은 트랜잭션이 중첩되어질 때 생겨나기 쉽다. 트랜잭션 안에 트랜잭션이 있는 구조에서는 트랜잭션이 완료되었다 해도 해당 트랜잭션이 생성한 언두 로그를 즉시 삭제할 수 없기 때문이다.  
모든 트랜잭션이 커밋되어야 삭제할 수 있게된다.

만약 사용자가 실수를 하게 되어 트랜잭션이 시작된 상태에서 하루 정도 방치되면, InnoDB 스토리지 엔진은 하루치 데이터 변경 사항들을 모두 저장하기 때문에 언두 로그 저장 공간은 계속 증가한다.  
이런 식으로 급격히 증가된 언두 로그로 인해 디스크 사용량이 증가하는 건 그다지 큰 문제가 아닐 수도 있지만, 그 동안에 변경이 발생한 레코드를 조회하는 쿼리가 실행되면 InnoDB 스토리지 엔진은 언두 로그의 이력을 필요한 만큼 스캔해야 필요한 레코드를 찾을 수 있기 때문에 쿼리의 성능이 전반적으로 떨어지게 된다.

그리고 백업을 할 때에도 언두 로그를 복사해야 하기에 문제가 된다. 

## 언두 테이블스페이스 관리
언두 로그가 저장되는 공간을 언두 테이블스페이스라고 한다. 이것은 MySQL 서버의 버전별로 많은 변화가 있었다. 

5.6 버전 이전에는 언두 로그가 모두 시스템 테이블스페이스(ibdata.ibd)에 저장됐다. 하지만 시스템 테이블스페이스의 언두 로그는 MySQL 서버가 초기화될 때 생성되기 때문에 확장의 한계가 있었다.  
그래서 5.6 이후로 innodb_undo_tablespaces 시스템 변수가 도입됐고, innodb_undo_tablespaces 값을 2보다 큰 값으로 설정하면 더이상 언두 로그를 시스템 테이블스페이스에 저장하지 않고 별도의 언두 로그 파일에 저장한다.  
8.0.14 버전부터는 innodb_undo_tablespaces는 deprecated되었으며 언두 로그를 항상 시스템 테이블스페이스 외부의 별도 로그 파일에 기록한다.

하나의 언두 테이블스페이스는 1개 이상 128개 이하의 롤백 세그먼트를 가지며, 롤백 세그먼트는 "언두 로그를 저장하는 논리적인 단위" 로 1개 이상의 언두 슬롯을 가진다. 

하나의 롤백 세그먼트는 InnoDB의 페이지 크기를 16바이트로 나눈 값의 갯수만큼 언두 슬롯을 가진다. 예를 들어, 페이지 크기가 16KB 이면 1,024개의 언두 슬롯을 가진다.  
그리고 하나의 트랜잭션이 필요로 하는 언두 슬롯의 갯수는 트랜잭션이 실행하는 INSERT, UPDATE, DELETE 문장의 특성에 따라 최대 4개까지 사용한다.  
일반적인 트랜잭션은 임시 테이블을 쓰지 않아 대략 2개 정도의 언두 슬롯을 필요로 한다고 가정하면 된다. 그래서 최대 동시 처리 가능한 트랜잭션의 개수는 다음의 수식으로 예측해볼 수 있다.

```
최대 동시 트랜잭션 수 = (InnoDB 페이지 크기) / 16 * (롤백 세그먼트 개수) * (언두 테이블스페이스 개수) / 2
```

가장 일반적인 설정인 16KB InnoDB에서 기본 설정(innodb_undo_tablespaces=2, innodb_rollback_seqments=128)을 사용한다면 대략 131027(=16 * 1024 / 16 * 128 * 2 / 2)개 정도의 트랜잭션이 동시에 처리 가능해진다. 

언두 로그 공간이 남는 것은 크게 문제되지 않지만 언두 슬롯이 부족하면 트랜잭션을 시작할 수 없는 심각한 문제가 발생하므로 기본값보다 낮게 설정하려는 시도는 하지 말자.  
만약 언두 로그 관련 시스템 변수를 변경해야 한다면 적절히 필요한 동시 트랜잭션 개수에 맞게 언두 테이블스페이스와 롤백 세그먼트 개수를 설정해야 한다.

MySQL 8.0 버전 이전에는 한 번 생성된 언두 로그가 변경이 허용되지 않고 정적으로 사용됐지만 이후에는 `CREATE UNDO TABLESAPCE`나 `DROP TABLESPACE` 같은 명령으로 새로운 언두 테이블 스페이스를 동적으로 추가하고 삭제하는게 가능해졌다.

언두 테이블스페이스 공간을 필요한 만큼만 남기고 불필요하거나 과도하게 할당된 공간을 운영체제에 반납하기 위해 자동과 수동으로 방법이 있다. 

- **자동 모드**:
    커밋된 트랜잭션에 해당하는 언두 로그 부분은 불필요하다. InnoDB 엔진의 퍼지 스레드는 주기적으로 언두로그 공간에서 이런 불필요한 부분을 삭제하는 작업을 수행하는데, 이 작업을 언두 퍼지라고 한다.
    `innodb_undo_log_truncate` 시스템 변수가 ON이면 퍼지 스레드가 주기적으로 깨어나서 언두 로그 파일에서 사용되지 않는 공간을 잘라내 운영체제에 반납한다. 이 주기를 `innodb_purge_rseg_truncate_frequency` 시스템 변수로 설정할 수 있다.
- **수동 모드**:
    `innodb_undo_log_truncate` 시스템 변수가 OFF일 때는 언두 테이블스페이스를 비활성화해서 더이상 사용되지 않도록 만들어야 퍼지 스레드가 비활성 상태의 언두 테이블스페이스를 찾아서 불필요한 공간을 잘라내고 운영체제에 반납한다. ON일 때도 비활성화된 언두 테이블스페이스는 퍼지 스레드가 반납하므로 예상보다 자동 모드에서 공간 반납이 부진한 경우에 사용하면 좋다. 반납이 완료되면 언두 테이블스페이스를 다시 활성화해서 사용하도록 만들어주자.
     수동 모드는 언두 테이블스페이스가 최소 3개 이상은 돼야 작동한다.
     ```sql
     ALTER UNDO TABLESPACE tablespace_name SET INACTIVE; -- 언두 테이블스페이스 비활성화
     ALTER UNDO TABLESPACE tablespace_name SET ACTIVE; -- 공간이 반납되면 다시 활성화
     ```

  
