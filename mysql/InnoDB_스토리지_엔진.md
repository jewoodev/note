# InnoDB 스토리지 엔진
InnoDB는 MySQL에서 사용할 수 있는 스토리지 엔진 중에 거의 유일하게 레코드 기반의 잠금을 제공하며, 그래서 높은 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.

이 스토리지 엔진이 어떤 기능들을 가진 자료구조와 알고리즘으로 구성되어 있는지 알아보자.

## 1. 프라이머리 키에 의한 클러스터링
InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장된다. 이말은 프라이머리 키가 곧 데이터 저장 구조를 결정한다는 말과 같다.  
즉, 프라이머리 키 값의 순서대로 디스크에 저장되고, 모든 세컨더리 인덱스는 레코드 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용한다.

### 1.1 어떤 구조로 저장될까?
InnoDB는 B-Tree 구조와 비슷한 클러스터링 테이블을 사용해서 클러스터링 인덱스를 관리한다.  
아래의 그림은 클러스터링 테이블의 특성을 이해하기 쉽도록 구조를 그림으로 표현한 것이다.

<img src="https://github.com/jewoodev/blog_img/blob/main/mysql/InnoDB_%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80_%EC%97%94%EC%A7%84/%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A7%81_%ED%85%8C%EC%9D%B4%EB%B8%94_%EA%B5%AC%EC%A1%B0.png?raw=true">

그림을 보면 클러스터링 인덱스 구조도 일반 B-Tree와 비슷하다. 하지만 세컨더리 인덱스를 위한 B-Tree의 리프 노드와는 달리 클러스터링 인덱스의 리프 노드는 레코드의 모든 컬럼이 같이 저장되어 있다.  
이처럼 클러스터링 테이블은 그 자체로 하나의 거대한 인덱스 구조로 관리되는 것이다.

## 2. 외래 키 지원
MyISAM이나 MEMORY에서는 사용할 수 없지만 InnoDB 스토리지 엔진은 지원한다.  
InnoDB에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 컬럼에 인덱스 생성이 필요하고, 변경 시에는 반드시 부모와 자식 테이블 모두에 데이터 유무를 확인하는 작업이 필요하다.  
이로 인해 잠금이 여러 테이블로 전파되어서, 데드락의 원인이 되기 좋다는 걸 인지하고 사용해야 한다. 

## 3. MVCC
> Multi Version Concurrency Control 의 약자이다.

일반적으로 레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능으로, 잠금을 사용하지 않는 일관된 읽기를 하는데에 가장 큰 목적을 두고 있다.  
InnoDB는 언두 로그를 이용해서 이 기능을 구현한다. 어떻게 구현되어 있는지 한 번 알아보자. 

만약 `member` 라는 테이블을 생성하고 레코드 하나를 INSERT 했다면, 다음의 그림처럼 바뀔 것이다.

<img src="https://github.com/jewoodev/blog_img/blob/main/mysql/InnoDB_%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80_%EC%97%94%EC%A7%84/mvcc1.png?raw=true">

그리고 `member` 테이블에 UPDATE 쿼리를 하면 아래처럼 바뀐다. 

```sql
UPDATE member SET area="경기" where id=1;
```

<img src="https://github.com/jewoodev/blog_img/blob/main/mysql/InnoDB_%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80_%EC%97%94%EC%A7%84/mvcc2.png?raw=true">

그림처럼 커밋 여부와 상관없이 버퍼 풀의 레코드는 바로 업데이트 되고 디스크의 데이터 파일의 상태는 시점에 따라 달라질 수 있다. 

아직 UPDATE 쿼리를 실행한 세션에서 커밋이나 롤백을 하지 않은 상태에서 다른 세션이 해당 레코드를 조회하면 어디에 있는 걸 조회할까?  
이 질문의 답은 "MySQL 서버의 시스템 변수(transaction_isolation)에 설정된 격리 수준에 따라 달라진다." 이다.

격리 수준이 READ_UNCOMMITTED 이면 버퍼 풀에서 가져오고, READ_COMMITTED 나 그 이상의 격리 수준에서는 언두 로그에서 읽는다. 

이렇듯 하나의 레코드에 여러 버전이 유지되며, 필요에 따라 다른 버전을 읽을 수 있는 기능이 MVCC이다.

## 4. 잠금 없는 일관된 읽기
`3. MVCC`에서 살펴 봤듯 InnoDB 스토리지 엔진은 잠금을 걸지 않고 읽기 작업을 수행한다.  
그래서 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고 읽기 작업을 수행하는게 가능하다. 격리 수준이 SERIALIZABLE 이 아닌 수준에서 순수한 SELECT 작업은 다른 트랜잭션이 지지고 볶든 항상 잠금을 대기하지 않고 바로 실행되는 것이다. 그리고 그러한 읽기 작업에서는 **언두 로그를 사용**한다.

트랜잭션이 길어지면 MySQL 서버가 느려지거나 문제가 발생하는 이유가 바로 일관된 읽기를 위해 언두 로그를 삭제하지 못하고 계속 유지하기 때문이다. 따라서 트랜잭션이 시작됐다면 가능한 빨리 완료하는 것이 좋다.

## 5. 자동 데드락 감지
InnoDB 스토리지 엔진은 잠금이 교착 상태에 빠지지 않았는지 체크하기 위해 잠금 대기 목록을 그래프(Wait-for List) 형태로 관리한다.  
InnoDB 스토리지 엔진은 데드락 감지 스레드를 가지고 있어 주기적으로 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션들 중 하나를 강제 종료한다.  
이때 어느 트랜잭션을 먼저 강제 종료할 것인지 판단하는 기준은 트랜잭션의 언두 로그 양이며, 더 적게 가진 트랜잭션을 보통 롤백의 대상으로 선정한다. 
언두 로그가 적다는 건 롤백을 하기 위해 처리해야 할 언두 작업이 적어서 강제 롤백으로 인한 서버의 부하가 적기 때문이다.

기본적으로 InnoDB 스토리지 엔진은 MySQL 엔진에서 관리되는 테이블 잠금에 대한 정보는 볼 수 없어 데드락 감지가 불확실할 수 있는데, `inoodb_table_locks` 시스템 변수를 활성화하면 테이블 잠금까지 볼 수 있게 된다. 특별한 이유가 없다면 활성화하는 것이 권장된다.

데드락 감지 스레드는 동시 처리 스레드가 매우 많아지거나 각 트랜잭션의 잠금 갯수가 많아지면 느려지게 되는데, 이는 서비스에 전반적인 악영향을 준다.  
왜냐하면, 데드락 감지 스레드가 잠금 목록을 검사할 땐 검사가 올바르게 될 수 있도록 목록에 잠금을 걸고, 그 잠금으로 인해 서비스 쿼리를 처리하는 스레드가 대기하게 되기 때문이다.

이런 문제점을 해결하기 위해 `innodb_deadlock_detect` 시스템 변수로 데드락 감지 스레드의 작동 여부를 제어할 수 있다. 그리고 `innodb_lock_wait_timeout` 시스템 변수로 락을 획득하지 못하면 요청이 실패하는 일정 시간을 설정할 수 있다. 만약 데드락 감지 스레드를 비활성화하고 `innodb_lock_wait_timeout` 을 설정한다면 기본값인 50초보다 훨씬 낮은 시간으로 변경해서 사용하는 것이 권장된다.

