# B-Tree 인덱스를 통한 데이터 읽기

## 1. 인덱스 레인지 스캔
이 방법은 인덱스 접근 방법들 중 가장 대표적인 것으로, 2번 3번의 방법보다는 빠른 방법이다.  

원래 인덱스를 통해 레코드를 한 건만 읽는 경우와 한 건 이상을 읽는 경우를 각각 다른 이름으로 구분하지만, 이번 글에선 "인덱스 레인지 스캔"이라고 표현했다. 더 상세한 내용은 실행 계획을 살펴보며 언급하겠다. 여기서는 B-Tree 인덱스에서 필요한 영역을 스캔하는데 어떤 작업이 필요한지 이해하는데에 집중하자. 다음의 쿼리를 예제로 살펴보자.

```sql
SELECT * FROM employee WHERE first_name BETWEEN 'Jewoo' AND 'Seokwon';
```
<img src="인덱스를_이용한_레인지_스캔">
인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다. 검색하려는 값의 수나 검색 결과 레코드 건수와 관계없이 레인지 스캔이라고 표현한다.   
위의 그림의 화살표에서 알 수 있듯 루트 노드에서부터 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾아 들어가야만 비로소 읽으려는 레코드 위치를 찾을 수 있다. 그 위치를 찾으면 그때부터는 리프 노드의 레코드만 순서대로 읽으면 된다.   

이처럼 차례대로 쭉 읽는 것을 스캔이라고 표현한다. 만약 스캔하다가 리프 노드의 끝까지 읽으면 리프 노드 간의 링크를 이용해 다음 리프 노드를 찾아 다시 스캔한다.   
그리고 최종적으로 스캔을 멈춰야 할 위치에 다다르면 지금까지 읽은 레코드를 사용자에게 반환하고 쿼리를 끝낸다. 위의 그림에서 두꺼운 선은 스캔해야 할 위치 검색을 위한 비교 작업을 의미하며, 두꺼운 화살표가 지나가는 리프 노드의 레코드 구간은 실제 스캔하는 범위를 표현한다.

위의 그림은 실제 인덱스만을 읽는 경우를 나타내고 있다. 하지만 B-Tree 인덱스를 리프 노드를 스캔하면서 실제 데이터 파일의 레코드를 읽어 와야 하는 경우도 많은데, 이 과정을 좀 더 자세히 살펴보자.

<img src="인덱스_레인지_스캔을_통한_데이터_레코드_읽기">
B-Tree 인덱스에서 스캔 시작 위치를 찾아서, 그 지점부터 필요한 방향(오름차순 또는 내림차순)으로 인덱스를 읽어나가는 것을 위의 사진에서 확인할 수 있다.  

여기서 중요한 건 인덱스를 읽는 방식은 인덱스 레인지 스캔이 아니더라도 동일하게, 사진처럼 해당 인덱스를 구성하는 컬럼의 정순 또는 역순으로 정렬된 상태로 레코드를 가져온다.  
인덱스 자체의 정렬 특성때문에 별도의 정렬이 수행되는 것이 아니라 자동으로 그렇게 된다.

그리고 중요한 사실이 하나 더 있다. 인덱스의 리프 노드에서 검색 조건에 일치하는 건들을 데이터 페일에서 레코드를 읽어오는 과정이 필요한데, 레코드 한 건마다 랜덤 I/O가 일어나는 것이다. 이 랜덤 I/O 때문에 인덱스를 이용한 읽기는 비싼 작업으로 분류된다. 

인덱스 레인지 스캔은 정리하면 크게 3단계를 거친다는 걸 알 수 있다.
1. 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾는다. 이 과정을 인덱스 탐색이라 한다.
2. 1번에서 탐색된 위치부터 인덱스를 연속적으로 읽는다. 이 과정을 인덱스 스캔이라 한다.
3. 2번에서 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽어 온다.

쿼리가 필요로 하는 데이터가 무엇인지에 따라서 3번 과정은 필요하지 않을 수도 있는데, 필요하지 않은 경우에 수행되는 인덱스 레인지 스캔 작업을 커버링 인덱스라고 한다.  
커버링 인덱스로 처리되면 디스크에서 랜덤 I/O를 해야하는 횟수가 상당히 줄어들어 성능이 좋아진다. 

## 2. 인덱스 풀 스캔
인덱스의 부분만을 읽는 인덱스 레인지 스캔과 달리 인덱스의 처음부터 끝까지 전부 읽는 방식이다. 대표적으로 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫 컬럼이 아닌 경우 사용된다.

일반적으로 인덱스 크기가 테이블 크기보다 작기 때문에 직접 테이블을 풀 스캔하는 것보다 빠르다. 

쿼리의 조건문에서 사용하는 컬럼들이 인덱스 안의 컬럼들로만 이루어진 경우 주로 사용된다. 하지만 인덱스에 포함되지 않는 컬럼의 데이터까지 읽어야 한다면 절대 이 방식으로 처리되지 않는다.

인덱스 풀 스캔은 인덱스 리프 노드의 맨 앞 또는 맨 뒤로 이동한 후, 각 리프 노드를 연결하는 링크드 리스트를 따라서 처음부터 끝까지 스캔하는 방식으로 수행된다. 이 방식은 인덱스 레인지 스캔보단 빠르지 않지만 테이블 풀 스캔보다는 효율적이다.

## 3. 루스 인덱스 스캔
이 스캔 방식은 말 그대로 느슨하게 또는 듬성듬성하게 인덱스를 읽는 방식이다. 인덱스 레인지 스캔과 비슷하게 동작하지만 중간에 필요하지 않은 인덱스 키 값은 무시하고 다음으로 넘어가는 형태로 처리한다.  
일반적으로 `GROUP BY` 나 `MAX()`, `MIN()` 집합 함수에 최적화를 하는 경우에 사용된다.

```sql
CREATE TABLE dept_emp (
    dept_no VARCHAR(10),
    emp_no VARCHAR(10),
    name VARCHAR(5),
    INDEX ix_dept_emp(dept_no, emp_no DESC)
)
```
`dept_emp` 테이블의 DDL이 위와 같을 때, 

```sql
SELECT dept_no, MAX(emp_no)
FROM dept_emp
WHERE dept_no BETWEEN 'business' AND 'marketing'
GROUP BY dept_no;
```
이런 쿼리를 날리면 `ix_dept_emp` 인덱스를 사용할 수 있는데, 이 인덱스는 쿼리에서 필요로 하는 순서로 정렬까지 되어있어 dept_no 그룹별로 첫 번째 레코드의 emp_no 값만 읽으면 된다.  
즉, 옵티마이저는 WHERE 절의 조건에 맞는 모든 레코드를 조회하여 집합 함수 연산을 하지 않아도 된다고 알 수 있는 것이다. 이렇게 읽는 방식이 루스 인덱스 스캔이다.

## 4. 인덱스 스킵 스캔
다중 인덱스를 만들면 첫번째부터 다음 순서대로 정렬이 적용된 인덱스가 생성되기 때문에 첫번째 인덱스가 조건에 사용되지 않으면 인덱스를 사용할 수 없다.  
그래서 3번에서 살펴본 dept_emp 테이블에서 emp_no 컬럼으로만 쿼리를 작성하면 인덱스를 사용할 수 없다. 만약 이러한 쿼리에도 최적화가 필요해 인덱스를 사용해야 한다면 추가적으로 인덱스를 생성해야 한다.

그런데! MySQL 8.0 버전부터는 옵티마이저가 dept_no 컬럼 값을 건너뛰고 emp_no 컬럼 만으로 인덱스 검색을 할 수 있게 하는 인덱스 스킵 스캔 최적화 기능을 갖게 되었다. 언뜻 루스 인덱스 스캔과 비슷하지 않나, 싶지만 루스 인덱스 스캔은 GROUP BY 작업을 수행하는데 인덱스를 사용하는 경우에만 적용될 수 있었다. 인덱스 스킵 스캔은 WHERE 절의 검색을 위해 사용 가능하므로 훨씬 적용되는 범위가 넓다.

이 방식이 사용되면 쿼리의 실행 계획에서 type 컬럼의 값이 "range", Extra 컬럼의 값이 "Using index for skip scan" 이라 표시된다.

추후 더 개선될테지만 아직 아래와 같은 조건이 만족되어야 사용될 수 있다.
1. WHERE 절에 쓰이지 않은 인덱스의 선행 컬럼의 유니크 한 값의 개수가 적어야 한다. 
2. 쿼리가 인덱스에 존재하는 컬럼만으로 처리 가능해야 한다(커버링 인덱스).

