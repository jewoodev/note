# B-Tree 인덱스 사용에 영향을 미치는 요소

## 1. 인덱스 키 값의 크기
MySQL의 B-Tree 인덱스는 루트, 브랜치, 리프 노드는 모두 페이지 단위로 저장된다. 그리고 MySQL가 디스크에서 데이터를 읽어오는 최소 단위는 페이지이다.

즉, MySQL 서버가 I/O 작업을 1회 수행했을 때 읽을 수 있는 데이터 크기는 페이지의 크기가 되고, 이 페이지에 인덱스가 몇 개 담길 수 있는지에 따라서 조회 작업을 수행할 때 필요한 I/O 작업의 횟수가 정해진다.  
그리고 페이지에 인덱스가 몇 개 담길 수 있는지는 인덱스 키 값의 크기가 얼마인지에 따라 달라진다. 페이지 크기가 16KB 이고 인덱스 키가 32 비트라면, `16*1024/32 = 512`개를 저장할 수 있다.

인덱스 키가 32비트인 경우와, 64 비트인 경우에 조회 성능은 어떻게 달라질까? SELECT 쿼리가 레코드 500개를 읽어야 한다면 전자의 경우 인덱스 페이지 하나를 읽어 오면 되지만, 후자의 경우 두번 이상을 읽어야 한다. 이는 I/O 작업 횟수가 늘어나 성능이 저하되는 걸 야기한다.

그리고 인덱스 키 값의 길이가 길어지면 인덱스를 캐시해두는 InnoDB 버퍼 풀이나 MyISAM 키 캐시 영역에서도 캐시해둘 수 있는 레코드 수가 줄어들게 된다. 그렇게 되면 메모리의 효율도 떨어지게 된다.

## 2. 선택도(기수성)
인덱스에서 선택도와 기수성은 거의 같은 뜻으로 모든 인덱스의 키 값 가운데 유니크한 값의 수를 의미한다.  
전체 인덱스 키 값이 100개일 때 이 중 유니크한 값이 10개이면 기수성이 10이다. 인덱스에 중복된 값이 많아질수록 기수성이 낮아지며 선택도가 떨어진다. 선택도가 높을수록 검색 대상이 줄어들기 때문에 그만큼 빨리 처리할 수 있게 된다.
> 기수성이 낮더라도 정렬이나 그루핑과 같은 작업을 위해 인덱스를 만드는 게 훨씬 나은 경우도 있다. 인덱스가 항상 검색 작업에만 쓰이는 게 아니기 때문에 여러 가지 용도에 맞게 적절히 인덱스를 설계할 수 있어야 한다.

기수성이 높으면 왜 검색 작업이 왜 더 빨라지는지 다음의 예시로 이해해보자. 
```sql
CREATE TABLE employee (
    department VARCHAR(10),
    name VARCHAR(5),
    INDEX ix_department(department)
)
```
employee 테이블은 1만 건의 레코드를 가지고 있는데, department 컬럼에만 인덱스가 걸려있다. 이때, (department, name) 으로 묶어 보았을 때의 모든 레코드는 중복되지 않는다고 가정하자.

이제 employee 테이블에 아래의 쿼리를 한번 실행해보자. 
```sql
SELECT *
FROM employee
WHERE department='development' AND name='신제우';
```
이 쿼리가 얼마나 효율적으로 수행되는지는 ix_department 인덱스의 유니크한 값의 갯수가 몇 개인지에 따라 달라진다.

department 컬럼의 유니크한 값이 10개라면,  
ix_department 인덱스의 키 값 하나로 검색했을 때 전체 레코드 수를 10으로 나눈 1000건이 검색될거라 예상할 수 있게 된다. 그런데 그 1000건 중 `name='신제우'`인 레코드는 1건이므로 나머지 999건은 불필요하게 읽은 것이다.

department 컬럼의 유니크한 값이 1000개라면,
ix_department 인덱스의 키 값 하나로 검색했을 때 10건이 검색될거라 예상된다. 그리고 그 10건 중 `name='신제우'`인 레코드는 1건이므로 9건만 불필요하게 읽은 것이다.

후자에 비해 전자는 990 건을 불필요하게 읽게 되는 효율의 차이를 갖는다. 이런 원리로 기수성은 효율성에 큰 영향을 미친다.

## 3. 읽어야 하는 레코드의 수
쿼리의 결과로 읽어야 하는 레코드의 수가 전체 테이블 레코드의 수의 몇 %가 되느냐는 쿼리를 효율적으로 수행하기 위한 중요한 지표이다. 인덱스를 이용한 읽기 작업과 풀 테이블 스캔이 수행하게 되는 I/O 작업의 효울성이 다르기 때문이다.

인덱스를 이용한 읽기는 인덱스에서 레코드의 위치를 찾고 해당 위치에서 데이터를 가져오는 작업을 수행한다. 이 과정에서 랜덤 I/O가 발생하여, 많은 레코드를 읽을 경우 오버헤드가 커진다.

반면, 풀 테이블 스캔은 순차 I/O로 데이터를 읽기 때문에 디스크 I/O 비용이 줄어들어 성능이 더 좋을 수 있다. 그리고 연속된 블록을 한 번에 읽을 수 있어 데이터 캐싱 효율도 증가한다.

일반적으로 DBMS의 옵티마이저는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 1건을 읽는 것보다 4~5배 정도 더 비싸다고 예측한다. 이는 그 동안 경험적으로 20~25%까지의 레코드 수를 읽을 때는 인덱스를 통한 읽기가 효율적이었지만, 넘어가면 풀 테이블 스캔을 하는 것이 더 효율적이었기 때문이다.