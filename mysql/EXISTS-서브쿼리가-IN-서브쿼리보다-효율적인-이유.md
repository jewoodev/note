- IN 서브쿼리와 비교했을 때 EXISTS 서브쿼리가 메모리 절감 효과를 갖는 이유는 뭘까?
  - IN 서브쿼리
    - 서브쿼리 결과를 모두 메모리에 로드
    - 임시 테이블 생성
    - 10만 건 이상이면 메모리 압박
  - EXISTS 서브쿼리
    - 행별로 즉시 평가(Short-circuit)
    - 첫 번째 매칭만 찾으면 중단
    - 메모리 효율적
- MySQL 5.6 버전에서는 IN 서브쿼리 성능에 치명적인 문제가 있었다. 그런 문제가 있었던 건 다음과 같은 처리절차 때문이다.
  1. 서브쿼리를 먼저 실행 -> 결과를 임시 테이블에 저장
  2. dental_orders의 각 행마다 임시 테이블 전체를 스캔
    - O(N * M) 복잡도 (N: orders 행 수, M: 서브쿼리 결과 수)
  - 이러한 이유 때문인지 IN 서브쿼리를 포함한 쿼리의 처리 속도는 테스트 결과, 다음과 같은 양상을 보였다.
    - IN 서브쿼리: 15초 ~ 30초 (또는 타임아웃)
    - EXISTS: 1초 ~ 3초 
    - JOIN: 0.5초 ~ 2초
  - 메모리 사용량도 문제가 된다.(부차적 문제, IN 서브쿼리)
    - 서브쿼리 결과 전체를 메모리의 임시 테이블에 저장 
    - 500개 lab_id → 약 4KB (작음)
    - 하지만 복잡한 서브쿼리면 수십MB~수백MB 가능
  - 따라서 IN 서브쿼리를 EXISTS 서브쿼리로 바꾸면 이러한 효과를 볼 수 있다.
    1. CPU 사용량 감소 (불필요한 비교 연산 제거)
    2. 임시 테이블 크기 감소 
    3. 버퍼 풀 효율 증가 
    - → 결과적으로 전체 메모리 사용량 감소, 체감상 가장 큰 변화는 응답 속도!
  - **정리**
    - | 항목        | IN 서브쿼리 | EXISTS | 개선 효과        |
      |-----------|---------|--------|--------------|
      | **응답 속도** | 15-30초  | 1-3초   | **90% 개선** ⭐ |
      | 메모리 사용    | 높음      | 낮음     | 50% 절감       |
      | CPU 사용률   | 매우 높음   | 낮음     | 70% 감소       |