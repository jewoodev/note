# 동시성

하나의 코어에서 여러 개의 task(or thread)가 한 번에 여러 task가 동시에 실행되는 것처럼 실행되는 것

# 병렬성

다수의 thread가 동시에 실행되는 것. cpu 클락 수를 무한정 늘릴 수 없기 때문에 하드웨어의 utilization을 높여서 더 높은 성능의 연산을 수행할 수 있게 하기 위해 고안된 방법.

# JVM에서의 lock 동작 방식

동시에 다수의 thread가 전역 변수나 공유 자원에 접근할 때 서로 다른 데이터를 보고 있을 수 있어 보통 모니터 락을 사용

synchronized 로 모니터 락을 걸면  

```java
monitorenter
monitorexit
```

와 같은 바이트 코드가 컴파일 결과로 들어간다.

자바의 모든 객체는 각각 하나의 모니터 락을 가진다. 모니터 락에는 special room, wait set, entry set이라는 자료구조가 있다. 이 안에 special room에는 락을 획득한 쓰레드, 대기하려는 쓰레드는 entry set에 우선 들어가고, wait set에는 락을 획득하기 위해 대기하는(wait 함수를 사용한) 곳이다. wait set에서 들어간 쓰레드는 누가 깨워(notify)주지 않으면 wait set으로 나올 수 없다. 깨워주면 entry set으로 가게 된다. 

하나의 코어에서도 동시성 문제가 발생할 수 있다. 타임 별로 컨텍스트 스위칭없이 타임슬립(맞나?) 하면서 각각 로컬에만 전역 변수의 값을 변경한 걸 갖고 있다가 어떤 순서로 메모리에 write하느냐에 따라 결과값이 달라질 수 있기 때문이다.

entry set, wait set에 대기할 수 있는 쓰레드 수는 리밋이 없다. 자바의 쓰레드는 이전엔 네이티브 쓰레드를 사용했지만, 21부터 버츄얼 쓰레드를 사용하면서 ... 커널에서 설정된, 혹은 사용 가능한 갯수의 수만큼 만들 수 있는 것이다. 

entry set에서 스레드가 락을 획득하는 순서는 무작위이다. 

# Spin lock vs mutex(semaphore)

spin lock은 쓰레드 컨텍스트 스위칭이 일어나지 않는 장점이 있다. 예를 들면, 쓰레드 풀이나 커넥션 풀을 직접 구현해야 한다면 

# lock free 알고리즘

이전까지 살펴봤던 방식은 모두 `확인`하는 메커니즘이다. 

atomicLong 같은 걸 보면 compareAndSet(낙관적 락)을 하는데 보면 java 언어가 아니고 어셈블리어로 하드웨어에 직접적으로 cas 연산을 함.

하나의 코어에서 타임을 쪼개 다수의 쓰레드로 작업을 수행할 때 "메모리에 write 하기 전에 로컬에만 갖고 있다~" 라는 부분에서 로컬에만 갖고 있다는 건 cpu 레지스터에 갖고 있는 것이거나 혹은 l1, l2 캐시에 있는걸 가져오는 것이다.


# 기타 lock

skip locked?

# 공부팁

기능을 공부할게 아니라 메커니즘을 공부하면 어떤 기능을 사용하지 못하는 상황에서도 빠르게 사용할 수 있게 된다. 기능을 공부하게 되면 그 기능에 종속적이게 된다.

# 도서

자바 병렬프로그래밍 - 브라이언 게츠

JVM 밑바닥까지 파헤치기 