# IPv4 데이터그램 포맷
인터넷 네트워크 계층 패킷을 **데이터그램**(datagram)이라고 부르는 것을 떠올리자. IPv4 데이터그램 문법과 용어의 개요에서 이야기를 시작하겠다. IPv4 데이터그램의 주요 필드는 다음과 같다.

- **버전 번호**: 4비트로 데이터그램의 IP 프로토콜 버전을 명시한다. 라우터는 버전 번호를 확인해 데이터그램의 나머지 부분을 어떻게 해석할지 결정한다. 다른 버전의 IP는 다른 데이터그램 포맷을 사용한다.
- **헤더 길이**: IPv4 데이터그램은 헤더에 가변 길이의 옵션을 포함하므로 이 네 비트로 IP 데이터그램에서 실제 페이로드(예를 들어, 데이터그램에 캡슐화된 트랜스포트 계층 세그먼트)가 시작하는 곳을 결정한다. 대부분의 IPv4 데이터그램은 옵션을 포함하지 않으므로 대체로 IPv4 데이터그램 헤더는 20바이트다.
- **서비스 타입**: IPv4 헤더에 포함된 서비스 타입(type of service, TOS) 비트는 각기 다른 유형의 IP 데이터그램을 구별한다. 예를 들어 실시간 데이터그램(IP 전화 통신 애플리케이션)과 비실시간 트래픽(예:FTP)을 구분하는 데 유용하다. 제공될 특정 서비스 레벨은 해당 라우터의 네트워크 관리자가 결정하고 구성할 정책 문제다. 
- **식별자, 플래그, 단편화 오프셋**: 이 세 필드는 이른바 IP 단편화와 관련이 있다. 큰 IP 데이터그램이 여러개의 작은 데이터그램으로 분할된 다음, 목적지로 독립적으로 전달되며, 여기서 페이로드 데이터가 최종 호스트의 트랜스포트 계층으로 전달되기 전에 다시 모이게 된다. 흥미롭게도, 새로운 IP 버전인 IPv6는 단편화를 허용하지 않는다.
- **TTL**: 이 필드는 네트워크에서 데이터그램이 무한히 순환하지 않도록 한다(라우팅 루프). 이 필드값은 라우터가 데이터그램을 처리할 때마다 감소한다. TTL 필드가 0이 되면 라우터가 데이터그램을 폐기한다.
- **프로토콜**: 이 필드는 일반적으로 IP 데이터그램이 최종 목적지에 도착했을 때만 사용된다. 이 필드값은 IP 데이터그램에서 데이터 부분이 전달될 목적지의 트랜스포트 계층의 특정 프로토콜을 명시한다. 예를 들어 값 6은 데이터 부분을 TCP로, 값 17은 UDP로 데이터를 전달하라는 뜻이다. 가능한 모든 값 목록은 [IANA Protocol Numbers 2016]에 있다. IP 데이터그램에서 프로토콜 번호의 역할은 트랜스포트 계층 세그먼트에서 포트 번호 필드의 역할과 유사하다. 포트 번호가 트랜스포트 계층과 애플리케이션 계층을 함께 묶는 접착제 역할을 하는 것처럼 프로토콜 번호는 네트워크 계층과 트랜스포트 계층을 묶는 역할을 한다.
- **헤더 체크섬**: 헤더 체크섬은 라우터가 수신한 IP 데이터그램의 비트 오류를 탐지하는데 도움을 준다. 헤더 체크섬은 IP 헤더(보통 20바이트)를 각 2바이트(16비트) 단위로 나누고, 그 각각의 2바이트를 16진수로 처리하여 합산하여 합이 16비트를 초과하면 상위 비트를 하위 16비트에 더하고, 그 결과의 1의 보수를 구한 것이다. 인터넷 체크섬으로 알려진 이 합의 1의 보수는 체크섬 필드에 저장된다. 라우터는 수신한 각 IP 데이터그램마다 헤더 체크섬을 계산하고 이 값과 데이터그램 헤더의 체크섬이 다르면 오류 상태임을 감지한다. 라우터가 보통 오류가 검출된 데이터그램을 폐기한다. TTL 필드와 옵션 필드의 값은 변경되므로 체크섬은 각 라우터에서 재계산되고 저장되어야 한다. 인터넷 체크섬 계산을 위한 알고리즘은 [RFC 1071]을 참고하자. TCP/IP가 트랜스포트 계층과 네트워크 계층에서 오류 검사를 수행하는 이유는 다음과 같다. 첫째, IP 헤더만 IP 계층에서 체크섬을 수행하지만 TCP/UDP 체크섬은 전체 TCP/UDP 세그먼트를 계산한다. 둘째, TCP/UDP와 IP는 동일한 프로토콜 스택에 속할 필요가 없다. 원리상 TCP는 IP가 아닌 다른 네트워크 프토토콜(예: ATM)[Black 1995] 위에서 운영될 수 있고, IP는 TCP/UDP로 전달되지 않는 데이터를 전달할 수 있다.
- **출발지와 목적지 IP 주소**: 출발지가 데이터그램을 생성할 때, 자신의 IP 주소를 출발지 IP 주소 필드에 삽입하고 목적지 IP 주소를 목적지 IP 주소 필드에 저장한다. 종종 출발지 호스트는 DNS 검색을 통해 목적지 주소를 결정한다. 
- **옵션**: 옵션 필드는 IP 헤더를 확장한다. 모든 데이터그램 헤더 옵션 필드에 정보를 포함하지 않음으로써 오버헤드를 해결하기 위해 헤더 옵션은 거의 사용되지 않는다. 옵션은 데이터그램 헤더가 가변 길이로 데이터 필드 시작점을 초기에 결정할 수 없게 만들기 때문이다. 또한 일부 데이터그램은 옵션 처리 유무에 따라서 라우터에서 IP 데이터그램을 처리하는 데 필요한 시간이 크게 달라진다. 이런 가변 길이의 옵션은 고성능 라우터 및 호스트에서 IP 처리에 특히 중요하다. 이런 이유로, IPv6에 옵션은 포함되지 않았다.
- **데이터**(페이로드): 데이터그램이 존재하는 이유이자 가장 중요한 마지막 필드다. 대부분의 경우 IP 데이터그램의 데이터 필드는 목적지에 전달하기 위해 트랜스포트 계층 세그먼트(TCP나 UDP)를 포함하지만 ICMP 메세지 같은 유형의 데이터를 담기도 한다.

IP 데이터그램은 총 20바이트의 헤더(옵션은 없다고 가정)를 갖는다. 데이터그램이 TCP 세그먼트를 전송한다면 단편화가 되지 않은 각 데이터그램은 애플리케이션 계층의 메세지와 더불어 총 40바이트의 헤더(IP 헤더 20바이트와 TCP 헤더 20바이트)를 전송한다.

# IPv4 주소체계
IP 주소체계를 살펴보기 전에 호스트와 라우터가 인터넷에 연결되는 방식에 관한 몇가지 용어를 정의하겠다. 호스트는 일반적으로 네트워크와 연결되는 하나의 링크를 갖는다. 호스트 IP가 데이터그램을 보낼 때 이 링크를 통해 데이터링크를 보낸다. 호스트와 물리적 링크 사이의 경계를 **인터페이스**라고 부른다. 이제 라우터와 인터페이스를 고려해보자. 라우터의 작업을 한 링크로부터 데이터그램을 수신하여 다른 링크로 전달하는 것이므로 라우터는 2개 이상의 연결된 링크가 필요하다. 라우터와 이런 링크 사이의 경계 또한 인터페이스라 하는데, 각 링크마다 하나의 인터페이스를 갖고 하나의 라우터는 여러 개의 인터페이스를 갖는다. 모든 호스트와 라우터는 IP 데이터그램을 송수신할 수 있으므로 IP는 각 호스트와 라우터 인터페이스가 IP 주소를 갖도록 요구한다. **따라서 기술 면에서 IP 주소는 인터페이스를 포함하는 호스트 라우터보다는 인터페이스와 관련이 있다**.

각 IP 주소는 **32비트**(4바이트) 길이다. 따라서 $2^{32}$(대략 40억 개)의 주소를 사용할 수 있다. 이 주소는 일반적으로 주소의 각 바이트를 십진수로 표현하고 주소의 다른 바이트와 점(.)으로 구분하는 십진 표기법(dotted-decimal notation)을 사용한다. 예를 들어, IP 주소가 193.32.216.9라고 하자. 193dms 주소의 첫 번째 8비트와 같다. 32는 주소의 두 번째 8비트와 같다.

전 세계 인터넷에서 모든 호스트와 라우터의 각 인터페이스는 고유한 IP 주소를 갖는다. 이런 주소는 마음대로 선택할 수 없고 인터페이스의 IP 주소 일부는 연결된 '서브넷'이 결정할 것이다.

IP 용어로 여러 호스트들의 인터페이스들과 하나의 라우터 인터페이스로 연결된 네트워크는 **서브넷**을 구성한다고 말한다. 서브넷의 예시를 살펴보자. IP 주소체계는 이 서브넷에 223.1.1.0/24(예시)와 같은 형식의 주소를 할당하는데, 여기서 /24는 **서브넷 마스크**라 부르며, 32비트 주소의 왼쪽 24비트가 서브넷 주소라는 걸 표현한다. 서브넷 223.1.1.0/24는 세 호스트 인터페이스(223.1.1.1, 223.1.1.2, 223.1.1.3)와 하나의 라우터 인터페이스(223.1.1.4)를 구성한다. 네트워크 223.1.1.0/24에 새로 부착할 호스트에는 223.1.1.xxx 형식의 주소가 필요할 것이다. 

서브넷의 IP 정의는 여러 호스트를 라우터 인터페이스에 연결하는 이더넷 세그먼트만을 의미하는 것은 아니다. 라우터의 주소에 대한 서브넷도 포함되는데 일반적인 라우터와 호스트를 연결한 시스템에서 서브넷을 정의하기 위해 다음과 같은 방법을 사용할 수 있다.

> 서브넷을 결정하려면 먼저 호스트나 라우터에서 각 인터페이스를 분리하고 고립된 네트워크를 만든다. 이 고립된 네트워크의 종단점은 인터페이스의 끝이 된다. 이렇게 고립된 네트워크 각각을 **서브넷**이라 부른다.

IP 주소는 각각의 인터페이스마다 부여된다고 보면 된다. 그럼 하나의 장치에 여러 개의 인터페이스가 달린 건 뭐가 있을까? 바로 '라우터'다.

## 1. Classful Addressing
예전에는 IP 주소를 고정된 크기로만 할당했었다.

- Class A: 0*
  - Very large / 8 blocks (example: MIT has 18.0.0.0/8)
  - 128 개의 기관 / 2의 24승 개의 호스트
- Class B: 10*
  -  Large / 16 blocks (example: Princeton has 128.112.0.0/16)
  - 2의 16승 개의 기관 / 2의 16승 개의 호스트
- Class C: 110*
  - Small / 24 blocks (example: AT&T Labs has 192.20.225.0/24)
  - 2의 24승 개의 기관 / 2의 8승 개의 호스트
- Class D: 1110* for multicast groups
- Class E: 11110* reserved for future use

이 방식은 IP 주소 할당을 유연하게 할 수 없어서(Class A를 할당받으면 너무 많은 IP 주소를 할당받게 되고, Class C는 너무 적은 IP 주소를 할당받게 된다) 2번 절의 방식이 제안된다.

## 2. Classless Inter-Domain Routing (CIDR)
8비트 단위로 prefix가 끊어지는게 아니라 자유롭게 끊어진다. 예를 들어, 12.4.0.0/15 이런 식으로 할당할 수 있다.

현대의 IP 주소는 CIDR를 따른다. 따라서 현재의 IP 주소들도 subnet(prefix) 부분, 호스트 부분, 그러니까 두 부분으로 이루어진다.

## 3. Longest Prefix Match Forwarding
포워딩 테이블에서 패킷의 목적지 IP 주소 값이 매칭되는 prefix가 여러개 있을 수 있다. 그러면 라우터는 그 prefix 들 중에 가장 긴 prefix를 택하여 포워딩을 수행한다.

## 4. Subnets
같은 IP 주소의 prefix를 가진 디바이스의 집합을 의미한다. 또다른 표현으로는 '라우터를 거치지 않고 접근이 가능한 호스트들의 집합'도 있다. 

라우터는 인터페이스를 여러 개 갖고, 그에 따라 IP 주소도 여러 개 갖는데 각 IP 주소가 다르다는 특징이 있다. 여러 개의 서브넷에 속한, 걸쳐 있는 디바이스이다.

## 5. NAT - Network Address Translation
IPv4의 IP 주소는 $2^{32}$ 갯수를 갖는데, IPv4를 설계하던 당시에는 인터넷이 지금처럼 상업화될 거라는게 예견되지 않았었다. 헌데 지금도 우리는 IPv4를 사용하고 있다. 사람들이 사용하는 고유한 디바이스 갯수가 IPv4의 IP 주소 갯수보다 커졌음에도 문제가 없이 사용하고 있는 이면에는 NAT라는 트릭이 있다.

NAT는 NAT를 지원하는 라우터에 IPv4 IP 주소를 할당하고 일정 범위의 디바이스의 IP 주소를 '그 범위 안에서만 고유하면 되는 IP 주소'로 할당해 NAT가 라우팅하게 한다. 그래서 NAT 범위 안의 디바이스가 NAT 범위 밖에 패킷을 내보낼 땐 NAT 라우터를 거쳐갈 때 source IP address를 rewrite 한다(Outbound). 그리고 NAT 범위 밖에서 안으로 패킷이 들어올 땐 destination IP address를 rewrite 한다(Inbound).

NAT가 IP address를 rewrite할 땐 (헤더 체크섬 값과) 포트 번호도 바꾼다. 그 포트 번호를 bound 내부의 고유한 IP 주소로 라우팅할 식별자로 쓰기 때문이다. NAT 라우터는  WAN side address를 키값으로, LAN side address를 value값으로 갖는 NAT translation table을 참조해 포워딩을 수행한다.

그런데 NAT 라우터가 translation 하는 작업에 집중해보자. source address와 destination address만 바꾸는게 아니라 포트 번호도 바꾸고 있다. 라우터는 네트워크 계층부터 하위 계층만 가진 device 이라는 점과 라우터는 네트워크 계층 레벨에서만 자신의 일을 수행하는 디바이스라는 점을 상기하자. 그런데 포트 번호를 바꾸는 것은 전송 계층에서 이루어져야 할 작업이다. 캡슐화되어 있는 DATA 부분을 열어서 하는 것이다. 이는 우체배달부가 편지봉투에 적힌 정보만 다뤄야 하는데 편지봉투를 뜯어서 그 안의 정보까지 다루고 있는 것이다. 이는 'Layer violation' 이다. 

그리고 NAT는 포트 번호를 프로세스를 식별하는 용도로 사용하지 않고 호스트를 식별하는 용도로 사용하기 때문에, NAT로 묶인 디바이스는 서버로 사용할 수 없다는 문제점도 있다.

## 6. DHCP - Dynamic Host Configuration Protocol
하나의 호스트가 인터넷을 사용하기 위해선 다음의 정보들을 알아야 한다.

1. 자신의 IP 주소
2. 자신의 서브넷 마스크
3. 자신의 NAT 라우터의 IP 주소
4. 자신의 범위에 해당하는 DNS의 IP 주소

고정 IP를 사용한다면 1, 2 항목은 항시 알고 있을 것이다. 하지만 와이파이를 사용한다거나 유동적으로 IP를 할당하여 비용을 절약하는 것이 DHCP로 가능하고, 그러면 IP 주소는 동적으로 할당된다.

### 6.1 DHCP 서버를 통한 주소 할당 과정

- **DHCP discover**: 처음에 클라이언트가 DHCP 서버에게 'DHCP discover' 를 시도한다. 이는 **DHCP discover message**를 통해 수행되며 클라이언트는 255.255.255.255(1.1.1.1, 브로드캐스트 주소) 주소로 포트 67번으로 UDP 패킷을 보낸다. source address는 아직 자신의 주소를 모르는 상태이기 때문에 0.0.0.0 으로 설정된다(포트 번호는 클라이언트가 특정 값으로 설정한다). 브로드캐스팅된 메세지는 DHCP server 에만 도달하게 되는데 그 이유는 DHCP server 만 67번 포트로 리스닝을 하고 있기 때문이다. 그리고 transaction id 값을 특정 값으로 설정해 보낸다.
- **DHCP offer**: DHCP server 가 DHCP discover message 를 수신하면 클라이언트에게 할당한 주소를 첨부한 메시지(DHCP offer message)로 응답한다. 이때에도 다시 IP 브로드캐스트 주소 255.255.255.255를 사용해 서브넷의 모든 노드로 이 메세지를 보낸다. 서브넷에는 여러 DHCP 서버가 존재하기 때문에, 클라이언트는 여러 DHCP 제공 메세지로부터 가장 최적의 위치에 있는 DHCP 서버를 선택한다. 각각 서버 제공 메세지는 수신된 discover message의 transaction id, 클라이언트에 제공된 IP 주소, 네트워크 마스크, IP 주소 임대 기간(IP address lease time)을 포함한다. 서버를 위해 설정하는 임대 시간은 일반적으로 몇 시간 또는 며칠이다.
- **DHCP request**: 클라이언트는 DHCP offer message 들을 확인해 하나 또는 그 이상의 서버 제공자 중에서 선택할 것이고 선택된 제공자에게 파라미터 설정으로 되돌아오는 **DHCP request message))로 응답한다. 이때도 브로드캐스트한다.
- **DHCP ACK**: 서버는 DHCP 요청 메세지에 대해 요청된 파라미터를 확인하는 **DHCP ACK message**로 응답한다.

보통 따로 DHCP 서버를 위한 호스트를 두기보다는 라우터에서 운영한다. DNS도 라우터에서, DHCP server도 라우터에서 운영하는 것이다.

## 7. IP fragmentation, reassembly
- network links have MTU(maximum transfer unit) - largest possible link - level frame
  - different link types, different MTUs
- large IP datagram divided("fragmented") within net
  - one datagram becomes several datagrams
  - "reassembled" only at final destination
  - IP header bits used to identify, order

패킷이 네트워크 경로들을 통과하던 중에 만난 링크 하나가 해당 패킷의 크기를 처리할 수 없는 링크면 그 라우터에서 바로 단편화를 한다.

## 8. ICMP: internet control message protocol
- used by hosts & routers to communicate network-level information
  - error reporting: unreachable host, network, port, protocol
  - echo request/reply (used by ping)
- network-layer "above" IP
  - ICMP msgs carried in IP datagrams
- ICMP message: type, code plus first 8 bytes of IP datagram causing error

# IPv6
## 1. Tunneling
IPv6를 도입한다면 IPv4와 IPv6를 함께 사용하면서 점차적으로 옮겨가는 과도기를 거치게 될 것이다. 그 과도기 동안에 두가지를 혼용하기 위한 방도가 **Tunneling**이다. IPv6 와 IPv4의 데이터그램을 모두 이해할 수 있는 IPv6 라우터를 IPv4 라우터만 있는 경로 바깥의 끝점에 두고 IPv4 라우터를 처음 만나기 전의 IPv6 라우터에서 IPv6의 데이터그램을 DATA 필드에 두고 헤더를 IPv4 방식으로 작성한다. IPv4 라우터는 IPv6의 헤더 방식을 이해할 수 없기 때문이다. 그래서 작성을 수행하는 IPv6 라우터에서 자신의 주소를 source에, IPv4 라우터들을 지나 처음 도달하게 될 IPv6 라우터의 주소를 destination 으로 작성한다.