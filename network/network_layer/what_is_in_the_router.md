# 2. 스위칭
## 2.1 메모리를 통한 교환
가장 단순한 초기의 라우터는 CPU(라우팅 프로세서)를 직접 제어해서 입력 포트와 출력 포트 사이에서 패킷을 스위칭하는 전통적인 컴퓨터이다. 입력 포트와 출력 포트는 전통적인 운영체제에서 전통적인 I/O 장치처럼 작동한다.

### 동작 과정:
1. 패킷이 도착하면 입력 포트는 라우팅 프로세서에게 인터럽트를 보내 패킷을 프로세서 메모리에 복사한다.
2. 그런 다음 라우팅 프로세서는 헤더에서 목적지 주소를 추출하고 포워딩 테이블에서 적절한 출력 포트를 찾은 다음 패킷을 출력 포트의 버퍼에 복사한다.

### 성능 제약:
이 시나리오에서 메모리 대역폭이 초당 최대 B인 패킷을 메모리에 쓰거나 메모리에서 읽을 수 있는 경우, 전체 전달 처리량(패킷이 입력 포트에서 출력 포트로 전송되는 총 속도)은 **B/2보다 작아야 한다**.

이는 각 패킷이 두 번의 메모리 접근을 필요로 하기 때문이다:
- 입력 포트 → 메모리 (쓰기)
- 메모리 → 출력 포트 (읽기)

또한 목적지 포트가 다른 경우라도 공유 시스템 버스를 통해 한 번에 하나의 메모리 읽기/쓰기 작업만 수행할 수 있기 때문에 두 패킷을 동시에 전달할 수 없다.

### 추가적인 한계점:
- **CPU 오버헤드**: 모든 패킷 처리에 CPU 개입 필요
- **인터럽트 처리 지연**: 패킷마다 인터럽트 처리 시간 소요
- **확장성 부족**: 포트 수 증가 시 성능 급격히 저하


## 2.2 버스를 통한 교환
라우터 내부에서 입력 포트가 라우팅 프로세서의 개입 없이 공유 버스를 통해 직접 출력 포트로 패킷을 전달하는 방식이다. 이 방식은 입력 포트와 출력 포트 간의 직접적인 연결을 제공함으로써 패킷 전달 속도를 높인다. 패킷에는 목적지 출력 포트를 식별하는 내부 레이블(스위치 헤더)이 추가되어 올바른 출력 포트로 전달된다. 이 레이블은 스위치 내부에서만 사용되므로 출력 포트에서 제거된다. 동시에 여러 패킷이 다른 입력 포트로 도착하면 한 번에 하나의 패킷만 버스를 통과할 수 있기 때문에 나머지 패킷들은 대기해야 한다. 모든 패킷이 하나의 공유 버스를 사용해야 하므로 라우터의 전체 교환 속도가 버스 속도로 제한된다. 이는 원형 교차로에서 한 번에 하나의 자동차만이 지날 수 있는 것과 유사하다. 그럼에도 불구하고 버스 기반 스위칭은 소규모 지역 및 기업 네트워크의 라우터에서 충분히 사용할 수 있다.


## 2.3 상호연결 네트워크
라우터 내부에서 입력 포트와 출력 포트를 연결하기 위해 복잡한 네트워크 구조를 사용하는 스위칭 방식이다. 이는 단일 공유 버스의 한계를 극복하기 위해 개발된 고성능 스위칭 기법이다. 

### 주요 특징
1. **다중 경로 제공**
   - 입력 포트와 출력 포트 사이에 여러 개의 경로가 존재
   - 단일 병목점을 제거하여 동시에 여러 패킷 전송 가능
   - 버스 기반 스위칭보다 훨씬 높은 처리량 달성
2. **병렬 처리 가능**
   - 서로 다른 입력-출력 포트 쌍이 동시에 통신 가능
   - 충돌하지 않는 경로들은 병렬로 패킷 전송
   - 전체 스위치 성능이 단일 링크 속도에 제한되지 않음
3. **확장성**
   - 포트 수가 증가해도 성능 저하가 적음
   - 모듈러 설계로 시스템 확장 용이

### 대표적인 구조
- **크로스바 스위치 (Crossbar Switch)**
  - N×N 격자 구조로 N개의 입력과 N개의 출력을 연결
  - 각 교차점에 스위치가 있어 경로 설정
  - 비블로킹(non-blocking): 사용 가능한 출력 포트가 있으면 항상 연결 가능
- **다단계 스위치 네트워크**
  - 여러 단계의 작은 스위치들을 조합
  - 예: Banyan 네트워크, Omega 네트워크
  - 비용 효율적이지만 일부 블로킹 가능성 존재

### 동작 방식
1. **경로 설정**: 입력 포트에서 목적지 출력 포트까지의 경로 결정
2. **스위치 구성**: 경로상의 각 스위치 요소들을 적절히 설정
3. **패킷 전송**: 설정된 경로를 통해 패킷 전달
4. **경로 해제**: 전송 완료 후 사용한 자원 해제

### 장점
- **높은 처리량**: 여러 패킷이 동시에 전송 가능
- **낮은 지연시간**: 직접 경로를 통한 빠른 전송
- **확장성**: 대규모 시스템에 적합
- **유연성**: 다양한 트래픽 패턴에 대응 가능

### 단점
- **복잡성**: 설계 및 제어가 복잡
- **비용**: 하드웨어 비용이 높음
- **스케줄링**: 효율적인 스위칭을 위한 복잡한 스케줄링 필요

### 실제 응용
- **고성능 라우터**: ISP나 데이터센터의 코어 라우터
- **스위치 패브릭**: 대용량 네트워크 장비의 내부 구조
- **병렬 컴퓨팅**: 슈퍼컴퓨터의 프로세서 간 연결

상호연결 네트워크를 통한 교환은 현대 고성능 네트워크 장비에서 필수적인 기술로, 인터넷 백본과 데이터센터에서 대용량 트래픽 처리를 가능하게 한다.


## 2.3 상호연결 네트워크를 통한 교환 - 크로스바 스위치
### 동작 원리
크로스바 스위치는 N개의 입력 포트와 N개의 출력 포트를 격자 형태로 연결하는 구조이다. 각 입력 버스와 출력 버스의 교차점에는 제어 가능한 교차점(crosspoint)이 있어 패킷의 경로를 설정한다.

### 패킷 전달 과정
1. **경로 설정**: 패킷이 포트 A에 도착하여 포트 Y로 전달되어야 하는 경우, 스위치 컨트롤러는 A 입력 버스와 Y 출력 버스의 교차점을 활성화한다.
2. **패킷 전송**: 활성화된 교차점을 통해 패킷이 A에서 Y 버스로 전달된다.
3. **선택적 수신**: Y 출력 버스에 연결된 포트 Y만이 해당 패킷을 수신한다.

### 병렬 처리의 장점
크로스바 스위치의 핵심 장점은 **동시 다중 패킷 전달**이다:

- **예시**: A→Y로 가는 패킷과 B→X로 가는 패킷이 동시에 처리될 수 있다
- **이유**: 서로 다른 입출력 버스 쌍을 사용하므로 경로가 겹치지 않는다
- **결과**: 이전의 메모리 기반, 버스 기반 스위칭과 달리 병렬 처리가 가능하다

### 비블로킹 특성
크로스바 스위치는 **비블로킹(non-blocking)** 특성을 가진다:
- 출력 포트가 사용 중이지 않다면 어떤 패킷도 차단되지 않는다
- 입력 포트에서 사용 가능한 출력 포트로의 연결은 항상 보장된다

### 충돌 상황과 해결
**충돌 발생**: 서로 다른 입력 포트(예: A포트, B포트)에서 동일한 출력 포트(예: Y포트)로 패킷이 동시에 전송되려는 경우

**해결 방법**:
- 한 번에 하나의 패킷만 특정 출력 버스를 사용할 수 있다
- 나머지 패킷은 해당 출력 포트가 사용 가능해질 때까지 대기한다
- 일반적으로 스케줄링 알고리즘을 통해 공정하게 처리한다

### 성능 특성
- **처리량**: 최대 N개의 패킷을 동시에 처리 가능 (N = 포트 수)
- **지연시간**: 직접 연결로 인한 낮은 지연시간
- **확장성**: 포트 수에 비례하여 성능 향상



# 3. 출력 포트 처리
출력 포트는 출력 포트의 메모리에 저장된 패킷을 가져와서 출력 링크를 통해 전송한다. 여기에는 전송을 위한 패킷 선택(스케줄링) 및 큐 제거, 필요한 링크 계층 및 물리 계층 전송 기능을 수행하는 것이 포함된다.



# 4. 어디에서 큐잉이 일어날까?
패킷 큐는 입력 포트와 출력 포트 모두에서 형성될 수 있다. 큐의 위치와 범위(입력 포트 큐 또는 출력 포트 큐)는 트래픽 로드, 스위치 구조의 상대 속도 및 라인 속도에 따라 달라진다. 큐가 커지면 라우터 메모리가 결국 소모되고 도착하는 패킷을 저장할 메모리가 없을 때 **패킷 손실**이 발생한다. 

## 4.1 입력 큐잉 
입력 포트를 통해 도착하는 모든 패킷을 전송하기에 스위치 구조가 충분히 빠르지 않으면 어떻게 되는가? 이 경우 패킷이 차례를 기다려야 한다. 이 큐잉의 결과를 살펴보기 위해 크로스바 스위치 구조를 가정해보자.
1. 모든 링크의 속도는 같다.
2. 입력 링크가 패킷을 받는 것과 같은 속도로 하나의 패킷을 입력 포트에서 주어진 출력 포트로 전달한다.
3. FCFS 방식으로 패킷은 입력 큐에서 출력 큐로 이동된다.
4. 각 패킷이 도달해야할 출력 포트가 다르다면 병렬로 전달될 수 있지만, 두 패킷이 같은 출력 큐로 향한다면 하나의 패킷만 전송이 가능하고 나머지는 차단된 채로 입력 큐에서 기다려야 한다.

4번의 경우에만 차단되어 입력 큐에서 기다려야 하는게 아니다. 스위치 구조에서 라인 앞 쪽에서 다른 패킷이 막고 있으면 자신이 사용할 출력 포트가 사용 중이지 않아도 기다려야 한다. 이 현상은 입력 대기 중인 스위치에서의 HOL(head-of-the-line) 차단(블로킹)이라고 한다. [karol 1987]은 입력 링크에서 패킷 도착 속도가 용량의 58%가 되면 HOL 차단 때문에 입력 큐가 무한정 길이로 증가함(즉, 중요한 패킷이 손실된다)을 보여준다. 즉, 패킷 손실이 증가한다. HOL 차단에 관한 해결책은 [McKeown 1997]을 참고한다.


## 4.2 출력 큐잉
스위치 속도가 출력 링크의 속도보다 N배 빠르며 N개의 입력 포트 각각에 도착하는 패킷이 동일한 출력 포트를 향하면 출력 포트에 큐잉이 발생한다. 출력 포트는 시간 단위(패킷 전송 시간)에 단일 패킷 하나만 전송할 수 있기 때문이다. 그리고 대기 중인 패킷의 수가 출력 포트에서 사용 가능한 메모리를 다 소모할 만큼 충분히 많아질 수 있다.

그렇게 메모리가 충분하지 않아지면 도착한 패킷을 삭제(drop-fail 정책으로 알려져 있음)하거나 이미 대기 중인 하나 이상의 패킷을 제거해서 새로 도착한 패킷을 저장하기 위한 공간을 확보해야 한다. 어떤 경우엔 버퍼가 가득 차기 전에 패킷을 삭제(또는 헤더를 마킹)해 송신자에게 혼잡 신호를 제공하는 것이 더 바람직할 수 있다. 이 마킹은 명시적 혼잡 알림(Explicit Congestion Notification, ECN)비트를 사용하여 수행할 수 있다. AQM(active queue management) 알고리즘으로 알려진 많은 '패킷 삭제'와 '패킷 마킹' 정책이 제안되거나 분석되고 있다.

이런 큐잉의 결과는 출력 포트의 **패킷 스케줄러**가 전송대기 중인 패킷 중 하나의 패킷을 선택해야 한다.


## 4.3 라우터 버퍼 크기 결정
라우터에서 적절한 버퍼 크기를 결정하는 것은 네트워크 성능과 비용에 직접적인 영향을 미치는 중요한 설계 요소이다.

### 전통적인 버퍼 크기 규칙 (RFC 3439)
**기본 원칙**: 몇 년 동안 네트워크 설계의 표준으로 사용되어 온 규칙

**공식**:
```
B = RTT × C
``` 
- **B**: 필요한 버퍼 크기
- **RTT**: 평균 왕복 시간 (Round Trip Time)
- **C**: 링크 용량

- **계산 예시**
  - 10 Gbps 링크, RTT가 250ms인 경우
  - B = 250ms × 10 Gbps = 2.5 Gb의 버퍼 필요

**적용 기반**: 상대적으로 적은 수의 TCP 흐름에 대한 큐잉 분석 결과 [Villamizar 1994]

### 현대적 버퍼 크기 규칙
**연구 배경**: 최근 이론 및 실험 연구 [Appenzeller 2004]

**개선된 공식**:
```
B = (RTT × C) / √N
``` 
- **N**: 링크를 통과하는 독립적인 TCP 흐름의 수

- **핵심 개선점**
  - TCP 흐름 수가 증가할수록 필요한 버퍼 크기가 감소
  - 통계적 다중화 효과를 반영한 더 정확한 모델

### 실제 네트워크에서의 적용
- **코어 네트워크 환경**
  - 대형 백본 라우터에는 수많은 TCP 흐름이 집중
  - N 값이 매우 크므로 √N으로 나누는 효과가 상당함
  - 결과적으로 필요한 버퍼 크기가 크게 감소

### 두 규칙의 비교
| 구분      | 전통적 규칙    | 현대적 규칙         |
|---------|-----------|----------------|
| 공식      | RTT × C   | (RTT × C) / √N |
| 적용 상황   | 적은 TCP 흐름 | 많은 TCP 흐름      |
| 버퍼 크기   | 상대적으로 큼   | 흐름 수에 따라 감소    |
| 네트워크 유형 | 소규모, 엣지   | 대규모, 코어        |

### 버퍼링의 양날의 검: 성능 vs 지연
- **버퍼링의 긍정적 효과**
  - 패킷 도착 속도의 변동 흡수
  - 패킷 손실률 감소
  - 트래픽의 단기 통계 변동 완화

- **버퍼링의 부정적 효과**
  - **큐잉 지연 증가**: 버퍼가 클수록 대기 시간 증가
  - **실시간 애플리케이션 영향**: 게임, 화상회의 등에서 수십 밀리초 지연 민감
  - **TCP 성능 저하**: 증가된 RTT로 인한 혼잡 제어 응답 속도 감소

- **균형점 찾기**
> 버퍼링은 마치 적당한 양의 소금이 음식의 맛을 향상시키지만, 너무 많은 소금은 음식을 먹을 수 없게 만드는 것과 같다.

### 버퍼블로트(Bufferbloat) 현상
- **정의**: 패킷의 과도한 버퍼링으로 인해 발생하는 패킷 교환 네트워크의 높은 대기 시간 문제
- **발생 환경**
  - 주로 네트워크 가장자리(엣지)에서 발생
  - 많은 독립적인 송신자가 경쟁하지 않는 환경
  - 홈 라우터, 소규모 네트워크 장비
- **버퍼블로트 시나리오 예시**
  - **상황 설정**:
    - 게이머의 TCP 세그먼트 전송 시간: 20ms
    - 종단간 RTT: 200ms
    - t=0에서 25개 패킷 버스트 도착
- **문제 발생 과정**
  1. **t=0**: 25개 패킷이 큐에 도착
  2. **t=200ms**: 첫 번째 ACK 도착 (21번째 패킷 전송 중)
  3. **ACK 클록 현상**: ACK가 도착할 때마다 새 패킷이 큐에 추가
  4. **지속적 큐잉**: 큐 크기가 항상 일정하게 유지 (약 5패킷)
  5. **결과**: 다른 트래픽이 없어도 지속적으로 긴 지연 발생
- **버퍼블로트의 특징**
  - 종단간 파이프는 최적 활용되지만 지연이 과도함
  - 큐잉 지연이 일정하고 지속적
  - 사용자가 원인을 이해하기 어려움

### 현실적 해결방안
- **네트워크 설계 고려사항**
  - **적용 환경별 구분**: 코어 vs 엣지 네트워크
  - **애플리케이션 요구사항**: 처리량 vs 지연시간 우선순위
  - **동적 버퍼 관리**: 트래픽 패턴에 따른 적응적 조정
- **기술적 해결책**
  - **AQM(Active Queue Management)**: 능동적 큐 관리 메커니즘
  - **DOCSIS 3.1 표준**: 케이블 네트워크에서 버퍼블로트 방지 [RFC 8033, RFC 8034]
  - **지연 기반 혼잡 제어**: BBR 등 새로운 TCP 알고리즘

### 핵심 교훈
- 처리량과 지연시간은 트레이드오프 관계
- 네트워크 위치(코어 vs 엣지)에 따라 다른 접근 필요
- 최소 지연도 처리량만큼 중요한 성능 지표 [Kleinrock 2018]
- 송신자 간의 상호작용이 복잡하고 미묘할 수 있음



# 5. 패킷 스케줄링
패킷 스케줄링은 큐에 대기 중인 패킷들이 출력 링크를 통해 전송되는 순서를 결정하는 핵심적인 네트워크 관리 기법이다.

## 5.1 패킷 스케줄링 개요
- **정의**: 라우터나 스위치에서 여러 패킷이 동일한 출력 링크를 사용하려고 할 때, 어떤 패킷을 먼저 전송할지 결정하는 알고리즘
- **중요성**
  - 네트워크 성능과 공정성에 직접적 영향
  - 서비스 품질(QoS) 보장의 핵심 요소
  - 다양한 애플리케이션 요구사항 충족


## 5.2 FIFO (First-In-First-Out) 스케줄링
### 기본 큐잉 메커니즘
- **패킷 처리 과정**
  1. **대기 단계**: 출력 링크가 다른 패킷을 전송 중일 때, 새로 도착한 패킷은 출력 링크 큐에서 대기
  2. **버퍼 관리**:
      - 버퍼 공간이 충분하지 않은 경우 패킷 폐기 정책 적용
      - 새 패킷 폐기 또는 기존 패킷 제거 결정
  3. **전송 완료**: 패킷이 출력 링크를 통해 완전히 전송되면 큐에서 제거

> **참고**: 본 논의에서는 설명의 단순화를 위해 패킷 폐기는 고려하지 않음

### FIFO 스케줄링 원리
- **정의**: 출력 링크 큐에 도착한 순서와 동일한 순서로 패킷을 전송하는 방식
- **별칭**: FCFS (First-Come-First-Served)
- **일상적 비유**: 서비스 센터의 대기줄과 동일한 원리로, 먼저 도착한 고객이 줄 뒤에서 기다리다가 맨 앞에 도달하면 서비스를 받는다.

### FIFO 동작 분석
- **타임라인 표현 방식**:
  - **상단 타임라인**: 패킷 도착 시점 (번호가 매겨진 화살표)
  - **하단 타임라인**: 개별 패킷 전송 시점
  - **사각형 영역**: 패킷 전송에 소비되는 시간 구간
- **예시 시나리오** (패킷 전송 시간: 3 단위):
  1. **순서 보장**: 패킷 1 → 2 → 3 → 4 순서로 전송
  2. **연속 처리**: 각 패킷이 도착 순서대로 **하나씩 차례대로** 처리됨
  3. **유휴 구간**: 패킷 4 전송 완료 후 패킷 5 도착까지 링크 유휴
  4. **원인**: 큐가 비어있는 상태 (패킷 1~4 모두 전송 완료)
```
시간축:  0----3----6----9----12----15----18
패킷 1:  [===]                              (0~3초 전송)
패킷 2:       [===]                         (3~6초 전송)  
패킷 3:            [===]                    (6~9초 전송)
패킷 4:                  [===]              (9~12초 전송)
유휴:                          -----        (12~15초, 패킷 5 대기)
패킷 5:                              [===]  (15~18초 전송)
```

### FIFO의 특성 분석
- 장점
  - **구현 단순성**: 가장 기본적이고 구현하기 쉬운 알고리즘
  - **공정성**: 도착 순서에 따른 공평한 처리 보장
  - **예측 가능성**: 대기 시간 계산이 상대적으로 용이
  - **오버헤드 최소**: 복잡한 우선순위 계산 불필요
- 한계점
  - **우선순위 미지원**: 모든 패킷을 동등하게 처리
  - **QoS 제한**: 실시간 트래픽과 일반 트래픽 구분 불가
  - **HOL 블로킹**: 큰 패킷이 작은 패킷들의 지연 유발 가능
  - **유연성 부족**: 네트워크 상황 변화에 적응하기 어려움
  - 
### 성능 지표
- **주요 메트릭**:
  - **평균 대기 시간**: 패킷이 큐에서 대기하는 평균 시간
  - **처리량**: 단위 시간당 전송되는 패킷 수
  - **큐 길이**: 평균적으로 대기 중인 패킷 수
  - **링크 활용률**: 출력 링크가 실제로 사용되는 비율
  - 
### 실무적 고려사항
- **적용 환경**
  - **적합한 경우**: 트래픽이 균등하고 우선순위가 필요 없는 환경
  - **부적합한 경우**: 실시간 애플리케이션과 배치 전송이 혼재하는 환경
- **개선 방향**
  - 우선순위 큐잉으로 발전
  - 가중 공정 큐잉(WFQ) 등 고급 기법 도입
  - 적응형 스케줄링 알고리즘 적용

### FIFO 스케줄링의 의의
FIFO 스케줄링은 가장 기본적인 패킷 스케줄링 방식으로, 복잡한 스케줄링 알고리즘의 기준점 역할을 한다. 비록 현대 네트워크의 다양한 QoS 요구사항을 충족하기에는 한계가 있지만, 그 단순성과 공정성으로 인해 여전히 많은 네트워크 장비에서 기본 스케줄링 방식으로 사용되고 있다.


## 5.3 우선순위 큐잉 (Priority Queuing)

### 우선순위 큐잉의 기본 개념
- **정의**: 출력 링크에 도착한 패킷을 우선순위 클래스로 분류하여, 높은 우선순위 패킷을 먼저 전송하는 스케줄링 방식
- **분류 과정**
  1. **패킷 도착**: 출력 링크 큐에 패킷 도착
  2. **우선순위 분류**: 패킷의 특성에 따라 우선순위 클래스 결정
  3. **큐 배치**: 해당 우선순위 클래스의 큐에 패킷 저장

### 우선순위 분류 기준
- **네트워크 관리 기준**
  - **관리 트래픽 우선**: 네트워크 관리 정보를 운반하는 패킷 > 사용자 트래픽
  - **포트 번호 기반**: 출발지 또는 목적지 TCP/UDP 포트 번호로 분류

- **애플리케이션 기준**
  - **실시간 트래픽**: VoIP 패킷 > 이메일 패킷
  - **서비스 유형**: 대화형 서비스 > 배치 전송 서비스

- **기술적 분류**
  - 각 우선순위 클래스는 **고유한 큐**를 보유
  - 클래스 내에서는 일반적으로 **FIFO 방식** 적용

### 우선순위 큐잉 동작 원리
- **패킷 선택 규칙**
  1. **최고 우선순위 우선**: 전송 대기 중인 패킷이 있는 가장 높은 우선순위 클래스에서 선택
  2. **클래스 내 FIFO**: 동일한 우선순위 클래스 내에서는 FIFO 방식으로 선택
  3. **비선점 방식**: 한 번 전송이 시작된 패킷은 중단하지 않음

### 동작 예시 분석
- **시나리오 설정**
  - **고우선순위**: 패킷 1, 3, 4
  - **저우선순위**: 패킷 2, 5
  - 각 패킷 전송 시간: 3 단위

**단계별 동작 과정**: 

| 시간  | 이벤트        | 동작         | 설명              |
|-----|------------|------------|-----------------|
| t=0 | 패킷 1 도착    | 즉시 전송 시작   | 링크가 유휴 상태       |
| t=1 | 패킷 2 도착    | 저우선순위 큐 대기 | 패킷 1 전송 중       |
| t=2 | 패킷 3 도착    | 고우선순위 큐 대기 | 패킷 1 전송 중       |
| t=3 | 패킷 1 전송 완료 | 패킷 3 전송 시작 | 고우선순위 우선 선택     |
| t=6 | 패킷 3 전송 완료 | 패킷 2 전송 시작 | 고우선순위 큐 비어있음    |
| t=7 | 패킷 4 도착    | 고우선순위 큐 대기 | 패킷 2 전송 중 (비선점) |
| t=9 | 패킷 2 전송 완료 | 패킷 4 전송 시작 | 고우선순위 우선 선택     |

**핵심 동작 특징**:
1. **우선순위 기반 선택**: 패킷 3이 패킷 2보다 늦게 도착했지만 먼저 전송
2. **비선점 특성**: 패킷 4가 패킷 2 전송 중에 도착했지만 대기
3. **클래스 내 순서**: 동일 우선순위 내에서는 도착 순서 유지

### 우선순위 큐잉의 특성
- 장점
  - **서비스 차별화**: 중요한 트래픽에 우선권 부여
  - **QoS 지원**: 실시간 애플리케이션의 요구사항 충족
  - **관리 효율성**: 네트워크 관리 트래픽 우선 처리
  - **구현 용이성**: 비교적 간단한 알고리즘
- 단점
  - **기아 현상**: 저우선순위 트래픽이 무한정 대기할 수 있음
  - **공정성 문제**: 우선순위가 낮은 사용자에게 불공평
  - **버퍼 관리**: 각 우선순위별 버퍼 크기 설정 복잡
  - **설정 복잡성**: 적절한 우선순위 분류 기준 설정 어려움

### 실무적 고려사항
- **설계 원칙**
  - **적절한 우선순위 수**: 너무 많은 클래스는 관리 복잡성 증가
  - **기아 방지**: 저우선순위 트래픽을 위한 최소 대역폭 보장
  - **동적 조정**: 네트워크 상황에 따른 우선순위 정책 변경
- **적용 분야**
  - **기업 네트워크**: 업무 중요도에 따른 트래픽 분류
  - **서비스 제공자**: 서비스 등급에 따른 차별화
  - **멀티미디어 네트워크**: 실시간 스트리밍 우선 처리

### 한계와 개선 방향
- **주요 한계**
  - 절대적 우선순위로 인한 불공정성
  - 저우선순위 트래픽의 성능 저하 가능성
- **개선 방안**
  - **가중 우선순위 큐잉**: 각 클래스에 최소 대역폭 보장
  - **적응형 우선순위**: 네트워크 상황에 따른 동적 조정
  - **하이브리드 방식**: 우선순위와 공정성을 함께 고려

우선순위 큐잉은 FIFO보다 발전된 형태로, 네트워크에서 서비스 품질 차별화를 위한 기본적인 메커니즘을 제공한다.

## 5.4 라운드 로빈과 WFQ
라운드 로빈 큐잉 규칙에서 패킷은 우선순위 큐잉과 같이 클래스로 분류된다. 그러나 클래스 간에는 엄격한 서비스 우선순위가 존재하지 않으며, 라운드 로빈 스케줄러가 클래스 간에 서비스를 번갈아서 제공한다. 가장 단순한 라운드 로빈 스케줄링에서는 클래스 1 패킷이 전송된 다음 클래스 2 패킷이 전송되고, 다시 클래스 1 패킷 다음에 클래스 2 패킷이 전송된다. 작업 보존 큐잉 규칙의 경우, 전송을 위해 큐에서 기다리는 패킷이 있다면 링크는 유휴 상태가 되는 것을 허용하지 않는다. 작업 보존 라운드 로빈 규칙에서는 클래스에서 패킷을 찾지만 아무것도 찾지 못하면 시퀀스의 다음 클래스를 즉시 검사한다. 

2개의 클래스 라운드 로빈 큐의 작동 예시를 살펴보자. 이 예에서 패킷 1, 2, 4는 클래스 1에 속하며 패킷 3, 5는 두 번째 클래스에 속한다. 패킷 1은 출력 큐에 도착하면 즉시 전송을 시작한다. 패킷 1이 전송되는 동안 패킷 2와 3이 도착하고 전송을대기한다. 패킷 1의 전송이 완료되면 링크 스케줄러는 클래스 2 패킷을 찾고 패킷 3을 전송한다. 패킷 3의 전송이 완료되면 스케줄러는 클래스 1 패킷을  찾고 패킷 2를 전송한다. 패킷 2의 전송이 완료되면 패킷 4만이 큐에 있기 때문에 바로 패킷 4를 전송한다.

라우터에서 널리 구현된 라운드 로빈 큐잉의 일반화된 형태는 소위 WFQ(Weighted Fair Queuing) 규칙이다. 여기서 도착하는 패킷은 적절한 클래스별 대기 영역에서 분류되며 대기한다. 라운드 로빈 스케줄링에서처럼 WFQ 스케줄러는 순환 방식으로 동작한다. 클래스가 3개 있다고 가정했을 때, 먼저 클래스 1이 동작하고 클래스 2 이후 클래스 3이 동작하는 패턴 작업을 반복한다. 또한 WFQ는 작업 보존 큐잉 규칙이며, 따라서 빈 클래스 큐를 찾으면 서비스 순서에서 다음 클래스로 즉시 이동한다.

WFQ는 각 클래스마다 다른 양의 서비스 시간을 부여받는다는 점에서 라운드 로빈과 차이가 있다. 특히 각 클래스 $i$는 가중치(weight) $w_{i}$를 할당받는다. WFQ에서는 전송할 클래스 $i$ 패킷이 있는 동안에 클래스 $i$는 $w_{i}/\sum w_{j}$의 처리율을 갖는다. 여기서 설명한 WFQ는 이상적인 것인데, 그 이유는 패킷이 이상적인 단위 데이터라는 것과 패킷 전송이 다른 패킷을 전송하기 위해 방해되지 않는다는 사실을 고려하지 않았기 때문이다.  



## 5.4 라운드 로빈과 WFQ (Weighted Fair Queuing)

### 라운드 로빈 큐잉 (Round Robin Queuing) 기본 개념

**정의**: 패킷을 클래스로 분류한 후, 클래스 간에 순환적(cyclic)으로 서비스를 제공하는 스케줄링 방식

- **우선순위 큐잉과의 차이점**
  - **우선순위 큐잉**: 클래스 간 엄격한 우선순위 존재
  - **라운드 로빈**: 클래스 간 엄격한 우선순위 없음, 순환적 서비스 제공

### 기본 라운드 로빈 동작

**단순 라운드 로빈 스케줄링**:
```
클래스 1 패킷 전송 → 클래스 2 패킷 전송 → 클래스 1 패킷 전송 → 클래스 2 패킷 전송 → ...
```

- **작업 보존 큐잉 규칙 (Work-Conserving)**
  - **정의**: 전송 대기 중인 패킷이 있다면 링크를 유휴 상태로 두지 않음
  - **동작**: 현재 클래스에 패킷이 없으면 즉시 다음 클래스 검사
  - **목적**: 링크 활용률 최대화

### 라운드 로빈 동작 예시
- **시나리오 설정**
  - **클래스 1**: 패킷 1, 2, 4
  - **클래스 2**: 패킷 3, 5

**단계별 동작 과정**:

| 단계 | 이벤트        | 스케줄러 동작            | 설명            |
|----|------------|--------------------|---------------|
| 1  | 패킷 1 도착    | 즉시 전송 시작           | 링크 유휴 상태      |
| 2  | 패킷 2, 3 도착 | 각각 클래스별 큐 대기       | 패킷 1 전송 중     |
| 3  | 패킷 1 전송 완료 | 클래스 2 검사 → 패킷 3 전송 | 라운드 로빈 순서     |
| 4  | 패킷 3 전송 완료 | 클래스 1 검사 → 패킷 2 전송 | 순환 계속         |
| 5  | 패킷 2 전송 완료 | 클래스 2 검사 → 비어있음    | 작업 보존 규칙 적용   |
| 6  | 클래스 1 재검사  | 패킷 4 전송            | 즉시 다음 클래스로 이동 |

- **핵심 특징**
  - **공정성**: 각 클래스가 순환적으로 서비스 받음
  - **효율성**: 빈 큐는 건너뛰어 링크 활용률 극대화
  - **예측 가능성**: 서비스 순서가 명확함

### WFQ (Weighted Fair Queuing) 기본 개념

**정의**: 라운드 로빈 큐잉의 일반화된 형태로, 각 클래스에 서로 다른 가중치를 부여하여 차별화된 서비스를 제공하는 방식

- **라운드 로빈과의 공통점**
  - 패킷의 클래스별 분류 및 대기
  - 순환적(cyclic) 서비스 제공
  - 작업 보존 큐잉 규칙 적용

### WFQ의 핵심 특징
- **가중치 기반 서비스**
  - 각 클래스 $i$에 가중치 $w_i$ 할당
  - 클래스 $i$의 처리율: $\frac{w_i}{\sum w_j}$
  - 가중치가 클수록 더 많은 대역폭 할당

**수학적 표현**:
```
클래스 i의 처리율 = w_i / (w_1 + w_2 + ... + w_n)
``` 

### WFQ 동작 원리

**3개 클래스 예시**:
```
클래스 1 (w₁=3) → 클래스 2 (w₂=2) → 클래스 3 (w₃=1) → 반복
``` 

- **서비스 시간 할당**
  - 총 가중치 합: 3 + 2 + 1 = 6
  - 클래스 1: 50% (3/6) 처리율
  - 클래스 2: 33% (2/6) 처리율  
  - 클래스 3: 17% (1/6) 처리율

### 이상적 WFQ의 가정

- **가정 조건**
  1. **무한 분할 가능**: 패킷을 무한히 작은 단위로 분할 가능
  2. **선점 가능**: 패킷 전송 중에도 다른 패킷으로 전환 가능
  3. **연속적 서비스**: 시간당 정확한 비율로 각 클래스 서비스

### 현실적 제약사항

- **패킷 단위 전송**
  - 패킷은 분할 불가능한 최소 단위
  - 패킷 전송은 비선점적 (non-preemptive)
  - 정확한 비율 달성이 어려움
- **실제 구현 고려사항**
  - **패킷 크기 변동**: 가중치대로 정확한 처리율 달성 困難
  - **버퍼 관리**: 각 클래스별 적절한 버퍼 크기 설정
  - **스케줄링 오버헤드**: 가중치 계산 및 클래스 관리 비용

### 라운드 로빈 vs WFQ 비교

| 특성         | 라운드 로빈       | WFQ            |
|------------|--------------|----------------|
| **공정성**    | 동등한 서비스 기회   | 가중치 기반 차별화     |
| **유연성**    | 모든 클래스 동일 처리 | 클래스별 서비스 차별화   |
| **구현 복잡성** | 상대적으로 단순     | 가중치 계산 및 관리 필요 |
| **QoS 지원** | 기본적인 공정성     | 세밀한 대역폭 제어     |
| **적용 분야**  | 동등한 우선순위 환경  | 차별화된 서비스 환경    |

### 라운드 로빈 실무적 활용, 적용 분야
- **로드 밸런싱**: 서버 간 균등한 요청 분배
- **CPU 스케줄링**: 프로세스 간 공정한 시간 할당
- **네트워크 기본 서비스**: 단순한 공정성이 필요한 환경

### WFQ 실무적 활용, 적용 분야
- **ISP 서비스**: 고객별 차등 대역폭 제공
- **기업 네트워크**: 부서별 트래픽 우선순위
- **멀티미디어 서비스**: 애플리케이션별 QoS 보장

### 라운드 로빈 장단점
- **장점**
  - 구현 단순성과 공정성 보장
  - 예측 가능한 서비스 패턴
  - 기아 현상 방지
- **단점**
  - 서비스 차별화 불가능
  - 다양한 QoS 요구사항 충족 어려움

### WFQ 장단점
- **장점**
  - 유연한 대역폭 할당 가능
  - 세밀한 QoS 제어 지원
  - 공정성과 효율성 균형
- **단점**
  - 구현 복잡성 증가
  - 가중치 설정의 어려움
  - 이상적 동작과 현실 간 차이

라운드 로빈과 WFQ는 네트워크에서 공정성을 기반으로 한 스케줄링의 대표적인 방식으로, 단순한 공정성에서 차별화된 서비스까지 다양한 요구사항을 충족할 수 있는 기반을 제공한다.
