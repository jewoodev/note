웹이 사용자에게 호감을 주는 주요한 요소는 웹이 **온디맨드** 방식으로 동작한다는 점이다. 사용자는 그들이 원할 때 원하는 것을 수신한다. 콘텐츠 제공자가 콘텐츠를 제공할 때 사용자가 주파수를 맞추고 있어야 하는 라디오/TV 방송과는 다른 것이다. 

그리고 개인이 웹상에 어떠한 정보를 사용 가능하게 만드는 것이 매우 쉽다. 모든 사람이 매우 낮은 비용을 들여 발행자가 될 수 있다는 것이다. 

## 1. HTTP 개요

웹의 애플리케이션 계층 프로토콜인 HTTP(HyperText Transfer Protocol)는 웹의 중심이다. 이것은 [RFC 1945](https://tools.ietf.org/html/rfc1945), [RFC 7230](https://tools.ietf.org/html/rfc7230), [RFC 7540](https://tools.ietf.org/html/rfc7540)에 정의되어 있다. 

HTTP는 두 가지 프로그램으로 구현된다. 각기 다른 종단 시스템에서 수행되는 클라이언트 프로그램과 서버 프로그램은 서로 HTTP 메세지를 교환하여 통신한다. HTTP는 메세지의 구조 및 클라이언트와 서버가 메세지를 어떻게 교환하는지에 대해 정의하고 있다. 

웹 페이지(= 웹 문서)는 객체들로 구성된다. **객체**(object)는 단순히 단일 URL로 지정할 수 있는 하나의 파일(HTML, 파일, JPEG 이미지, 자바스크립트, CSS 스타일 시트 파일, 비디오 클립 등)이다. 대부분의 웹 페이지는 기본 HTML 파일과 여러 참조 객체로 구성된다. 기본 HTML 파일은 페이지 내부의 다른 객체를 그 객체의 URL로 참조한다. 각 URL은 2개의 요소, 즉 객체를 갖고 있는 서버의 호스트 이름과 객체의 경로 이름을 갖고 있다.

웹 브라우저는 요구한 웹 페이지를 보여주고 여러 가지 인터넷 서핑과 구성 특성을 제공한다. 웹 서버는 URL로 지정할 수 있는 웹 객체들을 가지고 있다. 

HTTP는 웹 클라이언트가 웹 서버에게 웹 페이지를 어떻게 요청하는지와 서버가 클라이언트로 어떻게 웹 페이지를 전송하는지를 정의한다. HTTP는 TCP를 전송 프로토콜로 사용한다. HTTP 클라이언트는 먼저 서버에 TCP 연결을 시작한다. 연결이 이루어지고 나면, 브라우저와 서버 프로세스는 그들의 소켓 인터페이스를 통해 TCP로 접속한다. 그리고 나서 소켓을 통해 내보내진 메세지는 HTTP의 책임에서 떠나 TCP의 손에 쥐어진다. 그래서 HTTP는 데이터의 손실 또는 손실된 데이터를 어떻게 복구하고 네트워크 내부에서 올바른 순서로 데이터를 배열할 건지 걱정할 필요가 없다.

서버가 클라이언트에게 응답을 보낼 때, 클라이언트에 관한 어떤 상태 정보도 저장하지 않는다는 것을 기억하자. 그래서 같은 요청을 여러 차례 보내더라도 같은 객체를 재차 보낸다. 이러한 특징때문에 HTTP는 **비상태 프로토콜**(stateless protocol)이라고 한다. 웹 서버는 항상 켜져 있고, 고정 IP 주소를 가지며, 다른 잠재적인 수백만 브라우저로부터의 요청을 서비스한다.

## 2. 비지속 연결과 지속 연결

클라이언트가 서버에게 간헐적으로 요구하는 흐름을 보았을 때, 각 요구/응답마다 TCP 연결을 수립해서 보내져야 하는지 애플리케이션 개발자는 결정해야 한다. 매번 독립적인 연결을 수립한다면 **비지속 연결** 방식이고, 한 번에 여러 요구/응답을 처리하면 **지속 연결** 방식이다. HTTP는 기본적으로 지속 연결을 사용하지만 비지속 연결을 사용하도록 설정될 수 있다.

### 2.1 비지속 연결 HTTP

1. HTTP 클라이언트는 HTTP의 기본 포트 번호 80번을 통해 TCP 연결을 시도한다. 이 연결과 관련되는 각각의 소켓이 클라이언트와 서버에 있게 된다.
2. HTTP 클라이언트는 1단계에서 설정된 연결 소켓을 통해 서버로 HTTP 요청 메세지를 보낸다. 이 요청 메세지는 객체에 관한 경로 이름을 포함한다.
3. HTTP 서버는 1단계에서 설정된 연결 소켓을 통해 요청 메세지를 받는다. 저장 장치로부터 요청된 경로에 해당하는 객체를 추출한다. HTTP 응답 메세지에 그 객체를 캡슐화한다. 그리고 응답 메세지를 소켓을 통해 클라이언트로 보낸다.
4. HTTP 서버는 TCP에게 TCP 연결을 끊으라고 한다(그러나 실제로 TCP 클라이언트가 응답 메세지를 온전히 받을 때까지 연결을 끊지 않는다).
5. HTTP 클라이언트가 응답 메세지를 받으면, TCP 연결이 중단된다. 메세지는 캡슐화된 객체가 HTML 파일인 것을 나타낸다. 클라이언트는 응답 메세지로부터 파일을 추출하고 HTML 파일을 조사하고 10개의 JPEG 객체에 대한 참조를 찾는다.
6. 그 이후에 참조되는 각 JPEG 객체에 대해 처음 네 단계를 반복한다.

HTTP는 클라이언트가 웹 페이지를 어떻게 해석하는지는 관심이 없다. HTTP 명세서는 클라이언트 HTTP 프로그램과 서버 HTTP 프로그램 사이의 통신 프로토콜만 정의한다.

앞 단계는 서버가 객체를 보낸 후에 연결이 끊어져 비지속 연결을 사용하고 있다(연결이 다른 객체를 위해 유지되지 않는다). HTTP/1.0은 비지속 연결을 지원한다. 각 TCP 연결은 하나의 요청 메세지와 하나의 응답 메세지만 전송한다. 그래서 예시에서 총 11개의 TCP 연결이 만들어진다.

앞서 설명하는 부분에서는 클라이언트가 순차적으로 연결을 수립하는지, 아니면 동시에 수립하는지에 대해서는 언급하지 않았다. 사실 사용자가 동시성 정도를 조절할 수 있도록 브라우저를 구성할 수 있다. 이를 통해 응답 시간을 줄일 수 있다.

클라이언트가 요청을 송신하고 응답이 수신되는데까지 소요되는 시간을 살펴보자. 이 때 작은 패킷이 클라이언트로부터 서버까지 가고, 다시 되돌아오는 데에 걸리는 시간을 RTT(round-trip time)를 정의한다. RTT는 패킷 전파 지연, 패킷 큐잉 지연, 패킷 처리 지연 등을 포함한다. 

클라이언트가 서버로부터 객체를 요청할 때 발생하는 Three-way handshake 과정 중 처음 두 부분이 경과하면 한 RTT가 계산된다. 그 후 클라이언트는 HTTP 요청 메세지를 TCP 연결로 보내면서 핸드셰이크의 세 번째 부분(응답)을 함께 보낸다. 일단 요청 메세지가 서버에 도착하면 서버는 HTML 파일을 TCP 연결로 보낸다. 이 HTTP 요청/응답 과정에서 또 다른 RTT가 측정된다. 따라서 총 응답 시간은 대략 2 RTT와 HTML 파일을 서버가 전송하는 데에 걸리는 시간을 더한 것이다.

### 2.2 지속 연결 HTTP

비지속 연결은 다음과 같은 단점을 갖는다.

1. 각 요청 객체에 대한 새로운 연결이 설정되고 유지되어야 한다. 연결이 설정되고 유지되어야 하는 것에서 TCP 버퍼가 할당되어야 하고 TCP 변수들이 클라이언트와 서버 양쪽에 유지되는 것이 필요하다. 이러한 비용들은 수많은 클라이언트들의 요청을 동시에 처리해야 하는 웹 서버에 심각한 부담이 될 수 있다.
2. 각 객체는 2 RTT를 필요로 한다(TCP 연결 설정에 1 RTT, 요청/응답에 1 RTT).

HTTP/1.1 지속 연결에서 서버는 응답을 보낸 후 TCP 연결을 그대로 유지한다. 같은 클라이언트와 서버 간의 이후 요청과 응답은 같은 연결을 통해 보내진다. 특히, 전체 웹 페이지(HTML 문서와 여러 개의 이미지 등)를 하나의 지속 TCP 연결을 통해 보낼 수 있다. 그리고 같은 서버에 있는 여러 웹 페이지들을 하나의 지속 TCP 연결을 통해 보낼 수 있다. 그러한 관계를 갖는 객체에 대한 요구는 진행 중인 요구에 대한 응답을 기다리지 않고 연속해서 만들어질 수 있다(파이프라이닝(pipelining)). 일반적으로 HTTP 서버는 타임아웃 기간동안 사용되지 않으면 연결을 닫는다. 서버가 연속된 요구를 수신할 때, 서버는 연속적으로 객체를 내보낸다. HTTP의 default mode는 파이프라이닝을 이용한 지속 연결을 사용한다. 

## 3 HTTP 메세지 포맷

HTTP 명세서에서 정의하는 HTTP 메세지 포맷은 요청 메세지와 응답 메세지 두가지를 갖는다. 아래에서 이 두 가지 타입을 살펴본다.

### 3.1 HTTP 요청 메세지

다음은 전형적은 HTTP 요청 메세지다.

```
GET /somedir/example.html HTTP/1.1
Host: www.someschool.ac.kr
Connection: close
User-agent: Mozilla/5.0
Accept-language: kr
```

간단한 메세지이지만 다음과 같은 포맷을 갖는다. 

1. 메세지가 일반 ASCII 텍스트로 쓰여 있어 사람들이 읽을 수 있다.
2. 메세지가 다섯 줄로 되어있고 긱줄은 CR(carriage return)과 LF(line feed)로 구별된다. 마지막 줄에 이어서 추가 CR과 LF가 위치한다. 이 예시의 메세지는 다섯 줄이지만, 메세지는 더 많은 줄로 구성되거나 하나의 줄이 될 수도 있다. 

HTTP 요청 메세지의 첫 줄은 요청 라인(**request line**)이라 부르고, 이후의 줄들은 헤더 라인(**header line**)이라 부른다. 요청 라인은 3개의 필드, 즉 method 필드, URL 필드, HTTP 버전 필드로 구성된다. 

위의 예에서 헤더 라인을 살펴보자. 둘째 줄에서 객체가 존재하는 호스트를 명시하고 있다. 이미 호스트까지 TCP 연결이 맺어져 있기 때문에 이 헤더 라인이 필요한 것일까 의문이 들 수 있다. 하지만 호스트 헤더 라인이 제공하는 정보는 웹 프록시 캐시에서 필요로 한다. `Connection: close` 는 브라우저가 서버에게 지속 연결 사용을 원하지 않는다고 알려주고 있다. `User agent: `은 사용자 에이전트, 즉 서버에게 요청을 하는 브라우저 타입을 명시하고 있다. 이 헤더 라인은 서버가 같은 객체에 대한 다른 버전을 다른 타입의 사용자 에이전트에게 보낼 수 있으므로 유용하다. 마지막으로, `Accept-language: ` 는 사용자가 객체의 프랑스어 버전(서버에 존재한다면)을 원하고 있음을 알린다. 해당 버전의 객체가 없다면 서버는 기본 버전을 내보낸다. 

요청 메세지의 일반 포맷을 살펴보면 헤더 라인 다음으로 '개체 몸체(entity body)'가 있다. 이건 GET 방식에서는 비어있고 POST 방식에서 사용된다. HTTP 클라이언트는 사용자가 폼을 채워넣을 때 POST 방식을 사용한다. 폼으로 생성한 요구가 반드시 POST 방식을 사용할 필요가 있지는 않다. HTML 폼은 흔히 GET 방식을 사용하고 요청된 URL의 입력 데이터(폼 필드들)를 전송한다. 예를 들어, 만약 폼에 GET 방식을 사용하고 2개의 필드를 가지며 두 필드의 입력값이 name과 major이라면 URL은 www.someschool.ac.kr/some?name=John&major=CS 가 된다. 

HEAD 방식은 GET 방식과 유사하다. 서버가 HEAD 방식의 요청을 받으면 HTTP 메세지로 응답하는데, 요청 객체는 보내지 않는다. 애플리케이션 개발자가 주로 디버깅을 위해서 HEAD 요청을 사용한다. 

### 3.2 HTTP 응답 메세지

다음은 전형적인 HTTP 응답 메세지다.

```
HTTP/1.1 200 OK
Connection: close
Date: Tue, 18 Aug 2015 15:44:04 GMT
Server: Apache/2.2.3 (CentOS)
Last-Modified: Tue, 18 Aug 2015 15:44:04 GMT
Content-Length: 6821
Content-Type: text/html

(데이터 데이터 데이터 데이터 데이터 ...)
```

이 메세지는 3개의 섹션, 초기 상태 라인(status line), 6개의 헤더 라인, 개체 몸체로 이루어져있다. 이 개체 몸체는 요청 객체(데이터 데이터 ... 로 표현된 부분)를 포함한다. 상태 라인은 3개의 필드, 즉 프로토콜 '버전 필드', '상태 코드', '해당 상태 메세지'를 갖는다. 위 예시에서 상태 라인은 서버가 HTTP/1.1 을 사용하고 있고, 모든 것이 양호함(OK)을 나타낸다(즉, 서버가 요청 객체를 찾아서 보내고 있음을 알려준다).

응답 메세지의 헤더 라인들 중 Content-Length 헤더 라인은 송신되는 객체의 바이트 수를 나타낸다. Content-Type 헤더 라인은 개체 몸체 내부의 객체가 어떤 것인지 나타낸다. 객체 타입은 파일 확장자로 나타내는 것이 아니라 공식적으로 이 헤더로 나타낸다.

실제로 HTTP 응답 메세지를 어떻게 볼 수 있는가? 먼저 원하는 웹 서버에 텔넷으로 접속한다. 그 서버에 있는 객체에 대해 한 줄로 된 요청 메세지를 입력한다. 유닉스 컴퓨터에 로그인할 수 있다면 다음과 같이 압력하라(마지막 줄을 입력한 후 엔터를 두 번 쳐라).

```
telnet someschool.ac.kr 80

GET /kurose_ross/interactice/index.php HTTP/1.1
Host: someschool.ac.kr
```

위 메세지는 someschool.ac.kr 호스트의 80번 포트로 TCP 연결을 설정하고 다음에 HTTP 요청 메세지를 보낸다. 만약 HTTP 메세지 줄만 확인하고 객체 자체는 받지 않으려면 GET을 HEAD로 바꾸어 시도하자.

HTTP 명세서는 브라우저, 웹 서버, 네트워크 캐시 서버에 의해 삽입될 수 있는 많은 헤더 라인을 정의하고 있다.

브라우저는 요청 메세지에 포함되는 헤더 라인을 어떻게 결정하는가? 웹 서버는 응답 메세지에 어떤 헤더 라인을 포함할 것인지 어떻게 결정하는가? 브라우저는 브라우저 타입과 브라우저에 대한 사용자 설정, 그리고 브라우저가 현재 객체를 캐싱하고 있는지에 따라 헤더 라인을 생성한다. 웹 서버도 비슷하게 동작한다. 응답 메세지에 포함되는 헤더 라인에 영향을 주는 서로 다른 많은 제품, 버전, 설정이 있다.

## 4. 사용자와 서버 간의 상호작용: 쿠키

HTTP 서버가 상태를 유지하지 않는 특징은 서버 설계를 간단하게 하고 동시에 수천 개의 TCP 연결을 다룰 수 있는 고성능의 웹 서버를 개발하게 해주었다. 그런데 서버가 사용자 접속을 제한하거나 사용자에 따라 콘텐츠를 다르게 제공하기 위해 사용자를 확인하는 것이 필요하다. 그런 목적을 위해 HTTP는 쿠키를 사용한다. [RFC 6265]에 정의된 쿠키는 사이트가 사용자를 추적하게 해준다. 대부분의 주요  상용 웹사이트는 쿠키를 사용하고 있다.

중략...

## 5. 웹 캐싱

웹 캐시(**Web cache**, **프록시 서버**라고도 함)는 기점 웹 서버(origin Web server)를 대신해 HTTP 요구를 충족시키는 네트워크 개체다. 웹 캐시는 자체 저장 디스크를 갖고 있어 최근 호출된 객체의 사본을 저장 및 보존한다. 웹 캐시를 모든 HTTP 요청의 앞단에서 처리하도록 구성하면 다음과 같은 일이 발생한다.

1. 브라우저는 웹 캐시와 TCP 연결을 설정하고 웹 캐시에 있는 객체에 대한 HTTP 요청을 보낸다.
2. 웹 캐시는 객체의 사본이 자기에게 저장되어 있는지 확인한다. 만약 저장되어 있다면 클라이언트 브라우저로 HTTP 응답 메세지와 함께 객체를 전송한다.
3. 만약 웹 캐시가 객체를 갖고 있지 않다면, 웹 캐시는 기점 서버에 TCP 연결을 설정한다. 그리고 설정된 연결로 객체에 대한 HTTP 요청을 보낸다. 기점 서버는 요청을 받아 웹 캐시로 HTTP 응답 메세지와 함께 객체를 전송한다.
4. 웹 캐시의 객체를 수신할 때, 객체를 지역 저장장치에 복사하고 클라이언트 브라우저에 HTTP 응답 메세지와 함께 객체의 사본을 클라이언트 브라우저와 웹 캐시 간에 이미 설정되어 있는 TCP 연결을 통해 보낸다.

캐시는 서버이면서 클라이언트로써 동작하는 것을 알 수 있다. 

일반적으로 웹 캐시는 ISP가 구입하고 설치한다. 

웹 캐싱은 다음과 같은 장점이 있다. 

1. 클라이언트 요구에 대한 응답 시간을 줄일 수 있다. 특히, 클라이언트와 기점 서버 사이의 병목 대역폭이 클라이언트와 캐시 사이의 병목 대역폭에 비해 작을 수록 효과적이다.
2. 하나의 기관에서 인터넷으로의 접속하는 링크상의 웹 트래픽을 대폭 줄일 수 있다. 이를 통해 기관은 대역폭을 자주 개선할 필요가 없어지고, 결과적으로 인터넷 전체의 웹 트래픽을 줄여 모든 애플리케이션을 위한 성능을 개선한다.

콘텐츠 전송 네트워크(Content Distribution Network, CDN)의 사용을 통해, 웹 캐시는 인터넷에서 점진적으로 중요한 역할을 하고 있다. CDN 회사는 인터넷 전역을 통해 지역적으로 분산된 캐시를 설치해 유지하고 있으며, 이를 통해 많은 트래픽을 지역화하고 있다. 

### 5.1 조건부 GET

웹 캐시에 캐싱된 객체가 있는 와중에 웹 서버의 객체가 갱신되어 웹 캐시를 통해 응답되는 객체가 올바르지 않은 객체일 수 있다는 위험성을 해결하기 위한 방법으로,

HTTP는 클라이언트가 브라우저로 전달되는 모든 객체가 최신의 것인지 확인하면서 캐싱하게 해주는 방식을 갖고 있다. 그 방식을 **조건부 GET**(conditional GET)이라고 한다[RFC 7232]. HTTP 요청 메세지가 GET 방식을 사용하고, `Modified-Since: `헤더 라인을 포함하고 있다면, 그것이 조건부 GET 메세지다.

중략...
