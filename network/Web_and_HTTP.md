웹이 사용자에게 호감을 주는 주요한 요소는 웹이 **온디맨드** 방식으로 동작한다는 점이다. 사용자는 그들이 원할 때 원하는 것을 수신한다. 콘텐츠 제공자가 콘텐츠를 제공할 때 사용자가 주파수를 맞추고 있어야 하는 라디오/TV 방송과는 다른 것이다. 

그리고 개인이 웹상에 어떠한 정보를 사용 가능하게 만드는 것이 매우 쉽다. 모든 사람이 매우 낮은 비용을 들여 발행자가 될 수 있다는 것이다. 

## 1. HTTP 개요

웹의 애플리케이션 계층 프로토콜인 HTTP(HyperText Transfer Protocol)는 웹의 중심이다. 이것은 [RFC 1945](https://tools.ietf.org/html/rfc1945), [RFC 7230](https://tools.ietf.org/html/rfc7230), [RFC 7540](https://tools.ietf.org/html/rfc7540)에 정의되어 있다. 

HTTP는 두 가지 프로그램으로 구현된다. 각기 다른 종단 시스템에서 수행되는 클라이언트 프로그램과 서버 프로그램은 서로 HTTP 메세지를 교환하여 통신한다. HTTP는 메세지의 구조 및 클라이언트와 서버가 메세지를 어떻게 교환하는지에 대해 정의하고 있다. 

웹 페이지(= 웹 문서)는 객체들로 구성된다. **객체**(object)는 단순히 단일 URL로 지정할 수 있는 하나의 파일(HTML, 파일, JPEG 이미지, 자바스크립트, CSS 스타일 시트 파일, 비디오 클립 등)이다. 대부분의 웹 페이지는 기본 HTML 파일과 여러 참조 객체로 구성된다. 기본 HTML 파일은 페이지 내부의 다른 객체를 그 객체의 URL로 참조한다. 각 URL은 2개의 요소, 즉 객체를 갖고 있는 서버의 호스트 이름과 객체의 경로 이름을 갖고 있다.

웹 브라우저는 요구한 웹 페이지를 보여주고 여러 가지 인터넷 서핑과 구성 특성을 제공한다. 웹 서버는 URL로 지정할 수 있는 웹 객체들을 가지고 있다. 

HTTP는 웹 클라이언트가 웹 서버에게 웹 페이지를 어떻게 요청하는지와 서버가 클라이언트로 어떻게 웹 페이지를 전송하는지를 정의한다. HTTP는 TCP를 전송 프로토콜로 사용한다. HTTP 클라이언트는 먼저 서버에 TCP 연결을 시작한다. 연결이 이루어지고 나면, 브라우저와 서버 프로세스는 그들의 소켓 인터페이스를 통해 TCP로 접속한다. 그리고 나서 소켓을 통해 내보내진 메세지는 HTTP의 책임에서 떠나 TCP의 손에 쥐어진다. 그래서 HTTP는 데이터의 손실 또는 손실된 데이터를 어떻게 복구하고 네트워크 내부에서 올바른 순서로 데이터를 배열할 건지 걱정할 필요가 없다.

서버가 클라이언트에게 응답을 보낼 때, 클라이언트에 관한 어떤 상태 정보도 저장하지 않는다는 것을 기억하자. 그래서 같은 요청을 여러 차례 보내더라도 같은 객체를 재차 보낸다. 이러한 특징때문에 HTTP는 **비상태 프로토콜**(stateless protocol)이라고 한다. 웹 서버는 항상 켜져 있고, 고정 IP 주소를 가지며, 다른 잠재적인 수백만 브라우저로부터의 요청을 서비스한다.

## 2. 비지속 연결과 지속 연결

클라이언트가 서버에게 간헐적으로 요구하는 흐름을 보았을 때, 각 요구/응답마다 TCP 연결을 수립해서 보내져야 하는지 애플리케이션 개발자는 결정해야 한다. 매번 독립적인 연결을 수립한다면 **비지속 연결** 방식이고, 한 번에 여러 요구/응답을 처리하면 **지속 연결** 방식이다. HTTP는 기본적으로 지속 연결을 사용하지만 비지속 연결을 사용하도록 설정될 수 있다.

### 2.1 비지속 연결 HTTP

1. HTTP 클라이언트는 HTTP의 기본 포트 번호 80번을 통해 TCP 연결을 시도한다. 이 연결과 관련되는 각각의 소켓이 클라이언트와 서버에 있게 된다.
2. HTTP 클라이언트는 1단계에서 설정된 연결 소켓을 통해 서버로 HTTP 요청 메세지를 보낸다. 이 요청 메세지는 객체에 관한 경로 이름을 포함한다.
3. HTTP 서버는 1단계에서 설정된 연결 소켓을 통해 요청 메세지를 받는다. 저장 장치로부터 요청된 경로에 해당하는 객체를 추출한다. HTTP 응답 메세지에 그 객체를 캡슐화한다. 그리고 응답 메세지를 소켓을 통해 클라이언트로 보낸다.
4. HTTP 서버는 TCP에게 TCP 연결을 끊으라고 한다(그러나 실제로 TCP 클라이언트가 응답 메세지를 온전히 받을 때까지 연결을 끊지 않는다).
5. HTTP 클라이언트가 응답 메세지를 받으면, TCP 연결이 중단된다. 메세지는 캡슐화된 객체가 HTML 파일인 것을 나타낸다. 클라이언트는 응답 메세지로부터 파일을 추출하고 HTML 파일을 조사하고 10개의 JPEG 객체에 대한 참조를 찾는다.
6. 그 이후에 참조되는 각 JPEG 객체에 대해 처음 네 단계를 반복한다.

HTTP는 클라이언트가 웹 페이지를 어떻게 해석하는지는 관심이 없다. HTTP 명세서는 클라이언트 HTTP 프로그램과 서버 HTTP 프로그램 사이의 통신 프로토콜만 정의한다.

앞 단계는 서버가 객체를 보낸 후에 연결이 끊어져 비지속 연결을 사용하고 있다(연결이 다른 객체를 위해 유지되지 않는다). HTTP/1.0은 비지속 연결을 지원한다. 각 TCP 연결은 하나의 요청 메세지와 하나의 응답 메세지만 전송한다. 그래서 예시에서 총 11개의 TCP 연결이 만들어진다.

앞서 설명하는 부분에서는 클라이언트가 순차적으로 연결을 수립하는지, 아니면 동시에 수립하는지에 대해서는 언급하지 않았다. 사실 사용자가 동시성 정도를 조절할 수 있도록 브라우저를 구성할 수 있다. 이를 통해 응답 시간을 줄일 수 있다.

클라이언트가 요청을 송신하고 응답이 수신되는데까지 소요되는 시간을 살펴보자. 이 때 작은 패킷이 클라이언트로부터 서버까지 가고, 다시 되돌아오는 데에 걸리는 시간을 RTT(round-trip time)를 정의한다. RTT는 패킷 전파 지연, 패킷 큐잉 지연, 패킷 처리 지연 등을 포함한다. 

클라이언트가 서버로부터 객체를 요청할 때 발생하는 Three-way handshake 과정 중 처음 두 부분이 경과하면 한 RTT가 계산된다. 그 후 클라이언트는 HTTP 요청 메세지를 TCP 연결로 보내면서 핸드셰이크의 세 번째 부분(응답)을 함께 보낸다. 일단 요청 메세지가 서버에 도착하면 서버는 HTML 파일을 TCP 연결로 보낸다. 이 HTTP 요청/응답 과정에서 또 다른 RTT가 측정된다. 따라서 총 응답 시간은 대략 2 RTT와 HTML 파일을 서버가 전송하는 데에 걸리는 시간을 더한 것이다.

### 2.2 지속 연결 HTTP

비지속 연결은 다음과 같은 단점을 갖는다.

1. 각 요청 객체에 대한 새로운 연결이 설정되고 유지되어야 한다. 연결이 설정되고 유지되어야 하는 것에서 TCP 버퍼가 할당되어야 하고 TCP 변수들이 클라이언트와 서버 양쪽에 유지되는 것이 필요하다. 이러한 비용들은 수많은 클라이언트들의 요청을 동시에 처리해야 하는 웹 서버에 심각한 부담이 될 수 있다.
2. 각 객체는 2 RTT를 필요로 한다(TCP 연결 설정에 1 RTT, 요청/응답에 1 RTT).

HTTP/1.1 지속 연결에서 서버는 응답을 보낸 후 TCP 연결을 그대로 유지한다. 같은 클라이언트와 서버 간의 이후 요청과 응답은 같은 연결을 통해 보내진다. 특히, 전체 웹 페이지(HTML 문서와 여러 개의 이미지 등)를 하나의 지속 TCP 연결을 통해 보낼 수 있다. 그리고 같은 서버에 있는 여러 웹 페이지들을 하나의 지속 TCP 연결을 통해 보낼 수 있다. 그러한 관계를 갖는 객체에 대한 요구는 진행 중인 요구에 대한 응답을 기다리지 않고 연속해서 만들어질 수 있다(파이프라이닝(pipelining)). 일반적으로 HTTP 서버는 타임아웃 기간동안 사용되지 않으면 연결을 닫는다. 서버가 연속된 요구를 수신할 때, 서버는 연속적으로 객체를 내보낸다. HTTP의 default mode는 파이프라이닝을 이용한 지속 연결을 사용한다. 

## 3 HTTP 메세지 포맷

HTTP 명세서에서 정의하는 HTTP 메세지 포맷은 요청 메세지와 응답 메세지 두가지를 갖는다. 아래에서 이 두 가지 타입을 살펴본다.

### 3.1 HTTP 요청 메세지

다음은 전형적은 HTTP 요청 메세지다.

```
GET /somedir/example.html HTTP/1.1
Host: www.someschool.ac.kr
Connection: close
User-agent: Mozilla/5.0
Accept-language: kr
```

간단한 메세지이지만 다음과 같은 포맷을 갖는다. 

1. 메세지가 일반 ASCII 텍스트로 쓰여 있어 사람들이 읽을 수 있다.
2. 메세지가 다섯 줄로 되어있고 긱줄은 CR(carriage return)과 LF(line feed)로 구별된다. 마지막 줄에 이어서 추가 CR과 LF가 위치한다. 이 예시의 메세지는 다섯 줄이지만, 메세지는 더 많은 줄로 구성되거나 하나의 줄이 될 수도 있다. 

HTTP 요청 메세지의 첫 줄은 요청 라인(**request line**)이라 부르고, 이후의 줄들은 헤더 라인(**header line**)이라 부른다. 요청 라인은 3개의 필드, 즉 method 필드, URL 필드, HTTP 버전 필드로 구성된다. 

위의 예에서 헤더 라인을 살펴보자. 둘째 줄에서 객체가 존재하는 호스트를 명시하고 있다. 이미 호스트까지 TCP 연결이 맺어져 있기 때문에 이 헤더 라인이 필요한 것일까 의문이 들 수 있다. 하지만 호스트 헤더 라인이 제공하는 정보는 웹 프록시 캐시에서 필요로 한다. `Connection: close` 는 브라우저가 서버에게 지속 연결 사용을 원하지 않는다고 알려주고 있다. `User agent: `은 사용자 에이전트, 즉 서버에게 요청을 하는 브라우저 타입을 명시하고 있다. 이 헤더 라인은 서버가 같은 객체에 대한 다른 버전을 다른 타입의 사용자 에이전트에게 보낼 수 있으므로 유용하다. 마지막으로, `Accept-language: ` 는 사용자가 객체의 프랑스어 버전(서버에 존재한다면)을 원하고 있음을 알린다. 해당 버전의 객체가 없다면 서버는 기본 버전을 내보낸다. 

요청 메세지의 일반 포맷을 살펴보면 헤더 라인 다음으로 '개체 몸체(entity body)'가 있다. 이건 GET 방식에서는 비어있고 POST 방식에서 사용된다. HTTP 클라이언트는 사용자가 폼을 채워넣을 때 POST 방식을 사용한다. 폼으로 생성한 요구가 반드시 POST 방식을 사용할 필요가 있지는 않다. HTML 폼은 흔히 GET 방식을 사용하고 요청된 URL의 입력 데이터(폼 필드들)를 전송한다. 예를 들어, 만약 폼에 GET 방식을 사용하고 2개의 필드를 가지며 두 필드의 입력값이 name과 major이라면 URL은 www.someschool.ac.kr/some?name=John&major=CS 가 된다. 

HEAD 방식은 GET 방식과 유사하다. 서버가 HEAD 방식의 요청을 받으면 HTTP 메세지로 응답하는데, 요청 객체는 보내지 않는다. 애플리케이션 개발자가 주로 디버깅을 위해서 HEAD 요청을 사용한다. 

### 3.2 HTTP 응답 메세지

다음은 전형적인 HTTP 응답 메세지다.

```
HTTP/1.1 200 OK
Connection: close
Date: Tue, 18 Aug 2015 15:44:04 GMT
Server: Apache/2.2.3 (CentOS)
Last-Modified: Tue, 18 Aug 2015 15:44:04 GMT
Content-Length: 6821
Content-Type: text/html

(데이터 데이터 데이터 데이터 데이터 ...)
```

이 메세지는 3개의 섹션, 초기 상태 라인(status line), 6개의 헤더 라인, 개체 몸체로 이루어져있다. 이 개체 몸체는 요청 객체(데이터 데이터 ... 로 표현된 부분)를 포함한다. 상태 라인은 3개의 필드, 즉 프로토콜 '버전 필드', '상태 코드', '해당 상태 메세지'를 갖는다. 위 예시에서 상태 라인은 서버가 HTTP/1.1 을 사용하고 있고, 모든 것이 양호함(OK)을 나타낸다(즉, 서버가 요청 객체를 찾아서 보내고 있음을 알려준다).

응답 메세지의 헤더 라인들 중 Content-Length 헤더 라인은 송신되는 객체의 바이트 수를 나타낸다. Content-Type 헤더 라인은 개체 몸체 내부의 객체가 어떤 것인지 나타낸다. 객체 타입은 파일 확장자로 나타내는 것이 아니라 공식적으로 이 헤더로 나타낸다.

실제로 HTTP 응답 메세지를 어떻게 볼 수 있는가? 먼저 원하는 웹 서버에 텔넷으로 접속한다. 그 서버에 있는 객체에 대해 한 줄로 된 요청 메세지를 입력한다. 유닉스 컴퓨터에 로그인할 수 있다면 다음과 같이 압력하라(마지막 줄을 입력한 후 엔터를 두 번 쳐라).

```
telnet someschool.ac.kr 80

GET /kurose_ross/interactice/index.php HTTP/1.1
Host: someschool.ac.kr
```

위 메세지는 someschool.ac.kr 호스트의 80번 포트로 TCP 연결을 설정하고 다음에 HTTP 요청 메세지를 보낸다. 만약 HTTP 메세지 줄만 확인하고 객체 자체는 받지 않으려면 GET을 HEAD로 바꾸어 시도하자.

HTTP 명세서는 브라우저, 웹 서버, 네트워크 캐시 서버에 의해 삽입될 수 있는 많은 헤더 라인을 정의하고 있다.

브라우저는 요청 메세지에 포함되는 헤더 라인을 어떻게 결정하는가? 웹 서버는 응답 메세지에 어떤 헤더 라인을 포함할 것인지 어떻게 결정하는가? 브라우저는 브라우저 타입과 브라우저에 대한 사용자 설정, 그리고 브라우저가 현재 객체를 캐싱하고 있는지에 따라 헤더 라인을 생성한다. 웹 서버도 비슷하게 동작한다. 응답 메세지에 포함되는 헤더 라인에 영향을 주는 서로 다른 많은 제품, 버전, 설정이 있다.

## 4. 사용자와 서버 간의 상호작용: 쿠키

HTTP 서버가 상태를 유지하지 않는 특징은 서버 설계를 간단하게 하고 동시에 수천 개의 TCP 연결을 다룰 수 있는 고성능의 웹 서버를 개발하게 해주었다. 그런데 서버가 사용자 접속을 제한하거나 사용자에 따라 콘텐츠를 다르게 제공하기 위해 사용자를 확인하는 것이 필요하다. 그런 목적을 위해 HTTP는 쿠키를 사용한다. [RFC 6265]에 정의된 쿠키는 사이트가 사용자를 추적하게 해준다. 대부분의 주요  상용 웹사이트는 쿠키를 사용하고 있다.

중략...

## 5. 웹 캐싱

웹 캐시(**Web cache**, **프록시 서버**라고도 함)는 기점 웹 서버(origin Web server)를 대신해 HTTP 요구를 충족시키는 네트워크 개체다. 웹 캐시는 자체 저장 디스크를 갖고 있어 최근 호출된 객체의 사본을 저장 및 보존한다. 웹 캐시를 모든 HTTP 요청의 앞단에서 처리하도록 구성하면 다음과 같은 일이 발생한다.

1. 브라우저는 웹 캐시와 TCP 연결을 설정하고 웹 캐시에 있는 객체에 대한 HTTP 요청을 보낸다.
2. 웹 캐시는 객체의 사본이 자기에게 저장되어 있는지 확인한다. 만약 저장되어 있다면 클라이언트 브라우저로 HTTP 응답 메세지와 함께 객체를 전송한다.
3. 만약 웹 캐시가 객체를 갖고 있지 않다면, 웹 캐시는 기점 서버에 TCP 연결을 설정한다. 그리고 설정된 연결로 객체에 대한 HTTP 요청을 보낸다. 기점 서버는 요청을 받아 웹 캐시로 HTTP 응답 메세지와 함께 객체를 전송한다.
4. 웹 캐시의 객체를 수신할 때, 객체를 지역 저장장치에 복사하고 클라이언트 브라우저에 HTTP 응답 메세지와 함께 객체의 사본을 클라이언트 브라우저와 웹 캐시 간에 이미 설정되어 있는 TCP 연결을 통해 보낸다.

캐시는 서버이면서 클라이언트로써 동작하는 것을 알 수 있다. 

일반적으로 웹 캐시는 ISP가 구입하고 설치한다. 

웹 캐싱은 다음과 같은 장점이 있다. 

1. 클라이언트 요구에 대한 응답 시간을 줄일 수 있다. 특히, 클라이언트와 기점 서버 사이의 병목 대역폭이 클라이언트와 캐시 사이의 병목 대역폭에 비해 작을 수록 효과적이다.
2. 하나의 기관에서 인터넷으로의 접속하는 링크상의 웹 트래픽을 대폭 줄일 수 있다. 이를 통해 기관은 대역폭을 자주 개선할 필요가 없어지고, 결과적으로 인터넷 전체의 웹 트래픽을 줄여 모든 애플리케이션을 위한 성능을 개선한다.

콘텐츠 전송 네트워크(Content Distribution Network, CDN)의 사용을 통해, 웹 캐시는 인터넷에서 점진적으로 중요한 역할을 하고 있다. CDN 회사는 인터넷 전역을 통해 지역적으로 분산된 캐시를 설치해 유지하고 있으며, 이를 통해 많은 트래픽을 지역화하고 있다. 

### 5.1 조건부 GET

웹 캐시에 캐싱된 객체가 있는 와중에 웹 서버의 객체가 갱신되어 웹 캐시를 통해 응답되는 객체가 올바르지 않은 객체일 수 있다는 위험성을 해결하기 위한 방법으로,

HTTP는 클라이언트가 브라우저로 전달되는 모든 객체가 최신의 것인지 확인하면서 캐싱하게 해주는 방식을 갖고 있다. 그 방식을 **조건부 GET**(conditional GET)이라고 한다[RFC 7232]. HTTP 요청 메세지가 GET 방식을 사용하고, `Modified-Since: `헤더 라인을 포함하고 있다면, 그것이 조건부 GET 메세지다.

중략...

## 6. HTTP/2

2015년에 표준화된 HTTP/2[RFC 7540]는 1997년에 표준화된 HTTP/1.1 이후 새로운 HTTP의 첫 버전이다. HTTP/2가 발표된 이후 2020년까지 주요 웹사이트 천만 개 중 40%가 HTTP/2를 지원하고 있다[W3Techs]. 구글 크롬, 인터넷 익스플로러, 사파리, 오페라, 파이어폭스 등 대부분의 브라우저도 HTTP/2를 지원하고 있다.

HTTP/2의 주요 목표는 하나의 TCP 연결 상에서 멀티플렉싱 요청/응답 지연 시간을 줄이는데 있다. 그리고 HTTP/2는 요청 우선순위화, 서버 푸시, HTTP 헤더 필드의 효율적인 압축 기능 등을 제공한다. HTTP/2는 상태 코드, URL, 헤더 필드 등 HTTP 메소드 자체는 변경하지 않았다. 대신 클라이언트와 서버 간의 데이터 포맷 방법과 전송 방법을 변경했다.

HTTP/2의 필요성을 강조하기 위해 HTTP/1.1에 대해 다시금 살펴보자. HTTP/1.1은 지속적인 TCP 연결을 이용해 하나의 TCP 연결 상에서 서버로부터 클라이언트로 보내지는 웹페이지를 전달한다. 웹 페이지 당 오직 하나의 TCP 연결을 가짐으로써, 아래 설명하듯이 서버에서의 소켓 수를 줄이며 전송되는 각 웹 페이지는 공정한 네트워크 대역폭을 가질 수 있다. 그러나 웹 브라우저 개발자들은 하나의 TCP 상에서 웹 페이지에 있는 모든 객체를 보내면 **HOL**(Head of Line) **블로킹**문제가 발생할 수 있다는 사실을 빠르게 발견했다. 

HOL 블로킹을 이해하기 위해 하나의 HTML 기반 페이지, 웹 페이지 상단에 큰 비디오 클립이 위치하며 비디오 아래 많은 수의 작은 객체들을 포함하는 하나의 웹 페이지를 떠올려보자. 그리고 서버와 클라이언트 사이에는 저속에서 중간 속도의 병목(ex. 저속의 무선 링크) 링크가 있다. 하나의 TCP 연결을 이용하여 비디오 클립은 병목 링크를 통과하는데 오랜 시간이 걸리고, 작은 객체들은 비디오 클립 뒤에서 기다리는 시간이 길어진다. HTTP/1.1 브라우저에서는 여러 개의 병렬 TCP 연결을 열어서 HOL 블로킹 문제를 해결해왔다. 

TCP 혼잡 제어 또한 하나의 지속적인 연결 대신 여러 개의 병렬 TCP 연결을 사용함으로써 브라우저에게 예상치 못한 혜택을 주게 된다. TCP 혼잡 제어는 각 TCP 연결이 공정하게 병목 링크를 공유하여 같은 크기의 가용한 대역폭을 공평하게 나누게 해준다고 볼 수 있다. 만일 n개의 TCP 연결이 병목 링크에서 작동하고 있다면 각 연결은 대략 대역폭의 1/n씩을 사용하게 된다. 하나의 웹 페이지를 전송하기 위해 여러 개의 병렬 TCP 연결을 열게 함으로써 브라우저는 일종의 속임수로 링크 대역폭의 많은 부분을 받게 된다. HTTP/1.1 브라우저들 중 많은 수의 브라우저들은 6개까지 병렬 TCP 연결을 열 수 있으며 HOL 블로킹을 막을 뿐만 아니라 더 많은 대역폭을 사용할 수 있게 해준다.

> 여기서 말하는 "일종의 속임수"는 실제로 대역폭을 늘리는 것이 아니라, TCP의 혼잡 제어 메커니즘의 특성을 활용하는 것을 의미한다.
> 
> TCP 혼잡 제어의 핵심 원리를 설명하면:   
> TCP는 공정성(fairness)을 보장하기 위해 각 연결이 동일한 대역폭을 공유하도록 설계되어 있다.
> 예를 들어, 10Mbps의 병목 링크가 있고 2개의 TCP 연결이 있다면:
> 각 연결은 약 5Mbps씩 할당받게 된다.  
> 이는 TCP의 혼잡 제어 알고리즘(예: AIMD - Additive Increase Multiplicative Decrease)에 의해 자동으로 이루어진다.
> 
> 여기서 "속임수"라고 표현한 이유는:  
> 하나의 애플리케이션이 여러 개의 TCP 연결을 사용함으로써  
> TCP의 공정성 메커니즘을 우회하여  
> 전체 대역폭 중 더 큰 부분을 차지할 수 있기 때문이다.
> 
> 예를 들어:  
> 10Mbps 링크에서  
> 다른 애플리케이션이 1개의 TCP 연결을 사용하고  
> 우리 브라우저가 6개의 TCP 연결을 사용한다면  
> TCP의 공정성 메커니즘에 의해  
> 우리 브라우저는 약 8.5Mbps(10Mbps의 6/7)를 사용할 수 있게 된다.  
> 이는 실제로 링크의 물리적 대역폭을 늘리는 것이 아니라, TCP 프로토콜의 특성을 활용하여 더 많은 대역폭을 할당받는 방식입니다. 이런 이유로 "일종의 속임수"라고 표현한 것이다.

HTTP/2의 주요 목표 중 하나는 하나의 웹 페이지를 전송하기 위한 병렬 TCP 연결의 수를 줄이거나 제거하는 데에 있다. 이는 서버에서 열고 유지되는 소켓의 수를 줄일 뿐만 아니라 목표한 대로 TCP 혼잡 제어를 제어할 수 있게 하는데에 있다. 그러나 웹 페이지를 전송하기 위해 오직 하나의 TCP 연결만을 사용하게 될 경우 HTTP/2는 HOL 블로킹을 피하기 위해 신중하게 구현된 메커니즘이 필요하다.

### 6.1 HTTP/2 프레이밍

HOL 블로킹 문제의 해결책으로 등장한 HTTP/2는 각 메세지를 작은 프레임으로 나누고, 같은 TCP 연결에서의 요청과 응답 메세지를 인터리빙(끼우기)한다. 이를 이해하기 위해 앞서 언급한 하나의 큰 비디오 클립과 8개의 작은 객체로 이루어진 웹 페이지 예시를 다시 살펴보자. 

결론적으로 예시에서 서버는 이 웹 페이지를 응답해주기 위해 브라우저를 통해 9개의 병렬 요청을 받게 된다. 그리고 각 요청마다 9개의 경쟁적인 HTTP 응답 메세지를 브라우저로 보내야 한다. 이때 모든 프레임은 고정된 길이를 갖고, 비디오 클립은 1000개의 프레임으로 구성되며, 작은 객체들은 2개의 프레임으로 구성된다고 가정하자. 비디오 클립으로부터 하나의 프레임을 전송한 이후 프레임 인터리빙을 이용해 각 소형 객체의 첫 번째 프레임을 보낸다. 이후 두 번째 비디오 클립 프레임을 보내고 나서 각 소형 객체의 첫 번째 프레임을 보낸다. 이후 두 번째 비디오 클립 프레임을 보내고 나서 각 소형 객체의 마지막 프레임을 전송한다. 따라서 모든 소형 객체는 18개의 프레임을 보낸 후에 전송된다. 만약 인터리빙이 사용되지 않는다면 소형 객체들은 1016개의 프레임이 보내진 후에야 전송될 것이다. 만약 인터리빙이 사용되지 않는다면 소형 객체들은 1016개의 프레임이 보내진 후에야 전송될 것이다. 따라서 HTTP/2 프레이밍 메커니즘을 사용함으로써 사용자가 인지하는 지연 시간은 상당히 줄어들 수 있다.

HTTP 메시지를 독립된 프레임으로 쪼개고 인터리빙하여 반대편 사이트에서 재조립하는 것이 바로 HTTP/2의 가장 중요한 개선점이다. 프레이밍은 HTTP/2 프로토콜의 프레임으로 구현된 다른 프레이밍 서브 계층에 의해 이루어진다. 서버가 HTTP 응답을 보내려고 할 때, 응답은 프레이밍 서브 계층에 의해 처리되며 프레임 단위로 쪼개진다. 응답의 헤더 필드는 하나의 프레임이 되며 메세지 본문은 하나의 프레임으로 쪼개진다. 응답 프레임들은 서버의 프레이밍 서브 계층에 의해 인터리빙된 후 하나의 지속적인 TCP 연결을 통해 전송된다. 프레임들이 클라이언트에 도착하면 프레임 서브 계층에서 재조립되어 브라우저에 의해 처리된다. 클라이언트의 HTTP 요청도 동일하게 쪼개지고 인터리빙된다.

프레이밍 서브 계층은 각 HTTP 메세지를 독립적인 프레임으로 쪼갤뿐만 아니라 프레임을 바이너리 인코딩한다. 바이너리 프로토콜은 파싱하기 더 효율적이고, 좀 더 작은 프레임 크기를 갖기에 에러에 더 강하다.


### 6.2 메세지 우선순위화 및 서버 푸싱

메세지 우선순위화는 개발자가 요청들의 상대적 우선순위를 조정할 수 있게함으로써 애플리케이션 성능을 최적화할 수 있게 한다. 프레이밍 서브 계층은 같은 요청자로 향하는 메세지들을 병렬적인 데이터 스트림으로 쪼개준다. 클라이언트가 하나의 특정 서버로 동시에 여러 개의 요청을 할 때, 각 메세지에 1에서 256 사이의 가중치를 부여함으로써 요청에 우선순위를 매길 수 있다. 높은 수치일수록 높은 우선순위이다. 이런 가중치를 이용해 서버는 가장 높은 우선순위의 요청을 위한 프레임을 가장 먼저 보낼 수 있고, 클라이언트는 각 의존도에 따라 메세지의 ID를 저장함으로써 서로 다른 메세지 간의 의존성을 나타낼 수 있다.

HTTP/2의 또 다른 특징은 서버로 하여금 특정 클라이언트 요청에 대해 여러 개의 응답을 보낼 수 있게 하는데 있다. 요청에 대한 응답 외에도 서버는 클라이언트의 요청 없이도 추가적인 객체를 클라이언트에게 푸시해 보낼 수 있다. 이는 HTML 기반 페이지가 웹 페이지를 완벽하게 구동시킬 필요가 있는 객체들을 가리킬 수 있기에 가능하다. 이러한 객체에 대한 HTTP 요청을 기다리는 대신 서버는 HTML 페이지를 분석할 수 있고, 필요한 객체들을 식별할 수 있고, 해당 객체들에 대한 요청이 도착하기도 전에 해당 객체들을 클라이언트로 보낸다. 이러한 능동성으로 서버는 해당 요청들을 기다리는 데 소요되는 추가 지연을 없앤다.

### 6.3 HTTP/3

QUIC는 새로운 트랜스포트 프로토콜이며, UDP 프로토콜 위에 위치하는 애플리케이션 계층에 구현되어 있다. QUIC는 메세지 멀티플렉싱(인터리빙), 스트림별 흐름 제어, 저지연 연결 확립과 같은 HTTP에 의미 있는 여러 특징을 갖는다. HTTP/3은 QUIC 위에서 작동하도록 설계된 새로운 HTTP 프로토콜으로써, 2020년 현재 인터넷 드래프트로 나와 있지만 완전히 표준화된 상태는 아니다. 메세지 인터리빙과 같은 HTTP/2 특징들은 QUIC에 포함되며 HTTP/3을 위한 훨씬 더 간단한 설계를 가능하게 할 것이다.
