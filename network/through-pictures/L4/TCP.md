물리, 데이터링크, 네트워크 계층을 이용하면 원하는 호스트에 정확하게 데이터를 전달할 수 있다. 하지만 문제가 발생해 패킷 내용에 왜곡이 발생하거나 패킷이 분실되는 상황이 발생할 수 있다. TCP는 그런 문제를 해결하는 프로토콜이다.

# TCP
- 데이터의 신뢰성을 보장하는 프로토콜

## 3-way handshake
1. 수신측: SYN
2. 송신측: SYN/ACK
   - 최대 세그먼트 길이를 결정지어 보냄
     - TCP는 데이터를 세그먼테이션, 즉 분할해서 전송
       1. 너무 큰 데이터가 분실되면 잃어버리게 되는 데이터가 커지기 때문
          - 분할해서 전송하면, 일부 데이터가 손실되었을 때 그 일부 데이터만 재전송하는 것으로 해결 가능
       2. 데이터링크 계층에서 보낼 수 있는 데이터의 최대 크기가 정해져 있기 때문
          - 이더넷 프레임의 기본값을 사용한다면 1500Byte
            - TCP와 IP의 헤더값 20씩을 빼면 1460Byte가 최대 
3. 수신측: ACK
   - 전달받은 최대 세그먼트 크기로 보내겠다는 확인 여부를 보냄

## 커넥션 확립 후 데이터 전송
1. 세그먼트 헤더의 **순서 번호 필드**(seq)가 31(가정)이고 확인응답 번호 필드(ack)가 0인 것이 송신된다.
2. 수신한 호스트는 ack 필드에 `'수신한 seq 값'(31) + '데이터 크기' + 1`을 적어 송신 측에 전송
   - 이 세그먼트의 순서 번호 필드에는 다른 순서 번호 값(수신 측의 순서 번호)이 들어감
   - 즉, 수신 호스트와 송신 호스트는 각기 다른 순서 번호를 관리함
   - 이 메세지는 ACK 메시지
3. 송신 측은 ACK 메세지를 받으면 그 다음 데이터를 전송함
   - seq 필드에는 ACK 메세지의 'ack 필드 값'을 적음
   - ack 필드에는 `'ACK 메세지의 seq 값' + 데이터 크기 + 1`을 적음
4. 송신 측이 3번에서 전송한 메세지에 대한 ACK 메세지를 받지 못하면
   - 수신 측이 데이터를 받지 못했다고 판단
   - 같은 데이터를 재전송
5. 송신 측이 ACK 메세지를 받으면 또 '그 다음 데이터'를 전송함

## 커넥션 끊는 과정
- 4-way handshake를 거쳐 진행됨
1. FIN
2. ACK
3. FIN
4. ACK
   - 이 메세지를 보낸 호스트가 먼저 소켓을 닫음
   - 받은 호스트가 일정 시간을 기다렸다가 소켓을 닫음