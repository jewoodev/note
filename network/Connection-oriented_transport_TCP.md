TCP는 신뢰적인 데이터 전송을 제공하기 위해 '오류 검출', '재전송', '누적 확인응답', '타이머', '순서 번호'와 '확인응답 번호를 위한 헤더 필드'에 관한 원칙들을 따르고 있다. TCP는 RFC 793, RFC 1122, RFC 2018, RFC 5681, RFC 7323에 정의되어 있다.

## 1. TCP 연결

TCP는 애플리케이션 프로세스가 데이터를 다른 프로세스로 보내기 전에 두 프로세스가 서로 '핸드셰이크'를 먼저 해야 하는 **연결지향형** 프로토콜이다. 즉, 데이터 전송을 보장하는 파라미터들을 각자 설정하기 위한 사전 세그먼트들을 보내야 한다. TCP 연결 설정 과정에서 연결 대상인 종단들은 TCP 연결과 관련된 많은 변수들을 초기화한다.

TCP '연결'은 회선 교환 네트워크같은 환경 종단 간의 TDM이나 FDM이 아니다. 두 통신 종단 시스템의 TCP에 존재하는 상태를 공유하는 논리적인 것이다. TCP 프로토콜은 종단 시스템에서만 동작하고 다른 네트워크 요소에서는 동작하지 않아서 TCP 연결 상태를 유지하지 않는다. 아니, 연결을 아예 전혀 감지하지 못한다. 그저 데이터그램만 본다.

TCP 연결은 **전이중 서비스**(full-duplex service)를 제공한다. 그리고 항상 단일 송신자와 단일 수신자 사이의 점대점(point-to-point)이다. 한 번의 송신 동작으로 한 송신자가 여러 수신자에게 데이터를 전송하는 '멀티캐스팅'은 불가능하다.

TCP 연결은 클라이언트 애플리케이션 프로세스가 TCP 클라이언트에게 서버의 프로세스와 연결을 원한다고 알리는 것으로 설정되기 시작한다. 그러면 클라이언트의 트랜스포트 계층은 서버의 TCP와의 TCP 연결 설정을 진행한다. 이때, 클라이언트가 특별한 TCP 세그먼트를 보낸다. 그러면 서버는 두 번째 특별한 TCP 세그먼트로 응답한다. 마지막으로, 클라이언트가 세 번째 특별한 세그먼트로 다시 응답한다. 처음 2개의 세그먼트에는 페이로드, 즉 애플리케이션 계층 데이터가 없다. 그리고 세 번째 세그먼트는 페이로드를 포함할 수 있다. 이 세 번을 거쳐 설정되는 절차를 세 방향 핸드셰이크(three-way handshake)라 부른다.

TCP 연결을 통해 송신된 데이터가 관문을 통해 전달되면, 클라이언트에서 동작하고 있는 TCP에게 맡겨진다. TCP는 초기 세 방향 핸드셰이크 동안 준비된 버퍼 중 하나인 연결의 **송신 버퍼**(send buffer)로 데이터를 보낸다. TCP는 송신 버퍼의 데이터를 하나씩 보내는게 아닌 묶음으로 보낼 수 있다. [RFC 793]에서 TCP는 '자신이 편한 대로 세그먼트의 데이터를 전송'해야 한다고 기술되어 있으며 정해져 있는 전송 시점에 대해서는 기술하고 있지 않다. 세그먼트로 모아 담을 수 있는 최대 데이터 양은 **최대 세그먼트 크기**(maximum segment size, MSS)로 제한된다. MSS는 일반적으로 해당 호스트에서 전송될 수 있는 가장 큰 링크 계층 프레임의 길이(최대 전송 단위(maximum transmission unit, MTU))에 의해 1차적으로 결정되고, TCP 세그먼트(IP 데이터그램 안에 캡슐화되었을 때)와 TCP/IP 헤더 길이(통상 40바이트)가 단일 링크 계층 프레임에 맞도록 해서 정해진다. 따라서 MSS의 일반적인 값은 1460 바이트이다. MSS가 헤더를 포함하는 TCP 세그먼트의 최대 크기가 아니라, 세그먼트에 있는 애플리케이션 계층 데이터에 대한 최대 크기라는 것에 유의하자.

TCP는 TCP 헤더와 클라이언트 데이터를 하나로 짝지어 TCP 세그먼트를 구성한다. TCP가 상대에게서 세그먼트를 수신했을 때 세그먼트의 데이터는 TCP 연결의 수신 버퍼에 위치하게 된다. 그럼 애플리케이션은 이 버퍼로부터 데이터의 스트림을 읽는다. 연결의 양 끝은 각각 자신의 송신 버퍼와 수신 버퍼를 갖고 있다. 

이번에 살펴본 내용들로 하여금 TCP 연결은 한 쪽 호스트에서의 버퍼, 변수, 프로세스에 대한 소켓 연결과 다른 쪽 호스트에서의 버퍼, 변수 프로세스에 대한 소켓 연결의 집합으로 이루어진다는 걸 알 수 있다. 앞에서 언급한 대로, 버퍼와 변수는 종단 간을 잇는 경로의 네트워크 요소(라우터, 스위치, 리피터)의 연결에는 할당되지 않는다.

## 2. TCP 세그먼트 구조

TCP 세그먼트는 '헤더 필드'와 '데이터 필드'로 구성되어 있다. 데이터 필드는 애플리케이션 데이터의 일정량을 담는다. MSS는 세그먼트의 데이터 필드의 크기를 제한한다. TCP가 웹 문서의 이미지와 같은 큰 파일을 전송할 때, 일반적으로 MSS 크기로 파일을 분절한다. 하지만 대화식 애플리케이션들은 통상적으로 MSS 크기 보다 작은 데이터를 전송한다. 예를 들어 텔넷과 ssh 같은 원격 로그인에서는 TCP 세그먼트의 데이터 필드는 1바이트 밖에 안된다. TCP 헤더는 일반적으로 20바이트(UDP 헤더보다 12바이트 크다)이므로, 텔넷과 ssh에 의해 전송되는 세그먼트는 21 바이트 길이가 된다.

TCP 헤더는 UDP처럼 상위 계층 애플리케이션으로부터 다중화와 역다중화를 하는데 필요한 출발지와 목적지 포트번호를 포함한다. 그리고 UDP처럼 체크섬 필드도 포함한다. 또, 다음과 같은 필드를 포함한다.

- 32 비트 **순서 번호 필드**(sequence number field)와 32비트 **확인응답 번호 필드**(acknowledgement number field)는 신뢰적인 데이터 전송 구현에서 TCP 송신자와 수신자에 의해 사용된다.
- 16비트 **수신 윈도**(receive window) 필드는 흐름 제어에 사용된다. 이건 수신자가 받아들이려는 바이트 크기를 나타낸다.
- 4비트 **헤더 길이 필드**는 32비트 워드 단위로 TCP 헤더 길이를 나타낸다. TCP 헤더는 이전에 논의한 TCP 옵션 필드 때문에 가변적인 길이가 될 수 있다(일반적으로는 TCP 길이가 20바이트가 되도록 옵션 필드가 비어 있다.).
- 선택적이고 가변적인 길이의 **옵션 필드**는 송신자와 수신자가 최대 세그먼트 크기(MSS)를 협상하거나 고속 네트워크에서 사용하기 위한 윈도 확장 요소로 사용된다. 타임스탬프 옵션 또한 정의된다. 
- **플래그 필드**는 6비트를 포함한다. **ACK 비트**는 확인응답 필드에 있는 값이 유용한지를 나타나는데 쓰인다. **RST, SYN, FIN** 비트는 연결 설정과 해제에 사용된다. **PSH** 비트가 설정될 때, 이건 수신자가 데이터를 상위 계층에 즉시 전달해야 한다는 것을 가리킨다. 마지막으로, **URG** 비트는 이 세그먼트에서 송신 측 상위 계층 개체가 '긴급'으로 표시하는 데이터임을 가리킨다. 이 긴급 데이터의 마지막 바이트 위치는 16비트의 긴급 데이터 포인터 필드에 의해 가리켜진다. TCP는 긴급 데이터가 존재할 때 수신 측 상위 계층 개체에게 통지해야 하고 긴급 데이터의 끝에 대한 포인터를 전달한다(PSH, URG 그리고 긴급 데이터에 대한 포인터는 실제론 쓰이지 않지만 완벽하게 하기위해 이러한 필드를 전달한다).

### 2.1 순서 번호와 확인응답 번호

TCP 세그먼트 헤더에서 가장 중요한 필드 두 개는 순서 번호 필드와 확인응답 번호 필드다. 이 필드들은 TCP가 신뢰적인 전송을 가능하게 하는데에 중요한 역할을 한다. 

TCP는 데이터를 구조화되어 있지 않고 순서대로 정렬되어 있는 바이트 스트림으로 본다. 그래서 TCP의 순서 번호도 수신된 세그먼트에 대한 것이 아닌, 전송된 바이트 스트림에 대한 것이다. **세그먼트에 대한 순서 번호**는 세그먼트에 있는 첫 번째 바이트의 바이트 스트림 번호이다. 

확인응답 번호가 무엇인지 살펴보자. 호스트 A, B가 서로 데이터를 교환하는 경우에서, 호스트 A가 자신의 세그먼트에 삽입하는 확인응답 번호는 호스트 A가 호스트 B로부터 기대하는 다음 바이트의 순서 번호다. 만약 A가 B로부터 0부터 300까지의 번호들이 붙은 바이트를 수신했다면, A는 B의 데이터 스트림에서 301번째 바이트와 그 다음 순서의 바이트를 기다리고 있다. 이때 A가 B에게 세그먼트를 송신한다면 A는 그 세그먼트의 확인응답 번호 필드에 301을 삽입한다.

다른 예로 '0~300의 바이트를 포함한 세그먼트'와 '601~900의 바이트를 포함한 세그먼트'를 수신했다고 해보자. 그럼 어떤 이유인지 모르겠지만 301~600 번째 바이트는 수신하지 못한 것이다. 따라서 A는 B의 데이터 스트림을 재생성하기 위해 '301번째와 그 다음의 바이트'를 기다리고 있게 된다. 그렇기 때문에 B에 대한 A의 다음 세그먼트에는 확인응답 번호 필드에 301이 들어가 있을 것이다. TCP는 스트림에서 첫 번째 잃어버린 바이트까지의 바이트들까지만 확인응답하기 때문에, **누적 확인응답**(cumulative acknowledgement)을 제공한다고 한다.

### 2.2 텔넷: 순서 번호와 응답확인 번호 사례연구

텔넷은 TCP 상에서 실행되며 한 쌍의 호스트들 사이에서 동작하도록 설계된 "원격 로그인"을 위한 애플리케이션 계층 프로토콜이다. 이는 대화형 애플리케이션이다. 텔넷은 암호화를 하지 않기 때문에 도청 공격에 취약하다. 그래서 패스워드를 포함한 통신에서는 SSH가 선호된다.

사용자가 텔넷을 사용하는 대화형 애플리케이션에 문자 'C'를 입력한다고 하고, 클라이언트와 서버의 초기 순서 번호가 각각 33과 77 이라고 하자. 클라이언트에서 송신된 첫 번째 세그먼트는 순서 번호 33을 가질 것이다. 서버로부터 송신된 첫 번째 세그먼트는 77을 가질 것이다. 확인응답 번호는 호스트가 기다리는 데이터의 다음 바이트의 순서 번호라는 것을 상기하자. TCP 연결이 설정된 후 아무 데이터도 송신되기 전이라면 클라이언트는 77번 바이트를 기다리고 있고, 서버는 33번을 기다리고 있다.

이 가정하에 동작하는 텔넷 애플리케이션에서 해당 요청-응답 흐름은 3개의 세그먼트를 송신하는 것이 된다. 첫 번째 세그먼트는 클라이언트에서 서버로 송신된다. 그 세그먼트는 데이터 필드 안에 문자 'C'의 1바이트 ASCII 표현을 포함한다. 이 첫 번째 세그먼트는 앞서 설명했던 것처럼 순서 번호 필드에 33을 갖는다. 그리고 클라이언트가 아직 서버로부터 어떤 데이터도 수신하지 못했으므로, 확인응답 번호 필드에 77을 가질 것이다.

두 번째 세그먼트는 서버에서 클라이언트로 송신되는데, 다음과 같은 두가지 목적을 갖는다.
1. 수신하는 서버에게 데이터에 대한 확인응답을 제공한다.
2. 확인응답 필드 안에 34을 넣음으로써, 서버는 클라이언트에게 바이트 33을 성공적으로 수신했고 앞으로 34번 바이트를 기다린다는 것을 알린다.
    - 이 세그먼트의 두 번째 목적은 문자 'C'를 반대로 반향되도록 하는 것이다. 따라서 두 번째 세그먼트는 그것의 데이터 필드에 'C'의 ASCII 표현을 한다. 
    - 이 두 번째 세그먼트는 TCP 연결의 서버-클라이언트 데이터 흐름의 최초 순서 번호인 순서 번호 77을 갖는다.
    - 클라이언트/서버 데이터에 대한 확인응답은 **서버와 클라이언트 간에서 데이터를 운반하는 세그먼트 안에서 전달된다**는 것에 주의하자.
      - 이런 확인응답은 서버-클라이언트 데이터 세그먼트 상에서 **피기백**(piggybacked)된다고 말한다.
3. 세 번째 세그먼트는 클라이언트에서 서버로 송신되는데, 그 목적은 서버로부터 수신한 데이터에 대한 확인응답을 하는것이다.
   - 이 세그먼트는 두 번째 세그먼트와 다르게 빈 데이터 필드를 갖는다(두 번째 세그먼트는 수신한 데이터 필드의 'C'를 반향했다).
     - 즉, 이 확인응답은 어떤 클라이언트-서버와 데이타와 함께 피기백되지 않는다. 
   - 세그먼트의 확인응답 번호 필드 안에 78을 갖는다.
     - 클라이언트가 순서 번호 77의 바이트를 통해 바이트의 스트림을 수신했기 때문이다.
     - 이제 78로 시작하는 바이트를 기다린다.

### 2.3 왕복 시간(RTT) 예측과 타임아웃

rdt 프로토콜처럼 TCP가 손실 세그먼트를 발견하기 위해 사용하는 타임아웃/재전송 메커니즘에 대해 알아보자.

TCP같은 실질적인 프로토콜에서 타임아웃/재전송 메커니즘을 구현할 때는 애매한 부분들이 많다. 그런 애매한 부분들 중 대부분은 아마 타임아웃 주기와 관련이 될 것이다. 분명 타임아웃은 RTT보다는 커야 한다. 만약 그렇지 않으면 불필요하게 재전송이 발생할 것이다. 그렇다면 얼만큼 크게 해야 할까? RTT는 처음에 어떻게 측정할까? 타이머는 승인되지 않은 모든 세그먼트와 연결되어야 할까? 

이번 장은 [Jacobson 1988]과 현재 TCP 타이머 관리[RFC 6298]에 대한 IETF의 권고를 기본으로 하여 TCP 작동을 설명하겠다.

#### 왕복 시간 예측

TCP가 송신자와 수신자 사이에 왕복 시간을 어떻게 예측하는지 생각해보자. `SampleRTT`라고 표시되는 세그먼트에 대한 RTT 샘플은 세그먼트가 송신된 시간(즉, IP에게 넘겨진 시간)으로부터 그 세그먼트에 대한 긍정응답이 도착한 시간까지의 시간 길이다. 대부분의 TCP는 모든 전송된 세그먼트에 대한 `SampleRTT`를 측정하는게 아니라, 한 번에 하나의 `SampleRTT` 측정만을 시행한다. 즉, 어떤 시점에서 `SampleRTT`는 전송되었지만 현재까지 확인응답이 없는 세그먼트 중 하나에 대해서만 측정되며 이런 전략을 통해 TCP는 대략 왕복 시간마다 `SampleRTT`의 새로운 값을 얻게 한다. 그리고 TCP는 재전송한 세그먼트에 대한 `SampleRTT`는 계산하지 않으며, 한 번 전송된 세그먼트에 대해서만 측정한다.

`SampleRTT`값은 라우터에서의 혼잡과 종단 시스템에서의 부하의 변화 때문에 세그먼트마다 다르다. 대체로 RTT값을 추정하기 위해 `SampleRTT`값의 평균값을 채택한다. TCP는 `SampleRTT`값의 평균(`EstimatedRTT`라고 부름)을 유지한다. 긍정 확인응답을 수신하고 새로운 `SampleRTT`를 획득하자마자 TCP는 다음 공식에 따라 `EstimatedRTT`를 갱신한다.

$EstimatedRTT\ =\ (1 - \alpha)\ \cdot\ EstimatedRTT\ + \alpha \cdot\ SampleRTT$

위 공식에서 권장되는 $\alpha$값은 `0.125`(즉, 1/8)이다.

EstimatedRTT는 SampleRTT 값의 가중평균(weighted average)임을 유념하자. 이 가중평균은 예전 샘플보다 최근 샘플에 더 높은 가치를 준다. 최신 샘플들이 네트워크 상의 '현재의 혼잡'을 더 잘 반영한다. 통계에서 이런 평균은 **지수적 가중 이동 평균**이라고 부른다. 

RTT를 예측하는 것 말고도 RTT의 변화율을 측정하는 것 또한 매우 중요하다. 이를 `DevRTT`라고 부르며, 이는 `SampleRTT`가 `EstimatedRTT`로부터 얼마나 많이 벗어나는지에 대한 예측으로 정의한다.

#### 재전송 타임아웃 주기의 설정과 관리

`EstimatedRTT`보다는 크거나 같아야 하며, 또 `EstimatedRTT`보다 너무 커서도 안되(세그먼트를 잃었을 때, 세그먼트의 즉각적인 재전송을 하지 않게 됨)는 타임아웃 주기는 `EstimatedRTT`에 약간의 여윳값을 더한 값으로 설정하는 것이 바람직하다. 