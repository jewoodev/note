사람은 여러 가지 식별자로 자신을 식별할 수 있다. 예를 들어, 이름, 주민등록번호 등으로 식별할 수 있다. 이런 식볋자는 환경에 따라 더 적합하고 적합하지 않아지곤 한다. 국세청 컴퓨터에서는 이름보단 주민등록번호가 더 적합하고, 일반적인 사람들 사이에서는 주민등록번호보다 이름으로 서로를 식별하는게 더 적절하다. 

사람을 여러 가지 식별자로 식별할 수 있듯이, 인터넷 호스트도 그러하다. 호스트의 식별자 중 하나는 **호스트 이름**(hostname)이다. 호스트 이름은 사람이 기억하기 쉽기 때문에 사람에게 사용되기에 적합하다. 그러나 호스트 이름은 언테넷에서의 그 호스트 위치에 대한 정보를 거의 제공하지 않는다. 더 나아가서, 호스트 이름은 가변 길이의 알파뉴메릭 문자로 구성되므로 라우터가 처리하는 데 어려움이 있다. 이러한 이유로 호스트는 흔히 말하는 IP(IP address)로도 식별된다.

IP 주소는 4바이트로 구성되고 계층구조를 갖는다. IP 주소는 121.7.106.83과 같은 형태이고, 0~255의 십진수로 표현하는 각 바이트는 점으로 구분한다. IP 주소는 계층구조여서 주소를 왼쪽에서 오른쪽으로 조사함으로써, 그 호스트가 인터넷의 어디에 위치하는지(네트워크로 연결된 네트워크에서 어느 네트워크 내에 있는지)에 대한 자세한 정보를 얻을 수 있다. 

## 1. DNS가 제공하는 서비스

라우터가 선호하는 식별자와 사람이 선호하는 식별자가 다르기 때문에 호스트 이름을 IP 주소로 변환해주는 디렉터리 서비스가 필요한데, 이게 바로 DNS(Domain name system)의 주요 임무이다. 

1. DNS는 DNS 서버들의 계층구조로 구현된 분산 데이터베이스이고
2. 호스트는 분산 데이터베이스로 질의하도록 허락하는 애플리케이션 계층 프로토콜이다.

DNS 서버는 주로 BIND(Berkeley Internet Name Domain) 소프트웨어를 수행하는 유닉스 컴퓨터다[BIND 2020]. DNS 프로토콜은 UDP상에서 수행되고 포트 번호 53을 사용한다.

## 2. DNS 동작 원리 개요

DNS는 분산되도록 설계된 시스템이다. 단일 DNS 서버에서 중앙 집중 데이터베이스로 모든 인터넷 호스트에 대한 레코드를 유지하는 방식은 확장성이 전혀 없다. DNS는 분산 데이터베이스가 인터넷에서 어떻게 구현될 수 있는지를 보여주는 훌륭한 사례인데 이를 살펴보자.

### 2.1 분산 계층 데이터베이스

확장성 문제를 다루기 위해 DNS는 많은 서버를 이용하며 이들을 계층 형태로 구성해 전 세계에 분산시킨다. 어떤 단일 DNS 서버도 인터넷에 있는 모든 호스트에 대한 매핑을 갖지 않는 대신에 DNS 서버 사이에 분산된다. 대체로 세 유형의 DNS 서버가 있다. 루트(root) DNS 서버, 최상위 레벨 도메인 네임(top-level domain, TLD) DNS 서버, 책임(authoritative) DNS 서버다. 

어떤 DNS 클라이언트가 호스트 이름 www.amazon.com 의 IP 주소를 원한다고 가정하자. 먼저 이 클라이언트는 루트 서버 중 하나에 접속한다. 루트 서버는 최상위 레벨 도메인 com을 갖는 TLD 서버 IP 주소를 보낸다. 클라이언트는 받은 TDL 서버 중 하나에 접속하고, 서버는 도메인 amazon.com을 가진 책임 서버의 IP 주소를 보낸다. 클라이언트는 amazon.com 책임 서버 중 하나로 접속한다. 서버는 호스트 이름 www.amazon.com 의 ip 주소를 보낸다. 

- **루트 DNS 서버**: 1000개 이상의 루트 서버 인스턴스가 전 세계에 흩어져 있다. 루트 서버들은 13개의 다른 루트 서버 복사체이고, 12개의 다른 기관에서 관리되며, 인터넷 할당 번호 관리기관[IANA 2020]에 의해 조정된다. 루트 네임 서버들과 이를 관리하는 기관과 그들의 IP 주소 목록은 [Root Servers 2020]에서 볼 수 있다. 루트 네임 서버는 TLD 서버의 IP 주소들을 제공한다.
- **최상위 레벨 도메인(TLD) 서버**: com, org, net, edu, gov 같은 상위 레벨 도메인과 kr, uk, fr, ca, jp 같은 모든 국가의 상위 레벨 도메인에 대한 TLD 서버(또는 서버 클러스터)가 있다. 베리사인 글로벌 레지스트리 서비스사(Verisign Global Registry Service)는 com TLD에 대한 TLD 서버를 담당하고 있으며, 에듀코즈사(Educause)는 edu TLD에 대한 TLD 서버를 담당하고 있다. TLD를 지원하는 네트워크 인프라는 크고 복잡하다. TLD 서버는 권한 DNS 서버에 대한 IP 주소를 제공한다.
- **권한 DNS 서버**: 호스트(예: 웹 서버와 메일 서버)를 가진 모든 기관은 호스트 이름을 IP 주소로 매핑하는 공개적인 DNS 레코드를 제공해야 한다. 기관의 권한 DNS 서버는 이 DNS 레코드를 갖고 있다. 그리고 이 레코드를 갖도록 자신의 권한 DNS 서버의 구현을 선택할 수 있고, 일부 서비스 제공자의 권한 DNS 서버에 이 레코드를 저장하도록 비용을 지불한다. 대부분의 대학과 큰 기업들은 자신의 기본 권한 DNS 서버와 보조 책임 DNS 서버를 유지하고 구현한다.

DNS의 또 다른 중요한 형태는 로컬 DNS 서버다. 로컬 DNS 서버는 서버들의 계층 구조에 엄격하게 속하진 않지만, DNS 구조의 중심에 있다. (대학이나 주거지역 ISP 같은) ISP들은 로컬 DNS 서버(또는 디폴트 네임 서버)를 갖는다. 호스트가 ISP에 연결될 때, 그 ISP는 로컬 DNS 서버로부터 IP 주소를 호스트에게 제공한다(일반적으로 DHCP를 통해). 호스트의 로컬 DNS 서버는 호스트와 같은 LAN 상에 있을 수 있다. 주거지역 ISP는 전형적으로 몇 개의 라우터 범위 안에서 호스트로부터 떨어져 있다. 호스트가 DNS 질의를 보내면, 이 질의는 먼저 프록시로 동작하는 로컬 DNS 서버에게 전달되고, 그 로컬 DNS 서버는 이 질의를 DNS 서버 계층으로 전달한다. 

이론상으로 DNS 질의는 반복적이고 재귀적일 수 있다. 일반적으로는 요청하는 호스트로부터 로컬 DNS 서버까지의 질의는 재귀적이고, 나머지는 반복적이다. 재귀적인 질의만 일어나는 구조는 로컬 DNS 서버가 각 DNS 서버로 반복적인 질의를 하지 않고 로컬 -> 루트 -> TLD -> 권한 순으로 질의가 흘러갔다가 응답이 차례로 돌아오는 구조다.

### 2.2 DNS 캐싱

실제 DNS는 지연 성능 향상과 네트워크의 DNS 메세지 수를 줄이기 위해 캐싱을 사용한다. DNS가 사용하는 캐싱 전략은 간단하다. 질의 사슬에서 DNS 서버가 DNS 응답을 받았을 때(예: 호스트 이름을 IP 주소로 매핑하기) 그것은 로컬 메모리에 응답에 대한 정보를 저장할 수 있다. 예를들어, 로컬 DNS 서버는 임의의 DNS 서버로부터 응답을 받을 때마다 응답에 포함된 정보를 저장할 수 있다. 만약 호스트 이름과 IP 주소 쌍이 DNS 서버에 저장되고 나서 같은 질의가 DNS 서버에 요청된다면, DNS 서버는 호스트 이름에 대한 책임이 없을 때조차 원하는 IP 주소를 제공할 수 있다. 호스트 이름과 IP 주소 사이의 매핑 관계는 영구적이지 않기 때문에 DNS 서버는 어떤 기간(흔히 2일로 설정) 이후에 저장된 정보를 제거한다. 

### 2.3 DNS 레코드와 메세지

DNS 분산 데이터베이스를 구현한 DNS 서버들은 호스트 이름을 IP 주소로 변환하기 위해 자원 레코드(resource record, RR)를 저장한다. 각 DNS는 하나 이상의 자원 레코드를 가진 메세지로 응답한다. 

자원 레코드는 다음과 같은 필드를 포함하는 4개의 튜플(tuple)로 되어 있다.

```
(Name, Value, Type, TTL)
```

TTL은 자원 레코드의 생존기간(time to live)이다(자원이 캐시에서 제거되는 시간을 결정). Name과 Value의 의미는 Type에 따라 달라진다.

- Type=A이면, Name은 호스트 이름이고 Value는 호스트 이름에 대한 IP 주소다. 따라서 Type A 레코드는 표준 호스트 이름의 IP 주소 매핑을 제공한다. 예시로 (relay1.bar.foo.com, 145.37.93.126, A)는 Type A 레코드다.
- Type=NS이면, Name은 도메인이고 Value는 도메인 내부의 호스트에 대한 IP 주소를 얻을 수 있는 방법을 하는 권한 DNS 서버의 호스트 이름이다. 예시로 (foo.com, dns.foo.com, NS)는 Type NS 레코드다.
- Type=CNAME이면, Value는 별칭 호스트 이름 Name에 대한 정식 호스트 이름이다. 이 레코드는 질의 호스트에게 호스트 이름에 대한 정식 이름을 제공한다. 예시로 (foo.com, relay1.bar.foo.com, CNAME)은 CNAME 레코드다.
- Type=MX이면, Value는 별칭 호스트 이름 Name을 갖는 메일 서버의 정식 이름이다. 예를 들어, (foo.com, mail.bar.foo.com, MX)는 MX 레코드다. MX 레코드는 메일 서버의 호스트 이름이 간단한 별칭을 갖는 걸 허용한다. 어떤 회사는 한 메일 서버와 다른 서버들(웹 서버 같은 것)이 같은 별칭을 가질 수 있다. 메일 서버의 정식 이름을 얻기 위해 DNS 클라이언트는 MX 레코드에 대한 질의를 한다. 다른 서버의 정식 이름을 얻기 위해 DNS 클라이언트는 CNAME 레코드에 대한 질의를 한다.
