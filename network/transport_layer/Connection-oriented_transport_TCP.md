TCP는 신뢰적인 데이터 전송을 제공하기 위해 '오류 검출', '재전송', '누적 확인응답', '타이머', '순서 번호'와 '확인응답 번호를 위한 헤더 필드'에 관한 원칙들을 따르고 있다. TCP는 RFC 793, RFC 1122, RFC 2018, RFC 5681, RFC 7323에 정의되어 있다.

## 1. TCP 연결

TCP는 애플리케이션 프로세스가 데이터를 다른 프로세스로 보내기 전에 두 프로세스가 서로 '핸드셰이크'를 먼저 해야 하는 **연결지향형** 프로토콜이다. 즉, 데이터 전송을 보장하는 파라미터들을 각자 설정하기 위한 사전 세그먼트들을 보내야 한다. TCP 연결 설정 과정에서 연결 대상인 종단들은 TCP 연결과 관련된 많은 변수들을 초기화한다.

TCP '연결'은 회선 교환 네트워크같은 환경 종단 간의 TDM이나 FDM이 아니다. 두 통신 종단 시스템의 TCP에 존재하는 상태를 공유하는 논리적인 것이다. TCP 프로토콜은 종단 시스템에서만 동작하고 다른 네트워크 요소에서는 동작하지 않아서 TCP 연결 상태를 유지하지 않는다. 아니, 연결을 아예 전혀 감지하지 못한다. 그저 데이터그램만 본다.

TCP 연결은 **전이중 서비스**(full-duplex service)를 제공한다. 그리고 항상 단일 송신자와 단일 수신자 사이의 점대점(point-to-point)이다. 한 번의 송신 동작으로 한 송신자가 여러 수신자에게 데이터를 전송하는 '멀티캐스팅'은 불가능하다.

TCP 연결은 클라이언트 애플리케이션 프로세스가 TCP 클라이언트에게 서버의 프로세스와 연결을 원한다고 알리는 것으로 설정되기 시작한다. 그러면 클라이언트의 트랜스포트 계층은 서버의 TCP와의 TCP 연결 설정을 진행한다. 이때, 클라이언트가 특별한 TCP 세그먼트를 보낸다. 그러면 서버는 두 번째 특별한 TCP 세그먼트로 응답한다. 마지막으로, 클라이언트가 세 번째 특별한 세그먼트로 다시 응답한다. 처음 2개의 세그먼트에는 페이로드, 즉 애플리케이션 계층 데이터가 없다. 그리고 세 번째 세그먼트는 페이로드를 포함할 수 있다. 이 세 번을 거쳐 설정되는 절차를 세 방향 핸드셰이크(three-way handshake)라 부른다.

TCP 연결을 통해 송신된 데이터가 관문을 통해 전달되면, 클라이언트에서 동작하고 있는 TCP에게 맡겨진다. TCP는 초기 세 방향 핸드셰이크 동안 준비된 버퍼 중 하나인 연결의 **송신 버퍼**(send buffer)로 데이터를 보낸다. TCP는 송신 버퍼의 데이터를 하나씩 보내는게 아닌 묶음으로 보낼 수 있다. [RFC 793]에서 TCP는 '자신이 편한 대로 세그먼트의 데이터를 전송'해야 한다고 기술되어 있으며 정해져 있는 전송 시점에 대해서는 기술하고 있지 않다. 세그먼트로 모아 담을 수 있는 최대 데이터 양은 **최대 세그먼트 크기**(maximum segment size, MSS)로 제한된다. MSS는 일반적으로 해당 호스트에서 전송될 수 있는 가장 큰 링크 계층 프레임의 길이(최대 전송 단위(maximum transmission unit, MTU))에 의해 1차적으로 결정되고, TCP 세그먼트(IP 데이터그램 안에 캡슐화되었을 때)와 TCP/IP 헤더 길이(통상 40바이트)가 단일 링크 계층 프레임에 맞도록 해서 정해진다. 따라서 MSS의 일반적인 값은 1460 바이트이다. MSS가 헤더를 포함하는 TCP 세그먼트의 최대 크기가 아니라, 세그먼트에 있는 애플리케이션 계층 데이터에 대한 최대 크기라는 것에 유의하자.

TCP는 TCP 헤더와 클라이언트 데이터를 하나로 짝지어 TCP 세그먼트를 구성한다. TCP가 상대에게서 세그먼트를 수신했을 때 세그먼트의 데이터는 TCP 연결의 수신 버퍼에 위치하게 된다. 그럼 애플리케이션은 이 버퍼로부터 데이터의 스트림을 읽는다. 연결의 양 끝은 각각 자신의 송신 버퍼와 수신 버퍼를 갖고 있다. 

이번에 살펴본 내용들로 하여금 TCP 연결은 한 쪽 호스트에서의 버퍼, 변수, 프로세스에 대한 소켓 연결과 다른 쪽 호스트에서의 버퍼, 변수 프로세스에 대한 소켓 연결의 집합으로 이루어진다는 걸 알 수 있다. 앞에서 언급한 대로, 버퍼와 변수는 종단 간을 잇는 경로의 네트워크 요소(라우터, 스위치, 리피터)의 연결에는 할당되지 않는다.

## 2. TCP 세그먼트 구조

TCP 세그먼트는 '헤더 필드'와 '데이터 필드'로 구성되어 있다. 데이터 필드는 애플리케이션 데이터의 일정량을 담는다. MSS는 세그먼트의 데이터 필드의 크기를 제한한다. TCP가 웹 문서의 이미지와 같은 큰 파일을 전송할 때, 일반적으로 MSS 크기로 파일을 분절한다. 하지만 대화식 애플리케이션들은 통상적으로 MSS 크기 보다 작은 데이터를 전송한다. 예를 들어 텔넷과 ssh 같은 원격 로그인에서는 TCP 세그먼트의 데이터 필드는 1바이트 밖에 안된다. TCP 헤더는 일반적으로 20바이트(UDP 헤더보다 12바이트 크다)이므로, 텔넷과 ssh에 의해 전송되는 세그먼트는 21 바이트 길이가 된다.

TCP 헤더는 UDP처럼 상위 계층 애플리케이션으로부터 다중화와 역다중화를 하는데 필요한 출발지와 목적지 포트번호를 포함한다. 그리고 UDP처럼 체크섬 필드도 포함한다. 또, 다음과 같은 필드를 포함한다.

- 32 비트 **순서 번호 필드**(sequence number field)와 32비트 **확인응답 번호 필드**(acknowledgement number field)는 신뢰적인 데이터 전송 구현에서 TCP 송신자와 수신자에 의해 사용된다.
- 16비트 **수신 윈도**(receive window) 필드는 흐름 제어에 사용된다. 이건 수신자가 받아들이려는 바이트 크기를 나타낸다.
- 4비트 **헤더 길이 필드**는 32비트 워드 단위로 TCP 헤더 길이를 나타낸다. TCP 헤더는 이전에 논의한 TCP 옵션 필드 때문에 가변적인 길이가 될 수 있다(일반적으로는 TCP 길이가 20바이트가 되도록 옵션 필드가 비어 있다.).
- 선택적이고 가변적인 길이의 **옵션 필드**는 송신자와 수신자가 최대 세그먼트 크기(MSS)를 협상하거나 고속 네트워크에서 사용하기 위한 윈도 확장 요소로 사용된다. 타임스탬프 옵션 또한 정의된다. 
- **플래그 필드**는 6비트를 포함한다. **ACK 비트**는 확인응답 필드에 있는 값이 유용한지를 나타나는데 쓰인다. **RST, SYN, FIN** 비트는 연결 설정과 해제에 사용된다. **PSH** 비트가 설정될 때, 이건 수신자가 데이터를 상위 계층에 즉시 전달해야 한다는 것을 가리킨다. 마지막으로, **URG** 비트는 이 세그먼트에서 송신 측 상위 계층 개체가 '긴급'으로 표시하는 데이터임을 가리킨다. 이 긴급 데이터의 마지막 바이트 위치는 16비트의 긴급 데이터 포인터 필드에 의해 가리켜진다. TCP는 긴급 데이터가 존재할 때 수신 측 상위 계층 개체에게 통지해야 하고 긴급 데이터의 끝에 대한 포인터를 전달한다(PSH, URG 그리고 긴급 데이터에 대한 포인터는 실제론 쓰이지 않지만 완벽하게 하기위해 이러한 필드를 전달한다).

### 2.1 순서 번호와 확인응답 번호

TCP 세그먼트 헤더에서 가장 중요한 필드 두 개는 순서 번호 필드와 확인응답 번호 필드다. 이 필드들은 TCP가 신뢰적인 전송을 가능하게 하는데에 중요한 역할을 한다. 

TCP는 데이터를 구조화되어 있지 않고 순서대로 정렬되어 있는 바이트 스트림으로 본다. 그래서 TCP의 순서 번호도 수신된 세그먼트에 대한 것이 아닌, 전송된 바이트 스트림에 대한 것이다. **세그먼트에 대한 순서 번호**는 세그먼트에 있는 첫 번째 바이트의 바이트 스트림 번호이다. 

확인응답 번호가 무엇인지 살펴보자. 호스트 A, B가 서로 데이터를 교환하는 경우에서, 호스트 A가 자신의 세그먼트에 삽입하는 확인응답 번호는 호스트 A가 호스트 B로부터 기대하는 다음 바이트의 순서 번호다. 만약 A가 B로부터 0부터 300까지의 번호들이 붙은 바이트를 수신했다면, A는 B의 데이터 스트림에서 301번째 바이트와 그 다음 순서의 바이트를 기다리고 있다. 이때 A가 B에게 세그먼트를 송신한다면 A는 그 세그먼트의 확인응답 번호 필드에 301을 삽입한다.

다른 예로 '0~300의 바이트를 포함한 세그먼트'와 '601~900의 바이트를 포함한 세그먼트'를 수신했다고 해보자. 그럼 어떤 이유인지 모르겠지만 301~600 번째 바이트는 수신하지 못한 것이다. 따라서 A는 B의 데이터 스트림을 재생성하기 위해 '301번째와 그 다음의 바이트'를 기다리고 있게 된다. 그렇기 때문에 B에 대한 A의 다음 세그먼트에는 확인응답 번호 필드에 301이 들어가 있을 것이다. TCP는 스트림에서 첫 번째 잃어버린 바이트까지의 바이트들까지만 확인응답하기 때문에, **누적 확인응답**(cumulative acknowledgement)을 제공한다고 한다.

### 2.2 텔넷: 순서 번호와 응답확인 번호 사례연구

텔넷은 TCP 상에서 실행되며 한 쌍의 호스트들 사이에서 동작하도록 설계된 "원격 로그인"을 위한 애플리케이션 계층 프로토콜이다. 이는 대화형 애플리케이션이다. 텔넷은 암호화를 하지 않기 때문에 도청 공격에 취약하다. 그래서 패스워드를 포함한 통신에서는 SSH가 선호된다.

사용자가 텔넷을 사용하는 대화형 애플리케이션에 문자 'C'를 입력한다고 하고, 클라이언트와 서버의 초기 순서 번호가 각각 33과 77 이라고 하자. 클라이언트에서 송신된 첫 번째 세그먼트는 순서 번호 33을 가질 것이다. 서버로부터 송신된 첫 번째 세그먼트는 77을 가질 것이다. 확인응답 번호는 호스트가 기다리는 데이터의 다음 바이트의 순서 번호라는 것을 상기하자. TCP 연결이 설정된 후 아무 데이터도 송신되기 전이라면 클라이언트는 77번 바이트를 기다리고 있고, 서버는 33번을 기다리고 있다.

이 가정하에 동작하는 텔넷 애플리케이션에서 해당 요청-응답 흐름은 3개의 세그먼트를 송신하는 것이 된다. 첫 번째 세그먼트는 클라이언트에서 서버로 송신된다. 그 세그먼트는 데이터 필드 안에 문자 'C'의 1바이트 ASCII 표현을 포함한다. 이 첫 번째 세그먼트는 앞서 설명했던 것처럼 순서 번호 필드에 33을 갖는다. 그리고 클라이언트가 아직 서버로부터 어떤 데이터도 수신하지 못했으므로, 확인응답 번호 필드에 77을 가질 것이다.

두 번째 세그먼트는 서버에서 클라이언트로 송신되는데, 다음과 같은 두가지 목적을 갖는다.
1. 수신하는 서버에게 데이터에 대한 확인응답을 제공한다.
2. 확인응답 필드 안에 34을 넣음으로써, 서버는 클라이언트에게 바이트 33을 성공적으로 수신했고 앞으로 34번 바이트를 기다린다는 것을 알린다.
    - 이 세그먼트의 두 번째 목적은 문자 'C'를 반대로 반향되도록 하는 것이다. 따라서 두 번째 세그먼트는 그것의 데이터 필드에 'C'의 ASCII 표현을 한다. 
    - 이 두 번째 세그먼트는 TCP 연결의 서버-클라이언트 데이터 흐름의 최초 순서 번호인 순서 번호 77을 갖는다.
    - 클라이언트/서버 데이터에 대한 확인응답은 **서버와 클라이언트 간에서 데이터를 운반하는 세그먼트 안에서 전달된다**는 것에 주의하자.
      - 이런 확인응답은 서버-클라이언트 데이터 세그먼트 상에서 **피기백**(piggybacked)된다고 말한다.
3. 세 번째 세그먼트는 클라이언트에서 서버로 송신되는데, 그 목적은 서버로부터 수신한 데이터에 대한 확인응답을 하는것이다.
   - 이 세그먼트는 두 번째 세그먼트와 다르게 빈 데이터 필드를 갖는다(두 번째 세그먼트는 수신한 데이터 필드의 'C'를 반향했다).
     - 즉, 이 확인응답은 어떤 클라이언트-서버와 데이타와 함께 피기백되지 않는다. 
   - 세그먼트의 확인응답 번호 필드 안에 78을 갖는다.
     - 클라이언트가 순서 번호 77의 바이트를 통해 바이트의 스트림을 수신했기 때문이다.
     - 이제 78로 시작하는 바이트를 기다린다.

### 2.3 왕복 시간(RTT) 예측과 타임아웃

rdt 프로토콜처럼 TCP가 손실 세그먼트를 발견하기 위해 사용하는 타임아웃/재전송 메커니즘에 대해 알아보자.

TCP같은 실질적인 프로토콜에서 타임아웃/재전송 메커니즘을 구현할 때는 애매한 부분들이 많다. 그런 애매한 부분들 중 대부분은 아마 타임아웃 주기와 관련이 될 것이다. 분명 타임아웃은 RTT보다는 커야 한다. 만약 그렇지 않으면 불필요하게 재전송이 발생할 것이다. 그렇다면 얼만큼 크게 해야 할까? RTT는 처음에 어떻게 측정할까? 타이머는 승인되지 않은 모든 세그먼트와 연결되어야 할까? 

이번 장은 [Jacobson 1988]과 현재 TCP 타이머 관리[RFC 6298]에 대한 IETF의 권고를 기본으로 하여 TCP 작동을 설명하겠다.

#### 왕복 시간 예측

TCP가 송신자와 수신자 사이에 왕복 시간을 어떻게 예측하는지 생각해보자. `SampleRTT`라고 표시되는 세그먼트에 대한 RTT 샘플은 세그먼트가 송신된 시간(즉, IP에게 넘겨진 시간)으로부터 그 세그먼트에 대한 긍정응답이 도착한 시간까지의 시간 길이다. 대부분의 TCP는 모든 전송된 세그먼트에 대한 `SampleRTT`를 측정하는게 아니라, 한 번에 하나의 `SampleRTT` 측정만을 시행한다. 즉, 어떤 시점에서 `SampleRTT`는 전송되었지만 현재까지 확인응답이 없는 세그먼트 중 하나에 대해서만 측정되며 이런 전략을 통해 TCP는 대략 왕복 시간마다 `SampleRTT`의 새로운 값을 얻게 한다. 그리고 TCP는 재전송한 세그먼트에 대한 `SampleRTT`는 계산하지 않으며, 한 번 전송된 세그먼트에 대해서만 측정한다.

`SampleRTT`값은 라우터에서의 혼잡과 종단 시스템에서의 부하의 변화 때문에 세그먼트마다 다르다. 대체로 RTT값을 추정하기 위해 `SampleRTT`값의 평균값을 채택한다. TCP는 `SampleRTT`값의 평균(`EstimatedRTT`라고 부름)을 유지한다. 긍정 확인응답을 수신하고 새로운 `SampleRTT`를 획득하자마자 TCP는 다음 공식에 따라 `EstimatedRTT`를 갱신한다.

$EstimatedRTT\ =\ (1 - \alpha)\ \cdot\ EstimatedRTT\ + \alpha \cdot\ SampleRTT$

위 공식에서 권장되는 $\alpha$값은 `0.125`(즉, 1/8)이다.

EstimatedRTT는 SampleRTT 값의 가중평균(weighted average)임을 유념하자. 이 가중평균은 예전 샘플보다 최근 샘플에 더 높은 가치를 준다. 최신 샘플들이 네트워크 상의 '현재의 혼잡'을 더 잘 반영한다. 통계에서 이런 평균은 **지수적 가중 이동 평균**이라고 부른다. 

RTT를 예측하는 것 말고도 RTT의 변화율을 측정하는 것 또한 매우 중요하다. 이를 `DevRTT`라고 부르며, 이는 `SampleRTT`가 `EstimatedRTT`로부터 얼마나 많이 벗어나는지에 대한 예측으로 정의한다.

#### 재전송 타임아웃 주기의 설정과 관리
`EstimatedRTT`보다는 크거나 같아야 하며, 또 `EstimatedRTT`보다 너무 커서도 안되(세그먼트를 잃었을 때, 세그먼트의 즉각적인 재전송을 하지 않게 됨)는 타임아웃 주기는 `EstimatedRTT`에 약간의 여윳값을 더한 값으로 설정하는 것이 바람직하다. `SampleRTT` 값에 많은 변동이 있을 땐 여윳값이 커야 하고, 변동이 작을 때는 작아야 한다. 따라서 `DevRTT` 값이 중요한 역할을 한다. 이런 모든 고려사항은 재전송 타임아웃 주기를 결정하는 TCP 방식에서 사용된다.

$TimeoutInterval\ =\ EstimatedRTT\ +\ 4\ \cdot\ DevRTT$

초기 `TimeoutInterval`의 값은 1초가 권장된다[RFC 6298]. 또한 타임아웃이 발생할 때, `TimeoutInterval`의 값은 두 배로 해서 조만간 확인응답할 후속 세그먼트에게 발생할 수 있는 조기 타임아웃을 피하도록 한다. 그러나 세그먼트가 수신되고 `EstimatedRTT`가 수정되면 `TimeouInterval`은 다시 위의 공식에 따라 계산된다.

### 2.4 신뢰적인 데이터 전송
인터넷의 네트워크 계층(IP 서비스)은 비신뢰적이다. 인터넷 프로토콜은 데이터그램 전달을 보장하지 않고, 데이터그램이 순서대로 전달된다고 보장하지 않는다. 그리고 데이터그램에 포함된 데이터의 무결성(integrity)을 보장하지 않는다. IP 서비스에서 데이터그램은 라우터의 버퍼를 오버플로 상태로 만들 수도 있으며, 목적지에 도달하지 않을 수도 있고, 데이터그램의 순서가 틀리게 도달할 수도 있다. 또 데이터그램의 비트가 손상될 수도 있다(0에서 1로 바뀌거나 1에서 0으로 바뀜). 트랜스포트 계층의 세그먼트가 IP 데이터그램에 의해 네트워크 상에서 운반되므로, 트랜스포트 계층의 세그먼트도 이런 문제를 겪을 수 있다.

TCP는 IP의 비신뢰적인 최선형 서비스에서 **신뢰적인 데이터 전송 서비스**(reliable data transfer service)를 제공한다. TCP의 신뢰적인 데이터 전송 서비스는 프로세스가 자신의 수신 버퍼로부터 읽은 데이터 스트림이 손상되지 않았으며 손실이나 중복이 없단 것과 순서가 유지된다는 걸 보장한다.

신뢰적인 데이터 전송에 대한 앞에서의 전개 과정에서, 전송되었지만 아직 확인응답을 받지 못한 각각의 세그먼트와 개별적인 타이머가 한 쌍이 되어 동작한다고 가정하는 것이 개념상 가장 쉬웠다. 이것이 이론상으로는 훌륭할지 몰라도, 타이머 관리는 상당한 오버헤드를 요구할 수도 있다. 따라서 전송되었지만 확인응답이 안 된 다수의 세그먼트들이 있다 하더라도, 권장되는 TCP 타이머 관리 절차에선 오직 단일 재전송 타이머를 사용한다.

손실 세그먼트를 복구하기 위해 타임아웃을 사용하는 경우를 살펴보자. TCP 송신자는 데이터 전송/재전송에 관련된 세 가지 주요 이벤트를 갖는데, 상위 애플리케이션으로부터 수신된 데이터, 타이머 타임아웃, ACK 수신이다. 첫 번째 주요 이벤트 발생으로, TCP는 애플리케이션으로부터 데이터를 받고, 세그먼트로 이 데이터를 캡슐화하고, IP에게 이 세그먼트를 넘긴다. 이때 타이머가 이미 다른 세그먼트에 대해 실행 중인 상태가 아니라면, TCP는 이 세그먼트를 IP로 넘길 때 타이머를 시작한다. 이 타이머에 대한 만료 주기는 `TimeoutInterval`이다.

두 번째 주요 이벤트는 타임아웃이다. TCP는 타임아웃 이벤트에 대해 타움아웃을 일으킨 세그먼트를 재전송해 응답한다. 그리고 TCP의 타이머를 다시 시작한다.

TCP 송신자가 처리해야 하는 세 번째 주요 이벤트는 수신자로부터의 좀 더 구체적이고 다양한 ACK 필드값을 가진 수신 확인응답 세그먼트(ACK) 수신이다. 이 이벤트가 일어나면 TCP는 변수 `SendBase`와 ACK 값 y를 비교한다. TCP 상태 변수 `SendBase`는 수신 확인응답이 확인되지 않은 가장 오래된 바이트의 순서 번호다. 그러므로 `SendBase - 1`은 수신자에게서 정확하게 차례대로 수신되었음을 알리는 마지막 바이트의 순서 번호다. TCP는 누적 확인응답을 사용하고, y는 y바이트 이전의 모든 바이트의 수신을 확인한다. 만일 `y > SendBase`이면, ACK는 이전에 확인응답이 되지 않은 하나 이상의 세그먼트들을 확인해준다. 따라서 송신자는 자신의 `SendBase` 변수를 갱신한다. 또한 아직 확인응답이 되지 않은 세그먼트들이 존재한다면 타이머를 다시 시작한다.

#### 타임아웃 주기의 두 배로 설정
TCP 구현에서 고려되는 몇 가지 사항들에 대해 논의해보자. 첫 번째는 타이머의 종료 후 타임아웃 주기의 길이에 대한 것이다. 타임아웃이 발생할 때마다 TCP는 아직 확인응답이 되지 않은 가장 작은 순서번호를 가진 세그먼트를 재전송한다. 그러나 TCP는 재전송 때마다 마지막 `EstimatedRTT`와 `DevRTT`로부터 타임아웃값을 가져오는 게 아니라 타임아웃 주기를 이전 값의 두 배로 설정한다. 예를 들어, 타이머가 먼저 만료되었을 때 가장 이전의 확인응답이 안 된 세그먼트와 연관된 `TimeoutInterval`이 0.75라고 가정하자. TCP는 이 세그먼트를 재전송하고, 새로운 종료 소요 시간을 1.5초로 설정한다. 만약 타이머가 다시 1.5초가 지난 후에 만료되면, TCP는 다시 그 세그먼트를 재전송할 것이고 다음에는 종료 소요 시간을 3.0초로 한다. 따라서 이 주기는 각 재전송 후에 지수적으로 증가한다. 그러나 다른 두가지 이벤트(상위의 애플리케이션으로부터의 '데이터 수신'과 'ACK 수신') 이후 타이머가 시작될때 `TimeoutInterval`은 `EstimatedRTT`와 `DevRTT`의 가장 최근의 값에서 가져온다.

#### 빠른 재전송
타임아웃이 유발하는 재전송의 한 가지 문제는 타임아웃 주기가 때때로 비교적 길다는 점이다. 다행히 송신자는 종종 소위 중복 ACK에 의한 타임아웃이 일어나기 전에 패킷 손실을 발견한다. **중복 ACK**는 송신자가 이미 이전에 받은 확인응답에 대한 재확인응답 세그먼트 ACK다.

중복 ACK에 대한 송신자의 반응을 이해하기 위해, 먼저 수신자가 중복된 ACK를 보내는 이유를 알아야 한다. TCP 수신자는 자신이 기다리는 다음 것보다 더 큰 순서 번호를 가진 세그먼트를 받았을 때, 그 데이터 스트림에서의 간격(손실 세그먼트)를 찾아낼 것이다. 이 간격은 네트워크 안에서 세그먼트가 분실되거나 순서가 바뀐 결과일 수 았다. TCP는 부정 확인응답을 사용하지 않지만 수신자는 마지막으로 수신된 순차적인 바이트를 갖는 데이터를 그냥 다시 확인응답(즉, 중복 ACK를 생성)을 한다.

송신자는 많은 양의 세그먼트를 연속적으로 보낼 수 있기 때문에 하나의 세그먼트가 분실되었을 때 많은 연속적인 중복 ACK가 생성될 수 있다. 그런 여러 개의 중복 ACK가 수신되었을때, TCP는 세그먼트의 타이머가 만료되기 이전에 손실 세그먼트를 재전송하는 빠른 재전송을 한다.

### 2.5 흐름 제어
TCP 연결의 각 종단에서 호스트들은 연결에 대한 개별 수신 버퍼를 설정한다. 그리고 TCP 연결이 바이트를 순서대로 올바르게 수신되었을 때 TCP는 데이터를 수신 버퍼에 저장한다. 해당 애플리케이션 프로세스는 버퍼에서 데이터를 읽지만, 데이터가 도달한 시점에 읽을 필요는 없다. 사실 애플리케이션은 다른 작업들 때문에 바빠서 오랫동안 데이터를 읽지 않을 것이다. 그러한 이유로 데이터를 읽는 속도가 비교적 느리다면, 연결의 수신 버퍼는 아주 쉽게 오버플로를 발생시킬 것이다.

TCP는 그런 오버플로를 방지하기 위해 애플리케이션에게 **흐름 제어 서비스**를 제공한다. 한 마디로 흐름 제어는 속도를 일치시키는 서비스다. 수신하는 애플리케이션이 읽는 속도와 송신자가 전송하는 속도를 같게 한다. TCP가 흐름 제어 서비스를 어떻게 제공하는지 살펴보자. 이 설명에서는 TCP 수신자가 순서가 바뀐 세그먼트를 버린다고 가정한다.

TCP는 송신자가 **수신 윈도**라는 변수를 유지해 흐름 제어를 제공한다. TCP는 전이증이므로 연결 각 측의 송신자는 별개의 수신 윈도를 유지한다.

수신 버퍼의 크기를 `RcvBuffer`로 정의하고 추가로 다음의 변수들을 정의한다.
- LastByteRead: 호스트 B의 애플리케이션 프로세스에 의해 버퍼로부터 읽힌 데이터 스트림의 마지막 바이트 번호
- LastByteRcvd: 호스트 B에서 네트워크로부터 도착해 수신 버퍼에 저장된 데이터 스트림의 마지막 바이트 번호

이런 변수들로 다음의 수식이 항상 성립해야 한다.
```
LastByteRcvd - LastByteRead <= RcvBuffer
```

수신 윈도 `rwnd`는 버퍼의 여유 공간으로 설정된다.
```
rwcd = RcvBuffer - [LastByteRcvd - LastByteRead]
```

시간에 따라 여유 공간은 변하므로 `rwnd`는 동적이다.

TCP는 흐름 제어 서비스를 제공하기 위해 '송신하는 호스트'는 모든 세그먼트의 윈도 필드에 최신의 `rwnd` 값을 설정해 연결 버퍼에 얼만큼의 여유 공간이 있는지를 '수신하는 호스트'에게 알려준다. 초기에는 송신하는 호스트가 `rwnd = RcfBuffer`로 설정한다.

'송신하는 호스트'는 `rwnd` 값을 연결 동안 최신화 하기 위해 몇 개의 특정 연결 관련 변수들을 유지해야 한다. 반면 '수신하는 호스트'는 `LastByteSent`와 `LastByteAcked`만을 유지한다. `LastByteSent - LastByteAcked`는 '수신하는 호스트'가 해당 연결에서 확인응답을 받지 못한 데이터의 양이다. `rwnd`값보다 작은 확인응답 안 된 데이터의 양을 유지함으로써 '송신하는 호스트'는 '수신하는 호스트'의 수신 버퍼에 오버플로가 발생하지 않는다는 것을 확신한다.

따라서 '수신하는 호스트'는 연결된 동안 다음의 수식을 만족함을 보장한다.
```
LastByteSent - LastByteAcked <= rwnd
```

이 방식에서는 사소한 문제가 있다. 만약 '수신하는 호스트'의 수신 버퍼가 `rwnd = 0`으로 가득 찼다고 가정해보자. '송신하는 호스트'에게 `rwnd = 0`이라 알린 후에 수신하는 호스트'가 '송신하는 호스트'에게 보낼 게 없다고 가정하자. 이 상황에서 '수신하는 호스트'에서 애플리케이션 프로세스가 버퍼를 비우더라도, TCP는 '송신하는 호스트'에게 새로운 `rwnd`로 새로운 세그먼트를 전송하지 않는다. 즉, TCP는 전송할 데이터가 있거나 전송해야 할 확인응답을 가진 경우에만 '호스트'에게 세그먼트를 전송하기 때문에, '송신하는 호스트'는 '수신하는 호스트'의 수신 버퍼에 약간의 공간이 있다는 걸 모른다. 따라서 '송신하는 호스트'는 결과적으로 차단되는 것이나 다름 없다.

이런 문제를 해결하기 위해 TCP 명세서는 호스트 A가 호스트 B의 수신 윈도가 0일 때, 1바이트 데이터로 세그먼트를 계속해서 전송하도록 요구한다. 그럼 버퍼가 비워졌을 때 날아가는 긍정 확인응답은 0이 아닌 `rwnd` 값을 포함한다.

### 2.6 TCP 연결 관리

TCP 연결이 어떻게 설정되고 해제되는지에 대해서는 다음의 이유로 중요한 주제이다.
1. 연결 설정에서 생길 수 있는 latency가 커질 수 있다.
2. SYN flood 공격을 비롯한 가장 일반적인 네트워크 공격들은 TCP 연결 관리의 취약점을 악용한다.

클라이언트가 서버와의 연결을 시작하길 원한다고 하자. 그럼 클라이언트 애플리케이션 프로세스는 서버에 있는 프로세스와 연결 설정하기를 원한다는 것을 클라이언트 TCP에게 알린다. 그럼 클라이언트 안의 TCP는 다음과 같은 방법으로 서버와의 TCP 연결 설정을 시작한다.

1. **1단계**: 클라이언트 TCP는 서버 TCP에게 특별한 TCP 세그먼트를 송신한다. 이 세그먼트는 애플리케이션 계층 데이터를 포함하지 않는다. 하지만 세그먼트의 헤더에 SYN 비트라고 불리는 하나의 플래그 비트를 1로 설정한다. 이 세그먼트를 SYN 세그먼트라고 부른다. 추가로 클라이언트는 최초의 순서 번호(`client_isn`)를 임의로 선택하고, 최초의 TCP SYN 세그먼트의 순서 번호 필드에 이 번호를 넣는다. 이 세그먼트는 IP 데이터그램 안에서 캡슐화되고 서버로 송신된다.
2. **2단계**: TCP SYN 세그먼트를 포함하는 IP 데이터그램이 서버 호스트에 도착하면, 서버는 데이터그램으로부터 TCP SYN 세그먼트를 추출한다. 그리고 연결에 TCP 버퍼와 변수를 할당한다. 그리고 클라이언트 TCP로 연결 승인 세그먼트를 송신한다. 이 세그먼트도 애플리케이션 계층 데이터를 포함하지 않는다. 하지만 세그먼트 헤더에 중요한 정보 3개를 포함한다. 첫째, SYN 비트는 1로 설정된다. 둘째, TCP 세그먼트 헤더의 확인응답 필드는 `client_isn + 1`로 설정된다. 마지막으로, 서버는 자신의 최초 순서 번호(`server_isn`)를 선택하고, TCP 세그먼트 헤더의 순서 번호 필드에 이 값을 넣는다. 이 연결 승인 세그먼트는 사실상, '나는 당신의 최초 순서 번호 `client_isn`을 가지고 연결을 시작하자는 당신의 SYN 패킷을 수신했다. 나는 이 연결 설정에 동의한다. 나의 최초 순서 번호는 `server_isn이다.'라고 말하는 것이다. 연결 승인 세그먼트는 **SYNACK 세그먼트**라고도 불린다.
3. **3단계**: 연결 승인 세그먼트를 수신하면, 클라이언트는 연결에 버퍼와 변수를 할당한다. 그 다음 클라이언트 호스트는 서버로 또 다른 세그먼트를 송신한다. 이 마지막 세그먼트가 서버의 연결 승인 세그먼트를 확인하는 것이다. 연결이 설정되었기 때문에 SYN 비트는 0으로 설정된다. 세 방향 핸드셰이크의 세 번째 단계는 클라이언트에서 서버로의 데이터를 세그먼트 페이로드에서 운반할 수 있다.

