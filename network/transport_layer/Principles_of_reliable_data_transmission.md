신뢰적인 데이터 전송이 보장되는 서비스의 구현은 **신뢰적인 데이터 전송 프로토콜**의 '아래에 있는' 계층이 신뢰적이지 않을 수 있기 때문에 어려워진다.

신뢰적인 데이터 전송 프로토콜의 설계를 점진적으로 구현해보면 체크섬, 순서 번호, ACK/NCK 패킷, 재전송의 사용 등이 그런 프로토콜 구현에 필요하다. 

하지만 체크섬, 순서 번호, ACK/NCK 패킷 또한 손실 혹은 유실될 가능성이 있기 때문에 송신자의 관점에서 재전송이야 말로 답인 것처럼 정리된다. 따라서 송신자 측의 **시간 기반 재전송 메커니즘***의 구현이 중요하다.

그런 메커니즘을 구현하기 위해서 '주어진 시간이 지난 후에 송신자의 대기 상태를 인터럽트할 수 있는 **카운트다운 타이머**'가 필요하다. 타이머에 의한 송신자의 동작은 다음과 같다.

1. 매 패킷(첫 번째 또는 재전송 패킷)이 송신된 시간에 타이머를 시작
2. 주어진 시간이 지나면 인터럽트되어 적당한 행동을 취함
3. 타이머를 멈춤

카운트다운 타이머를 사용하는 설계의 프로토콜을 **alternating-bit protocol**이라고 부른다. 본문에서 이를 줄여서 얼비콜이라고 부르겠다.

## 2. 파이프라이닝된 신뢰적인 데이터 전송 프로토콜

위에서 살펴본 얼비콜은 전송 후 대기(stop-and-wait) 프로토콜이다. 이 프로토콜은 패킷 전송 후 대기하는 방식으로 동작하기 때문에 비효율적이다. 

어떤 두 종단 시스템 사이의 광속 왕복 전파 지연(RTT)가 30ms라고 해보자. 이곳으로 8000 비트 크기의 패킷을 1Gbps 링크로 전송한다면 링크로의 전송 시간은 8 마이크로 초이다.

송신자는 따라서 30.008 ms 후에 ACK 패킷을 받을 수 있다. 따라서 다음과 같은 송신자 이용률을 갖게 된다.

$U_{sender}\ =\ \frac{L/R}{RTT\ +\ L/R} = \frac{0.008}{30.008}\ =\ 0.00027$

즉, 송신자는 자신이 ACK 패킷을 받는데 소요되는 시간의 0.027% 동안만 일을 했다. 30.008 ms 동안 1,000 바이트를 송신할 수 있는 스펙의 인프라를 사용 중임에도 267 kbps의 유효 처리량을 갖는 것이다. 고작 267 kbps 의 처리량을 얻자고 1Gbps 용량의 링크의 비용을 지불하는 것은 눈물이 절로 나는 상황이다.

이 문제의 해결책으로 송신자가 ACK를 받기 전에 다음 패킷들을 송신하는 것을 허용하는 방법이 있다. 그런 방법, 기술을 파이프라이닝(pipelining)이라고 부른다. 그러한 파이프라이닝 종류로 GBN과 SR이 있다.

## 3. GBN(Go-Back-N) 프로토콜

이 프로토콜은 슬라이딩 윈도우 개념을 사용해 아직 응답되지 않은 패킷의 개수를 제한한다. 송신 측부터 살펴보자.

- **상위로부터 호출**: 송신이 상위 계층에서 호출되면, 송신자는 우선 윈도가 가득 찼는지 확인하고 차있지 않다면 패킷이 생성되어 송신된다. 그리고 변수들이 적절하게 갱신된다. 만약 가득 차있다면, 가득 차있다는 함축적인 의미를 담아 송신하라고 한 데이터를 그대로 반환한다. 
- **ACK의 수신**: GBN 프로토콜에서 순서 번호 n을 가진 패킷에 대한 ACK는 누적 확인응답(cumulative acknowledgment)으로 인식된다. 이 누적 확인응답은 수신 측에서 올바르게 수신된 n을 포함해, n까지의 순서 번호를 가진 모든 패킷에 대한 확인응답이다.
- **타임아웃 이벤트**: GBN 이름은 손실이 있거나 지연된 긴 패킷이 있을 때의 송신자 동작에서 유래되었다. 전송 후 대기 프로토콜처럼 타이머를 손실된 데이터 또는 손실된 확인응답 패킷으로부터 회복하는데 사용한다. 만약 타임아웃이 발생하면, 송신자는 이전에 전송되었지만 아직 확인응답되지 않은 모든 패킷을 다시 송신한다. 만일 하나의 ACK가 수신되었지만, '전송했지만 아직 확인응답되지 않은 패킷'이 존재한다면, 타이머는 다시 시작된다. 확인응답이 안 된 패킷이 없다면 타이머는 멈춘다.

수신 측은 다음과 같다.

만약 순서 번호 n의 패킷이 문제 없이 순서대로 수신된다면 패킷 n에 대한 ACK를 송신하고 상위 계층에 패킷의 데이터 부분을 전달한다. 문제가 있다면 그 패킷을 버리고 가장 최근에 제대로 수신된 순서의 패킷에 대한 ACK를 재전송한다. 

또, 순서가 잘못된 패킷들은 버린다. 지금 순서 상 패킷 n이 수신되어야 하는데 패킷 n+1이 먼저 수신되었다면 데이터가 순서대로 전달되어야 하므로, 패킷 n+1을 저장하고 나중에 패킷 n이 수신되고 전달된 후에 상위 계층에 이 패킷을 전달한다. 그러나 패킷 n이 손실되면 송신자에서 GBN 재전송 규칙에 따라 패킷 n과 n+1이 모두 재전송될 것이다. 이러한 전략은 수신자 버퍼링이 간단해진다는 이점이 있다. 그러므로 송신자는 윈도 상위와 하위 경계와 이 윈도 안에 있는 nextseqnum 위치를 유지해야 하지만, 수신자는 단지 다음 패킷의 순서 번호다. 이 값은 수신자 FSM에 변수 `expectedseqnum`에서 유지된다. 물론, 재전송된 패킷마저 손실되어 있을 수도 있으므로 많은 재전송이 필요해질 수 있다는 단점이 있다.

## 4. SR(Selective Repeat) 프로토콜

GBN 프로토콜은 윈도 크기와 대역폭 지연이 모두 클 때, 많은 패킷이 파이프라인에 있게 되고 재전송이 일어날 때 불필요하게 많은 패킷이 대상이 될 수 있다. 채널 오류의 확률이 증가할수록 파이프라인에 불필요한 패킷의 비율 또한 증가한다. 

SR은 수신자에서 오류가 발생한 패킷이라 의심되는 것만을 송신자가 재전송한다. 이런 방식에서 수신자는 필요에 따라 올바르게 수신된 패킷에 대한 개별적인 확인응답을 요구한다. 

GBN과 동일하게 윈도 크기 N으로 아직 확인응답이 안 된 패킷의 수를 제한한다. 그러나 GBN과 달리 송신자는 윈도에 있는 몇몇 패킷에 대한 ACK를 이미 수신했을 것이다. 