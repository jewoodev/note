네트워크 애플리케이션 개발의 중심은 다른 위치에서 동작하고 있는 종단 시스템끼리 네트워크를 통해 서로 통신하는 프로그램을 작성하는 것이다. 대표적인 예시인 웹 애플리케이션에는 서로 통신하는 서버와 클라이언트로 구별되는 두 가지 프로그램이 있는데, 각각 사용자의 호스트(데스크톱, 랩톱, 태블릿, 스마트폰 등)에서 실행되는 브라우저 프로그램과 웹 서버 호스트에서 실행되는 웹 서버 프로그램이다.

그래서 네트워크 애플리케이션을 개발할 때는 여러 종단 시스템에서 실행되는 소프트웨어를 작성해야 한다. 중요한 것은 우리가 라우터나 링크 계층 스위치처럼 네트워크 코어 장비에서 실행될 소프트웨어를 작성할 필요는 없다는 것이다. 그런 네트워크 코어 장비를 위한 애플리케이션 소프트웨어를 직접 개발하고 싶더라도 불가능하다. 네트워크 코어 장비는 애플리케이션 계층에서 기능하지 않는 대신에 네트워크 계층 및 그 하위 계층에서 기능한다. 애플리케이션 소프트웨어는 종단 시스템에만 존재한다는 기본 설계 방식을 기억해두자.

## 1. 네트워크 애플리케이션 구조

애플리케이션 개발자 관점에서 네트워크 구조는 고정되어 있으며 애플리케이션에 특정 서비스의 집합을 제공한다. 반면 **애플리케이션 구조**는 애플리케이션 개발자가 설계하며, 애플리케이션이 다양한 종단 시스템에서 어떻게 조직되어야 하는지를 알려준다. 애플리케이션 개발자는 네트워크 애플리케이션에서 사용되는 잘 알려진 두 가지 구조(클라이언트-서버 구조 || P2P 구조) 중 하나를 선택하게 될 것이다.

**클라이언트-서버 구조**에서 항상 동작하고 있는 호스트를 서버라고 부르는데, 그러한 서버 하나 혹은 여러 서버가 협업해 제공하는 서비스는 클라이언트라는 호스트로부터 서비스 요청을 받아 제공된다. 서버와는 다르게 클라이언트는 항상 동작하고 있지 않을 수도, 할 수도 있다. 클라이언트-서버 구조에서 클라이언트는 서로 직접적인 통신을 하지 않는다는 특징이 있다. 그리고 서버가 고정 IP 주소라는 잘 알려진 주소를 갖는다는 특징도 있다. 서버는 항상 동작하고 있으므로 클라이언트는 서버 주소로 패킷을 보내서 언제든지 서버에 연결할 수 있다. 

클라이언트-서버 구조에서 하나의 서버 호스트가 모든 요청을 처리하기 버거운 일은 흔한 일이다. 그래서 많은 수의 호스트를 갖춘 **데이터 센터**가 강력한 가상의 서버를 생성하는 역할로 사용된다. 그리고 서비스 제공자들은 데이터 센터로부터 데이터를 보내기 위해 상호연결과 대역폭에 합당한 비용을 지불해야 한다.

P2P 구조에서는 항상 켜져 있는 인프라스트럭쳐 서버에 최소로 의존한다. 대신에 애플리케이션은 **피어**라는 간헐적으로 연결된 호스트 쌍이 서로 직접 통신하게 한다. 피어는 서비스 제공자가 소유하지 않고 사용자들이 제어하는 데스크톱과 랩톱이며, 대부분의 피어들은 가정, 대학, 사무실에 위치한다. 특정 서버를 통하지 않고 피어가 통신하므로 이 구조를 피어 투 피어, P2P라고 한다. 가장 인기 있는 P2P 애플리케이션은 파일 공유 애플리케이션인 비트토렌트이다.

P2P 구조에서 주목할만한 특징들 중 하나는 **자가 확장성**이다. 예를 들어, P2P 파일 공유 애플리케이션에서는 비록 각 피어들이 파일을 요구함으로써 작업 부하를 만들어내지만 동시에 그 피어들이 파일을 다른 피어들에게 분배함으로써 시스템의 서비스 능력을 높인다. 이런 특징으로 인해 일반적으로 서버 인프라와 대역폭을 요구하지 않기 때문에 비용 효율적이다. 하지만 고도의 분산 구조 특징으로 인한 보안, 성능, 신뢰성 면에서 문제가 있다.

## 2. 프로세스 간 통신

프로세스간 통신을 위한 규칙은 종단 시스템의 운영체제에 의해 좌우된다. 하지만 다른 호스트에서 실행되는 프로세스와의 통신을 대상으로 보면 서로 다른 운영체제에서 실행되는 프로세스들 간 통신이 어떻게 이루어지는지 봐야한다.

2개의 종단 시스템에서 프로세스는 컴퓨터 네트워크를 통한 메세지 교환으로 서로 통신한다. 

### 2.2 클라이언트와 서버 프로세스

네트워크 애플리케이션은 네트워크에서 서로 메세지를 보내는 두 프로세스로 구성된다. 그리고 그 두 프로세스는 클라이언트 프로세스와 서버 프로세스다. 두 프로세스는 다음과 같이 정의할 수 있다.

- 두 프로세스 간의 통신 세션에서 통신을 초기화(다른 프로세스와 세션을 시작하려고 접속을 초기화)하는 프로세스는 클라이언트이다.
- 세션을 시작하기 위해 접속을 기다리는 프로세스는 서버이다.

### 2.3 프로세스와 컴퓨터 네트워크 사이의 인터페이스

하나의 프로세스가 다른 프로세스로 보내는 메세지는 **소켓**(socket)을 통해 네트워크로 메세지를 보내고 받는다. 프로세스를 집에 비유한다면 소켓은 집 문, 출입구로 비유된다. 프로세스는 메세지를 다른 호스트의 프로세스로 보낼 때 소켓을 통해 바깥 네트워크로 메세지를 밀어낸다. 밀어내진 메세지는 일종의 전송 흐름을 거쳐 수신 프로세스의 소켓에 도달하고, 소켓을 통해 메세지를 받은 프로세스는 메세지를 처리한다.

소켓은 호스트의 애플리케이션 계층과 트랜스포트 계층 간의 인터페이스다. 또한, 소켓은 네트워크 애플리케이션이 인터넷에 만든 프로그래밍 인터페이스이므로, 애플리케이션과 네트워크 사이의 API(Application Programming Interface)라고도 한다. 

애플리케이션 개발자는 소켓의 애플리케이션 계층에 대한 모든 통제권을 갖지만, 소켓의 트랜스포트 계층에 대한 통제권은 거의 갖지 못한다. 트랜스포트 계층에 대한 애플리케이션 개발자의 통제는 

1. 트랜스포트 프로토콜의 선택
2. 최대 버퍼와 최대 세그먼트 크기 같은 약간의 트랜스포트 계층 매개변수의 설정

두 가지 뿐이다. 애플리케이션 개발자가 트랜스포트 프로토콜을 (선택이 가능한 경우에)선택하면, 애플리케이션은 그 프로토콜이 제공하는 전송 서비스를 사용해 구성된다.

### 2.4 프로세스 주소 배정

메세지가 특정 프로세스로 전송되어 도달하기 위해서는 수신 프로세스가 주소를 가지고 있어야 한다. 수신 프로세스를 식별하기 위해서는 다음과 같은 정보가 명시되어야 한다.

1. 호스트의 주소
2. 목적지 호스트 내의 수신 프로세스를 명시하는 식별자

인터넷에서 호스트는 IP 주소로 식별된다. IP 주소는 32비트로 구성되며, 호스트를 유일하게 식별할 수 있게 해준다.

송신 호스트는 목적지 호스트의 주소, 그리고 수신 호스트에서 수행되고 있는 수신 프로세스와 수신 소켓도 식별해야 한다. 이는 일반적으로 하나의 호스트가 많은 네트워크 애플리케이션을 실행하고 있을 수 있기 때문이다. 목적지 **포트 번호**가 특정 프로세스와 소켓을 식별하기 위한 목적으로 사용된다. 인기 있는 애플리케이션에는 특정 포트 번호가 할당된다. 웹 서버 포트 번호는 80번으로, SMTP를 사용하는 메일 서버는 25번으로 식별된다. 이러한 Well-known 포트 번호 목록은 http://www.iana.org에서 찾아볼 수 있다.

## 3. 애플리케이션이 이용 가능한 트랜스포트 서비스

소켓은 애플리케이션 프로세스와 트랜스포트 프로토콜 간의 인터페이스이다. 트랜스포트 프로토콜은 네트워크를 통해 메세지를 송신 프로세스의 소켓에서 수신 프로세스의 소켓으로 이동시킬 책임이 있다.

인터넷을 포함한 다양한 네트워크는 각각 하나 이상의 트랜스포트 프로토콜을 제공한다. 그래서 프로토콜이 애플리케이션에 어떤 서비스를 제공할 수 있는지를 파악하고 선택해야 한다. 그러한 서비스들은 크게 **신뢰적 데이터 전송**, **처리율**, **시간**, **보안**이라는 네 가지 차원으로 분류할 수 있다.

## 3.1 신뢰적 데이터 전송

패킷들은 네트워크 내에서 손실될 수 있다. 그러한 손실이 일어나는 예시로 라우터 버퍼에서 오버플로되거나, 패킷의 비트가 잘못되어 호스트나 라우터에 의해 버려질 수 있다. 이러한 손실은 애플리케이션의 종류에 따라서는 위험한 결과를 초라할 수 있다. 따라서 하나의 애플리케이션이 데이터가 올바르고, 다른 애플리케이션에 전달되는 것을 완전히 보장하기 위해 조치를 취해야 한다. 

프로토콜이 보장된 데이터 전송 서비스를 제공하는 걸 **신뢰적 데이터 전송**(reliable data transfer)을 제공한다고 한다. 

트랜스포트 계층 프로토콜이 애플리케이션에 제공할 수 있는 중요한 서비스 중 하나가 바로 신뢰적 데이터 전송이다. 트랜스포트 프로토콜이 이 서비스를 제공하면 송신 프로세스는 소켓으로 보내진 데이터가 오류 없이 수신 프로세스에 도달할 것에 확신을 갖는다.

신뢰적 데이터 전송이 제공되지 않을 때, 송신 프로세스가 보낸 데이터는 수신 프로세스에 전혀 도착하지 않을 수 있다. 그런 현상은 **손실 허용 애플리케이션**(loss-tolerant application)의 경우에만 받아들여질 수 있다. 그러한 애플리케이션에는 실시간 오디오/비디오 혹은 저장 오디오/비디오 같은 멀티미디어 애플리케이션이 있다. 

### 3.2 처리율

'처리율'은 네트워크 경로를 따라 두 프로세스 간의 통신 세션에서 송신 프로세스가 수신 프로세스로 비트를 전달할 수 있는 비율을 나타낸다. 다른 세션들이 네트워크 경로를 따라 대역폭을 공유하고, 그런 세션들이 생겼다 없어졌다 하기 때문에 가용한 처리율은 시간에 따라 변동한다. 

애플리케이션은 보장된 처리율을 트랜스포트 프로토콜에 요구할 수 있고 트랜스포트 프로토콜은 가용한 처리율이 항상 적어도 그 처리율임을 보장한다. 이런 보장된 처리율 서비스는 많은 애플리케이션에서 요구된다. 예를 들어, 인터넷 전화 애플리케이션이 32 kbps로 음성을 인코딩한다면, 애플리케이션은 같은 속도로 데이터를 네트워크로 보내야 한다. 만약 트랜스포트 프로토콜이 보장된 처리율을 제공하지 않는다면 애플리케이션은 낮은 속도로 인코딩하거나 포기해야 한다. 왜냐하면 인터넷 전화 애플리케이션에서 필요한 처리율의 반으로 수신하는 것은 의미가 없기 때문이다. 

처리율 요구사항을 갖는 애플리케이션은 **대역폭 민감 애플리케이션**(bandwidth-sensitive application)이라고 한다. 반면 **탄력적 애플리케이션**(elastic application)은 처리율 요구사항이 없다. 예를 들어, 웹 브라우저는 네트워크 처리율이 높을 때 더 많은 데이터를 다운로드하고, 네트워크 처리율이 낮을 때는 더 적은 데이터를 다운로드한다. 

### 3.3 시간

트랜스포트 계층 프로토콜은 **시간 보장**(timing guarantee)을 제공할 수 있다. 이 서비스는 여러 형태로 구현된다. 한 가지 예로, 송신자가 소켓으로 내보내는 모든 비트가 수신자의 소켓에 100ms 내에 도착하게 하는 형태가 있다. 이런 형태는 인터넷 전화, 가상 환경, 원격회의같은 실시간 상호작용 애플리케이션에 적합하다. 이런 애플리케이션이 효과적으로 동작하기 위해선 데이터 전송에 엄격한 시간 제한 조건이 요구된다. 

### 3.4 보안

마지막으로 트랜스포트 계층 프로토콜은 애플리케이션에 하나 이상의 보안 서비스를 제공할 수 있다. 예를 들어, 송신 호스트에서 트랜스포트 프로토콜은 송신 프로세스가 전송하는 모든 데이터를 암호화할 수 있고 수신 호스트에서 트랜스포트 프로토콜은 그 데이터를 수신 프로세스로 전달하기 전에 데이터의 암호를 해독할 수 있다. 이를 통해 데이터가 송신과 수신 프로세스 사이에서 어느 정도 관찰된다 하더라도 기밀성을 제공한다. 그리고 기밀성 외에 데이터 무결성(integrity)과 종단 인증(authentication)을 제공할 수 있다. 

## 4. 인터넷 전송 프로토콜이 제공하는 서비스

인터넷과 일반적인 TCP/IP 네트워크는 애플리케이션에게 2개의 전송 프로토콜, UDP(User Datagram Protocol)와 TCP(Transmission Control Protocol)를 제공한다. 두 프로토콜은 애플리케이션에게 각기 다른 서비스 모델을 제공한다.

### 4.1 TCP 서비스

이 서비스는 연결지향형 서비스와 신뢰적인 데이터 전송 서비스를 포함한다. 

- **연결지향형 서비스**: 애플리케이션 계층 메세지를 전송하기 전에 클라이언트와 서버가 서로 전송 제어 정보를 교환하게 한다. 이 핸드셰이킹 과정이 클라이언트와 서버에 패킷이 곧 도달할 테니 준비하라고 알리는 역할을 한다. 이 핸드셰이킹 단계를 지나면, **TCP 연결**이 두 프로세스의 소켓 사이에 존재한다고 말한다. 이 연결은 두 프로세스가 서로에게 동시에 메세지를 보낼 수 있기에 전이중(full-duplex) 연결이라 한다. 애플리케이션이 메세지 전송을 마치면 연결을 끊어야 한다.
- **신뢰적인 데이터 전송 서비스**: 통신 프로세스는 모든 데이터를 오류 없이 올바른 순서로 전달하기 위해 TCP에 의존한다. TCP는 애플리케이션의 한쪽이 바이트 스트림을 소켓으로 전달하면 그 바이트 스트림이 손실되거나 중복되지 않게 수신 소켓으로 전달한다.

또한 혼잡 제어 방식, 즉 통신하는 프로세스의 이득보다는 인터넷 전체 성능 향상을 위한 서비스를 제공한다. TCP 혼잡 제어 방식은 네트워크가 혼잡 상태에 이르면 프로세스의 속도를 낮춘다. 특히 각 TCP 연결이 네트워크 대역폭을 공평하게 사용하게 끔 제한하려 한다.

### 4.2 UDP 서비스

최소의 서비스 모델을 가진 간단한 전송 프로토콜이다. 비연결형이므로 두 프로세스가 통신을 하기 전에 핸드셰이킹을 하지 않는다. 그리고 비신뢰적인 데이터 전송 서비스를 제공한다. 하나의 프로세스가 UDP 소켓으로 메세지를 보내면, UDP는 그 메세지가 수신 소켓에 도착하는 걸 보장하지 않고 도착하는 메세지들의 순서가 뒤바뀔 수 있다.

혼잡 제어 방식도 제공하지 않는다. 따라서 송신 측은 데이터를 원하는 속도로 하위 계층(네트워크 계층)으로 보낼 수 있다. 하지만 실제 종단 간 처리율은 중간 링크들의 제한된 대역폭 혹은 혼잡으로 인해 이 속도보다 작아질 수 있다.

### 4.3 인터넷 전송 프로토콜이 제공하지 않는 서비스

TCP와 UDP에서 처리율이나 시간 보장에 대한 서비스는 제공하지 않는다. 그럼 오늘날의 인터넷 환경에서 시간 민감 애플리케이션은 어떻게 문제없이 쓰이고 있는걸까? 이러한 애플리케이션은 그런 보장이 없는 경우에도 가능한 한 잘 대처할 수 있도록 설계함으로써 상당히 잘 작동하고 있다. 그래도 지연이 과도할 때는 한계가 있다. 

오늘날의 인터넷은 항상은 아닌, 때때로 시간 민감 애플리케이션들에게 만족스러운 서비스를 제공할 수 있으나 시간 혹은 대역폭 보장을 제공할 수는 없다.

## 5. 애플리케이션 계층 프로토콜

메세지는 어떻게 구성되고 구성되는 여러 필드가 의미하는 것은 무엇일까? 프로세스는 메세지를 언제 보낼까? 

애플리케이션 계층 프로토콜은 다른 종단 시스템에서 실행되는 애플리케이션의 프로세스들이 서로 메세지를 보내는 방법을 정의한다. 어떤 것들이냐 하면, 아래와 같다.

- 교환 메세지 타입(ex. 요청 메세지와 응답 메세지)
- 여러 메세지 타입의 문법(ex. 메세지 내부의 필드와 필드간의 구별 방법)
- 필드에 있는 정보의 의미
- 언제, 어떻게 프로세스가 메세지를 전송하고 메세지에 응답하는지 결정하는 규칙

여러 애플리케이션 계층 프로토콜은 RFC에 명시되어 있어 공중 도메인(public domain)에서 찾을 수 있다. 만약 브라우저 개발자가 HTTP RFC의 규칙을 따른다면, 브라우저는 HTTP RFC의 규칙을 따른 어떤 웹 서버로부터라도 웹 페이지를 가져올 수 있다. 다른 많은 애플리케이션 계층 프로토콜은 독점적(비개방적)이머 공중 도메인에서 구할 수 없다. 예를 들어, 스카이프는 비개방 애플리케이션 계층 프로토콜을 사용한다.

네트워크 애플리케이션과 애플리케이션 계층 프로토콜을 구별하는 것은 중요하다. 애플리케이션 계층 프로토콜은 네트워크 애플리케이션의 한 요소일 뿐이다. 웹 애플리케이션 계층 프로토콜(HTTP)은 브라우저와 웹 서버 사이에서 교환되는 메세지의 포맷과 순서를 정의한다. 따라서 HTTP는 단지 웹 애플리케이션을 구성하는 요소이다. 