- 토픽은 카프카에서 데이터를 구분하기 위해 사용하는 단위이다.
- 토픽은 1개 이상의 파티션을 소유하고 있다.
- 파티션에는 프로듀서가 보낸 데이터들이 저장되는데 이 데이터를 '레코드(record)'라고 부른다.
- 파티션은 자료구조에서 접하는 큐(queue)와 비슷한 구조라고 생각하면 쉽다.
- First-In-First-Out(FIFO) 구조와 같이 먼저 들어간 레코드는 컨슈머가 먼저 가져가게 된다. 
  - 다만, 일반적인 자료구조로 사용되는 큐는 데이터를 가져가면(pop) 삭제하지만 카프카에서는 삭제하지 않는다. 파티션의 레코드는 컨슈머가 가져가는 것과 별개로 관리된다. 
  - 이러한 특징 때문에 토픽의 레코드는 다양한 목적을 가진 여러 컨슈머 그룹들이 토픽의 데이터를 여러번 가져갈 수 있다.

## 토픽 생성시 파티션이 배치되는 방법
![image-20240505151737203](https://github.com/jewoodev/blog-img/blob/main/2024-05-03-%EC%95%84%ED%8C%8C%EC%B9%98_%EC%B9%B4%ED%94%84%EC%B9%B4_%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D_%EC%9D%B8%EA%B0%95_%EC%A0%95%EB%A6%AC/image-20240505151737203.png?raw=true)

파티션이 5개인 토픽을 생성했을 경우 그림과 같이 0번 브로커부터 시작하여 round-robin 방식으로 리더 파티션들이 생성된다. 카프카 클라이언트는 리더 파티션이 있는 브로커와 통신하여 데이터를 주고 받으므로 여러 브로커에 골고루 네트워크 통신을 하게 된다. 이를 통해, 데이터가 특정 서버(여기서는 브로커)와 통신이 집중되는(hot spot) 현상을 막고 선형 확장(linear scale out)을 하여 데이터가 많아지더라도 유연하게 대응할 수 있게 된다.

## 파티션 개수와 컨슈머 개수, 그리고 처리량
파티션은 카프카의 병렬처리의 핵심으로써, 그룹으로 묶인 컨슈머들이 레코드를 병렬로 처리할 수 있도록 파티션들과 매칭된다. 컨슈머의 처리량이 한정된 상황에서 '많은 레코드를 벙렬로 처리하는 가장 좋은 방법'은 컨슈머의 개수를 늘려 스케일 아웃하는 것이다. 다만, 컨슈머 개수가 파티션 개수를 초과하면 의미가 없으니 같이늘려야 처리량이 증가한다.

## 파티션 개수를 줄이는 것은 불가능
카프카에서 한 번 늘린 파티션의 개수를 줄이는 걸 지원하지 않는다. 그래서 파티션을 늘리는 작업을 할 때는 신중히 파티션 개수를 정해야 한다.  

만에 하나 지원을 한다고 하더라도 여러 브로커에 저장된 데이터를 취합하고 정렬해야하는 복잡한 과정을 거쳐야 하며, 그런 작업은 클러스터에 큰 영향을 미치게 된다. 

참고로 KIP-694에서 파티션 개수를 줄이는 것을 논의했지만 더 이상 진행되지 않고 있다. 