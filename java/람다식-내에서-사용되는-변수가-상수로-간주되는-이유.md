'자바의 람다식 내에서 사용되는 변수'가 상수로 간주되는 이유는 **effective final**개념 때문이다.

# 주요 이유
## 캡쳐된 변수의 불변성 보장
람다식은 외부 변수를 캡처할 때 그 변수의 값을 복사해서 사용한다. 만약 람다 내부에서 파라미터나 캡처된 변수를 사용할 수 있다면, 원본 변수와 복사본 간의 불일치가 발생할 수 있다.

```java
int x = 10;
Runnable r = () -> {
    // x = 20;  // 컴파일 에러! x는 effectively final이어야 함
    System.out.println(x);
};
```

## 멀티스레드 안정성
람다식은 다른 스레드에서 실행될 수 있다. 그렇기에 변수를 변경 가능하게 만들면 동기화 문제가 발생할 수 있어, 이를 원천적으로 차단한다.

## 익명 클래스와의 일관성
자바 8 이전부터 익명 클래스에서도 외부 변수를 사용하려면 final이어야 했다. 람다식도 이 규칙을 따른다.

```java
// 익명 클래스 (Java 7 이전)
final int y = 5;
Runnable r = new Runnable() {
    public void run() {
        System.out.println(y); // final만 접근 가능
    }
};
```

# Effective final이란?
명시적으로 `final` 키워드가 없어도, 초기화 이후 값이 변경되지 않으면 effectively final로 간주된다. 

```java
int num = 100;
Consumer<String> consumer = s -> System.out.println(s + num);

// num = 200; // 이 줄이 있으면 num은 더 이상 effectively final이 아님
```
이런 제약은 코드의 예측 가능성을 높이고, 함수형 프로그래밍의 불변성 원칙과도 일치한다.

# 동기화 문제 더 이해하기
앞서 언급된 동기화 문제가 구체적으로 어떤 방식으로 발생할 수 있는지 살펴보자.

```java
public class LambdaConcurrencyProblem {
    public static void main(String[] args) {
        // 만약 변수가 변경될 수 있다면...
        int[] counter = {0}; // 배열로 우회
        
        // 여러 스레드에서 동일한 람다 실행
        Runnable r = () -> {
            for (int i = 0; i < 1000; i++) {
                counter[0]++;
            }
        };
        
        Thread t1 = new Thread(r);
        Thread t2 = new Thread(r);
        Thread t3 = new Thread(r);
        
        t1.start();
        t2.start();
        t3.start();
        
        try {
            t1.join();
            t2.join();
            t3.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        
        // 예상: 3000, 실제: 3000보다 작은 값 (Race condition)
        System.out.println("Counter: " + counter[0]);
    }
}
```

```
**실행 결과 예시:**

Counter: 2847  // 매번 다른 결과
Counter: 2931
Counter: 2765
```

## 문제의 이유 1: Read-Modify-Write 문제
```
counter[0]++;  // 실제로는 3단계

// 1. Read:   temp = counter[0]
// 2. Modify: temp = temp + 1
// 3. Write:  counter[0] = temp
```

**2. 스레드 인터리빙 예시**
```
시간  | Thread 1        | Thread 2        | counter[0]
-----|-----------------|-----------------|------------
t1   | Read (0)        |                 | 0
t2   |                 | Read (0)        | 0
t3   | Modify (1)      |                 | 0
t4   |                 | Modify (1)      | 0
t5   | Write (1)       |                 | 1
t6   |                 | Write (1)       | 1  ← 2가 되어야 하는데 1!
```

## 해결 방법
```java
public class LambdaConcurrencySolution {
    public static void main(String[] args) {
        // 1. AtomicInteger 사용
        AtomicInteger counter = new AtomicInteger(0);

        Runnable task = () -> {
            for (int i = 0; i < 1000; i++) {
                counter.incrementAndGet();  // 원자적 연산
            }
        };

        Thread t1 = new Thread(task);
        Thread t2 = new Thread(task);
        Thread t3 = new Thread(task);

        t1.start();
        t2.start();
        t3.start();

        try {
            t1.join();
            t2.join();
            t3.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("Counter: " + counter.get());  // 항상 3000
    }
}
```

## 자바가 effectively final을 강제하는 이유
람다식이 변수 수정을 허용하지 않음으로써:

1. 개발자가 동기화를 잊는 실수 방지 
2. 불변성을 통한 스레드 안전성 보장 
3. 복잡한 동기화 로직 불필요

만약 변경 가능한 상태가 필요하다면 `AtomicInteger`, `AtomicReference` 같은 스레드 안전한 클래스를 명시적으로 사용하도록 유도한다. 이는 개발자가 멀티스레드 환경을 의식하고 적절한 도구를 선택하게 만든다.
