# 제네릭 타입
제네릭 타입은 클래스나 메소드에서 사용할 타입을 동적으로 할당하는 방법이다. 이를 사용하면 클래스나 메소드를 정의하는 단계가 아닌 객체를 생성하는 단계에서 타입을 지정할 수 있다.  

Object 타입을 사용하면 모든 타입(기본 타입 제외)을 포용할 수 있어 이 또한 동적인 할당 방법이라고 할 수 있지만, Object 자리에 모두 같은 타입이 와야 한다는 제약을 걸 수는 없다.  
그래서 나중에 타입이 맞지 않아 에러가 발생하기도 한다. 그런데 제네릭 타입을 쓰면 동일한 타입이 요구되는 상황에서 타입을 일치시켜야 하는 제약을 걸 수 있다. 즉, 타입 안정성을 보장할 수 있다.

Object 클래스를 사용하면 컴파일이나 런타임에 예상치 못한 타입 충돌로 인한 에러나 비일관성 문제로 인한 버그를 만들어 낼 수 있다. 타입이 분명해지는 시점에는 가능하면 타입을 애매하지 않게 표현하는 것이 좋다. 제네릭 클래스는 이러한 목적을 이루기 위해 사용하기 적합하다.

## 1. 타입 소거
제네릭은 컴파일 타임에만 존재하고, 런타임에는 사라지는 특성을 가지고 있다.  
즉, 컴파일 후에는 `List<String>` 이나 `List<Integer>` 모두 `List`로 처리돼서 런타임에는 제네릭 타입 정보가 남아 있지 않다.   
이 특성 때문에 제네릭 타입의 변수를 선언할 때는 타입을 명시해주어야 한다.

아직 어떤 상황에서 명시하라는 건지 명확하게 이해가 되지 않는다. 예시를 보면서 이해해보자.

`List`같은 제네릭 타입의 리스트 클래스를 만들려고 한다고 생각해보자.  
그리고 원소를 저장하는 구조는 배열을 선택했다고 하자.

```java
public class ArrayList<E> {
    private E[] elements; // 원소를 저장할 배열
    private int size; // 현재 리스트에 저장된 원소 갯수
    private static final int DEFAULT_CAPACITY = 64; // 리스트의 크기 Default 값 
    
    pubilc ArrayList() {
        elements = new E[DEFAULT_CAPACITY]; // ❌ 컴파일 에러 발생
        size = 0;
    }
}
```
`ArrayList`의 생성자에선 `elements`와 `size` 변수를 초기화 해줘야 할 것이다.   
`elements` 변수를 생성자에서 초기화하기 위해 평소에 인스턴스를 생성하듯이 `new E[]`를 넣어주면 될 것 같지만 컴파일 에러가 발생한다.

컴파일 에러가 발생하는 이유는 아래와 같다.
- `T`가 어떤 타입인지 컴파일 타임에는 알지만, 런타임에는 알 수 없다(타입 소거 특성!).
- 즉, `T`는 타입 소거 후에 `Object`처럼 취급되므로, new 연산자로 인스턴스를 생성할 수 없다.

그래서 `Object`로 인스턴스를 생성하고 명시적으로 형변환을 해줘야 한다.

```java
public class ArrayList<E> {
    // ...
    
    pubilc ArrayList() {
        elements = (E[]) new Object[DEFAULT_CAPACITY];
        size = 0;
    }
}
```
