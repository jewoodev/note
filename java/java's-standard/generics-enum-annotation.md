# 1. 지네릭스
지네릭스는 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입 체크를 해주는 기능이다. 객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성을 높이고 형변환의 번거로움을 없애준다.

### 지네릭스의 용어
```java
class Box<T> {}
```
위처럼 선언된 클래스가 있을 때 다음과 같은 지네릭스 용어가 있다.

- `Box<T>`: 지네릭 클래스. 'T의 Box' 또는 'T Box'라고 읽는다.
- `T`: 타입 변수 또는 타입 매개변수(T는 타입문자).
- `Box`: 원시(raw) 타입

타입 문자는 지네릭 클래스의 타입 변수 또는 타입 매개변수라고 한다. 그렇게 부르는 이유는 메서드의 매개변수와 유사한 면이 있기 때문이다.  
`Box<String>`과 `Box<Integer>`는 지네릭 클래스 `Box<T>`에 서로 다른 타입을 대입해 호출한 것일 뿐, 별개의 클래스를 의미하는 것이 아니다. 이러한 점이 유사하다.

컴파일 후에 `Box<String>`과 `Box<Integer>`는 원시 타입 `Box`로 바뀐다. 즉, 지네릭 타입이 **제거**된다.

### 지네릭스의 제한
모든 객체에 대해 동일하게 동작해야하는 'static 멤버'에 타입 변수를 사용할 수는 없다. T는 인스턴스 변수로 간주되기 때문이다.  
> static 멤버는 인스턴스 변수를 참조할 수 없다. static 멤버는 타입 변수에 지정된 타입, 혹은 대입된 타입의 종류에 상관없이 동일한 것이어야 하기 때문이다.

그리고 지네릭 타입의 배열을 생성하는 것도 허용되지 않는다. 지네릭 배열 타입의 참조변수를 선언하는 것은 가능하지만 `new T[10]`처럼 배열을 생성하는 것은 안 된다.

지네릭 배열을 생성할 수 없는 이유는 `new` 연산자 때문인데, 이 연산자는 컴파일 시점에 타입 T가 무엇인지 정확히 알아야 한다. 그런데 지네릭 클래스을 인스턴스화 하는 사용부가 아닌 지네릭 클래스는 컴파일 하는 시점에서 그걸 알 수가 없다. 그래서 `instanceof` 연산자도 사용할 수 없다.

꼭 지네릭 배열을 생성해야할 필요가 있을 땐 'Reflection API'의 `newInstance()`와 같이 동적으로 객체를 생성하는 메서드로 배열을 생성하거나, `Object` 배열을 생성해서 복사한 다음 `T[]`로 형변환하는 방법 등을 사용한다.

## 1.4 제한된 지네릭 클래스
```java
class FruitBox<T extends Fruit> {
    ArrayList<T> list = new ArrayList<>();
}
```
지네릭 타입에 `extends`를 사용하면 특정 타입과 그의 자손들만 대입할 수 있게 제한할 수 있다.

만일 클래스가 아니라 인터페이스를 구현해야 한다는 제약이 필요하다면, 이 때도 `extends`를 사용한다. `implements`를 사용하지 않는다는 점에 주의하자.

클래스 Fruit의 자손이면서 Eatable 인터페이스도 구현해야 한다면 아래와 같이 `&` 기호로 연결하면 된다.
```java
class FruitBox<T extends Fruit & Eatable> {}
```

## 1.5 와일드 카드
```java
class Juicer {
    static Juice makeJuice(FruitBox<Fruit> box) {
        // ...
    }
}
```
위 예시처럼 지네릭 타입이 Fruit으로 고정되면 `makeJuice()` 메서드의 매개변수로 `FruitBox<Apple>`은 올 수 없게 된다(지네릭스의 불공변성 때문).  

원시 타입은 공변성이 적용되지만, 타입 매개변수에는 적용되지 않는다. 그러면 아래처럼 오버로딩 메서드를 만드는 걸 시도하게 될 것이다.
```java
class Juicer {
    static Juice makeJuice(FruitBox<Fruit> box) {
        // ...
    }
    
    static Juice makeJuice(FruitBox<Apple> box) {
        // ...
    }
}
```
하지만 이렇게 시도하면 컴파일 에러가 발생한다. **지네릭 타입이 다른 것만으로는 오버로딩이 성립하지 않기 때문이다**. 이 두 메서드의 정의는 '메서드 중복 정의'가 되버린다.

이런 문제를 해결하기 위해 고안된 것이 '와일드 카드'이다. 와일드 카드는 어떤 타입도 될 수 있다.

## 1.6 지네릭 메서드
메서드 선언부에 지네릭 타입이 선언된 메서드를 지네릭 메서드라고 한다. 지네릭 메서드의 지네릭 타입 선언 위치는 '반환 타입 바로 앞'이다.

```java
static <T> void sort(List<T> list, Comparator<? super T> c)
```

'지네릭 클래스에 정의된 타입 매개변수'와 '지네릭 메서드에 정의된 타입 매개변수'는 전혀 다른 별개의 것이다. 

```java
class FruitBox<T> {
    static <T> void sort(List<T> list, Comparator<? super T> c) {
        // ...
    }
}
```
위 코드에서 FruitBox의 타입 매개변수 T와 지네릭 메서드 `sort()`에 선언된 타입 매개변수 T는 타입 문자만 같을 뿐 서로 다른 것이다.

> static 멤버에는 타입 매개변수를 사용할 수 없지만, 지네릭 메서드로의 지네릭 타입 선언 및 사용은 가능하다.

메서드에 선언된 지네릭 타입은 지역 변수를 선언한 것과 같다고 쉽다.

## 1.7 지네릭 타입의 형변환
지네릭 타입와 원시 타입 간의 형변환은 경고를 발생시키지만 항상 가능하다.

타입 매개변수가 다른 지네릭 클래스 간에는 형변환이 불가능하다.

하지만 와일드 카드를 통해 '타입 매개변수가 다른 지네릭 클래스 간의 형변환'도 가능해질 수 있다.

```
Optional<Object> -> Optional<T> // 형변환 불가능
Optional<Object> -> Optional<?> -> Optional<T> // 형변환 가능. 경고발생.
```

## 1.8 지네릭 타입의 제거
컴파일러는 지네릭 타입을 이용해서 소스파일을 체크하고, 필요한 곳에 형변환을 넣어준다. 그리고나서 지네릭 타입을 제거한다. 알고 있겠지만, 이런 절차를 밟기 때문에 컴파일된 파일에는 지네릭 타입이 없다.

이런 절차로 처리되게 해놓은 이유 중 주된 것은 지네릭이 도입되기 이전의 소스 코드와의 호환성을 유지하기 위해서다. 

이 제거 과정은 꽤 복잡하기 때문에 기본적인 과정에 대해서만 알아보자.

1. 지네릭 타입의 경계(bound)를 제거한다.
   - 지네릭 타입이 `<T extends Fruit>`라면 `T`는 `Fruit`로 치환된다. `<T>` 인 경우 `T`는 `Object`로 치환되며 그 후 클래스 옆의 선언은 제거된다.
2. 지네릭 타입을 제거한 후에 타입이 일치하지 않으면, 형변환을 추가한다.
   - ex) `List`의 `get()`은 `Object` 타입을 반환하므로 형변환이 필요하다.
   - 지네릭 타입에 와일드 카드가 포함되어 있는 경우도 적절한 타입으로의 형변환이 추가된다.


# 2. 열거형
열거형은 서로 관련된 '상수'를 편리하게 선언하기 위한 것으로 여러 상수를 정의할 때 사용하기 유용하다. 그리고 열거형이 갖는 값뿐만 아니라 타입도 관리하기 때문에 논리적인 오류를 줄일 수 있는 효과가 있다.

그보다 중요한 열거형이 갖는 강점이 있다. 상수의 값이 바뀌면 해당 상수를 참조하는 모든 소스를 다시 컴파일해야 한다. 그런데 열거형을 사용하면, 기존의 소스를 재컴파일할 필요가 없다.

## 2.2 열거형의 정의와 사용
열거형 정의는 다음과 같이 `{}` 괄호 안에 상수의 이름만 나열하면 된다.
```java
enum 열거형이름 { 상수명1, 상수명1, ... }
```

열거형에 정의된 상수를 사용하는 방법은 `열거형이름.상수명`이다. 클래스의 static 변수를 참조하는 것과 동일하다.

열거형 상수간의 비교에는 `==`를 사용할 수 있다. `equals()`가 아닌 `==`로 비교가 가능하다는 것은 그만큼 빠른 성능을 제공한다는 얘기다.  
그러나 `<`, `>` 같은 비교연산자는 사용할 수 있고 `compareTo()`는 사용가능하다. 

```java
if (dir == Direction.EAST) {
  x++;
} else if (difr > Direction.WEST) { // 에러. 열거형 상수에 비교연산자 사용불가
    // ...
} else if (dir.compareTo(Direction.WEST) > 0) { // compareTo()는 가능
    // ...
}
```

다음과 같이 switch 문의 조건식에도 열거형을 사용할 수 있다.
```java
void move() {
    switch (dir) {
       case EAST: // Direction.EAST라고 쓰면 안된다.
           x++;
           break;
       case WEST:
           x--;
           break;
       case SOUTH:
           y++;
           break;
       case NORTH:
           y--;
           break;
    }
}
```

이 때 주의할 점은 case문에 열거형의 이름은 적지 않고 상수의 이름만 적어야 한다는 제약이 있다.

### 모든 열거형의 조상 - java.lang.Enum
열거형의 모든 상수를 출력하려면 다음과 같이 한다.
```java
Direction[] dArr = Direction.values();

for (Direction d : dArr)
    System.out.println("%s=%d%n", d.name(), d.ordinal());
```

`values()`는 열거형의 모든 상수를 배열에 담아 반환한다. 이 메서드는 모든 열거형이 가지고 있는 것인데, Enum 클래스가 갖고 있는 메서드가 아니라 '컴파일러가 각 enum 클래스마다 자동으로 생성하는 synthetic 메서드'다.  
그리고 `ordinal()`는 모든 열거형의 조상인 java.lang.Enum 클래스에 정의된 것으로, 열거형 상수가 정의된 순서(0부터 시작)를 정수로 반환한다.

# 3. 애너테이션
자바를 개발한 사람들은 소스코드에 대한 문서를 따로 만들기보다 소스코드와 문서를 하나의 파일로 관리하는 것이 낫다고 생각했다.  
그래서 소스코드의 주석 `/** */`에 소스코드의 정보를 저장하고, 소스코드의 주석으로부터 HTML 문서를 생성해내는 프로그램(javadoc.exe)을 만들어서 사용했다. 

모든 애너테이션의 조상인 Annotation 인터페이스의 소스코드는 미리 정의된 태그들을 이용해서 주석 안에 정보를 저장하고, javadoc.exe라는 프로그램이 이 정보를 읽어서 문서를 작성하는데 사용한다.

이 기능을 응용해서, 프로그램의 소스코드 안에 다른 프로그램을 위한 정보를 미리 약속된 형식으로 포함시킨 것이 바로 애너테이션이다.  
애너테이션은 주석처럼 프로그래밍 언어에 영향을 미치지 않으면서도 다른 프로그램에게 유용한 정보를 제공할 수 있다는 장점이 있다.

애너테이션은 JDK에서 기본적으로 제공하는 것과 다른 프로그램에서 제공하는 것들이 있는데, 어느 것이든 그저 약속된 형식으로 정보를 제공하기만 하면 된다. JDK에서 제공하는 표준 애너테이션은 주로 컴파일러를 위한 것으로 컴파일러에게 유용한 정보를 제공한다. 그리고 새로운 애너테이션을 정의할 때 사용하는 메타 애너테이션을 제공한다.

### java.lang.annotation.Annotation
모든 애너테이션의 조상이다. 조상이지만 애너테이션은 상속이 허용되지 않으므로 아래와 같이 명시적으로 Annotation을 조상으로 지정할 순 없다.
```java
@interface TestInfo extends Annotation { // 에러. 허용되지 않는 표현
    int count();
    String testedBy();
}
```

그리고 Annotation은 애너테이션이 아니라 일반적인 인터페이스로 정의되어 있다.
```java
package java.lang.annotation;

public interface Annotation { // Annotation 자신은 인터페이스이다.
    boolean equals(Object obj);
    int hashCode();
    String toString();
    
    Class<? extends Annotation> annotationType(); // 애너테이션 타입을 반환
}
```

모든 애너테이션의 조상이 위와 같이 정의되어 있기 때문에, 모든 애너테이션 객체에 대해 equals(), hashCode(), toString() 메서드를 호출할 수 있다.

### 마커 애너테이션 Marker Annotation
값을 지정할 필요가 없는 경우, 애너테이션의 요소를 하나도 정의하지 않을 수 있다.  
Serializable이나 Cloneable 인터페이스처럼, 요소가 하나도 정의되지 않은 애너테이션을 마커 애너테이션이라고 한다.

### 애너테이션 요소의 규칙
애너테이션 요소를 선언할 때 반드시 지켜야 하는 규칙이 있다.

- 요소의 타입은 기본형, String, enum, 애너테이션, Class만 허용된다.
- ()안에 매개변수를 선언할 수 없다.
- 예외를 선언할 수 없다.
- 요소를 타입 매개변수로 정의할 수 없다.

아래의 코드에서 오른쪽 주석을 가리고 무엇이 잘못되었는지 잠시 생각해보자.
```java
@interface AnnoTest {
   int id = 100; // OK. 상수 선언. static final int id = 100;
   String major(int i, int j); // 에러. 매개변수를 선언할 수 없음
   String minor() throws Exception; // 에러. 예외를 선언할 수 없음
   ArrayList<T> list(); // 에러. 요소의 타입에 타입 매개변수 사용불가
}
```

만약 클래스에 적용된 애너테이션 런타임에서 얻으려면, 아래와 같이 하면 된다.
```java
Class<AnnotationEx5> cls = AnnotationEx5.class;
TestInfo anno = (TestInfo) cls.getAnnotation(TestInfo.class);
```

`AnnotationEx5.class`는 클래스 객체를 의미하는 리터럴이다.  
모든 클래스 파일은 클래스로더에 의해 메모리에 올라갈 때, 클래스에 대한 정보가 담긴 객체를 생성하는데 이 객체를 클래스 객체라고 한다. 이 객체를 참조할 때는 `클래스이름.class`의 형식을 사용한다.

클래스 객체에는 해당 클래스에 대한 모든 정보를 가지고 있는데, 애너테이션의 정보도 포함되어 있다.  
클래스 객체가 가지고 있는 getAnntation()이라는 메서드에 매개변수로 정보를 얻고자 하는 애너테이션을 지정하거나, getAnnotations()로 모든 애너테이션을 배열로 받아올 수 있다.
```java
TestInfo anno = (TestInfo) cls.getAnnotation(TestInfo.class);
System.out.println("anno.testedBy() = " + anno.testedBy());

// AnnotationEx5에 적용된 모든 애너테이션을 가져온다.
Annotation[] annoArr = cls.getAnnotations();
```

