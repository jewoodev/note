# 1. 객체지향언어
## 1.1 객체지향언어의 역사
컴퓨터의 발전으로 활용 폭이 넓고 다양해졌지만, 초창기에는 주로 과학 실험이나 미사일 발사 실험같은 모의실험을 목적으로 사용되었다. 이 시절의 과학자들은 모의 실험을 위해 **실제 세계와 유사한 가상 세계를 컴퓨터 속에 구현**하려고 노력했으며, 그러한 노력은 객체지향이론을 탄생시켰다.

객체지향이론의 기본 개념은 "실제 세계는 사물(객체)로 이루어져 있으며, 발생하는 모든 사건들은 사물 간의 상호작용이다." 라는 것이다. 실제 사물의 속성과 기능을 분석한 다음, 변수와 함수로 정의함으로써 실제 세계를 컴퓨터 속에 옮겨 놓은 것과 같은 가상 세계를 구현하고 이 가상세계에서 모의실험을 함으로써 많은 시간과 비용을 절약할 수 있었다.

객체지향이론은 상속, 캡슐화, 추상화 개념을 중심으로 점차 구체적으로 발전되었으며 1960년대 중반에 객체지향이론을 프로그래밍언어에 적용한 시뮬라라는 최초의 객체지향언어가 탄생하였다. 그 당시에는 FORTRAN이나 COBOL과 같은 절차적 언더들이 주류를 이루었으며, 객체지향언어는 널리 사용되지 못하고 있었다. 1980년대 중반에 C++을 비롯한 여러 객체지향언어가 발표되면서부터 객체지향언어가 본격적으로 개발자들의 관심을 끌기 시작했지만 여전히 사용자층이 넓지 못했다.

그러나 프로그램의 규모가 점점 커지고 사용자들의 요구가 빠르게 변화해가는 상황을 절차적 언어로는 극복하기 어렵다는 한계를 느끼고 객체지향언어를 이용한 개발방법론이 대안으로 떠오르게 되면서 조금씩 입지를 넓혀가고 있었다. 자바가 1995년 발표되고 1990년대 말에 인터넷의 발전과 함께 크게 유행하면서 객체지향언어는 프로그래밍언어의 주류로 자리잡는다.

## 1.2 객체지향언어
객체지향언어는 기존의 프로그래밍 언어에 몇 가지 새로운 규칙을 추가한, 보다 발전된 형태의 언어이다. 규칙들을 이용해 코드 간에 관계를 형성함으로써 더 유기적으로 프로그램을 구성하는 것이 가능해졌다. 객체지향언어의 주요특징은 다음과 같다.

1. 코드의 재사용성이 높다.
    - 새로운 코드를 작성할 때 기존의 코드를 이용해 쉽게 작성할 수 있다.
2. 코드의 관리가 용이하다.
    - 코드 간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있다.
3. 신뢰성 높은 프로그래밍을 가능하게 한다.
    - 제어자와 메서드를 이용해 데이터를 보호하고 올바른 값을 유지하도록 하며, 코드의 중복을 제거해서 '코드의 불일치'로 인한 오동작을 방지할 수 있다.


# 2. 클래스와 객체
클래스는 '객체를 정의해놓은 것' 또는 '객체의 설계도 또는 틀'이라고 정의할 수 있다. 클래스는 객체를 생성하는데 사용되며, 객체는 클래스에 정의된 대로 생성된다.

객체의 사전적 정의는 '실제로 존재하는 것'이다. 책상, 의자, 자동차와 같은 사물들이 곧 객체이며 그 뿐만 아니라 개념이나 논리와 같은 무형적인 것들도 객체지향이론에서는 객체로 간주한다.

프로그래밍에서의 객체는 클래스에 정의된 대로 메모리에 생성된 것을 뜻한다.

클래스를 정의하고 클래스로 객체를 생성하는 이유는 설계도를 통해서 제품을 만드는 이유와 같다. 설계도를 한 번만 잘 만들면 제품을 만들 때마다 고민할 필요 없어지며, 복잡한 제품일수록 설계도 없이 제품을 만드는 게 어려워질 것이다.

## 2.3 객체의 구성요소 - 속성과 기능
객체는 속성과 기능, 두 종류의 구성요소로 이루어져 있다. 즉, 객체는 속성과 기능의 집합이라고 할 수 있다. 그리고 객체가 가지고 있는 속성과 기능을 그 객체의 멤버(구성원, member)라고 한다.

속성과 기능은 아래와 같이 같은 뜻의 여러 가지 용어가 있다.

- 속성(property): 멤버 변수(member variable), 특성(attribute), 필드(field), 상태(state)
- 기능(function): 메서드(method), 함수(function), 행위(behavior)

## 2.6 클래스의 또 다른 정의
클래스는 '객체를 생성하기 위한 틀'이며 '클래스는 속성과 기능으로 정의되어있다.'고 했다. 이것은 객체지향이론의 관점에서 내린 정의이고, 프로그래밍적인 관점에서의 정의와 의미를 살펴보자.

### 데이터와 함수의 결합
데이터와 함수는 서로 관계가 없는 것처럼 데이터는 데이터끼리 함수는 함수끼리 따로 다루어지지만, 함수는 주로 데이터를 가지고 작업을 하기 때문에 많은 경우에 있어서 데이터와 함수의 관계는 깊다. 그래서 자바와 같은 객체지향언어에서는 변수(데이터)와 함수를 하나의 클래스에 정의해 서로 관계가 깊은 변수와 함수들을 함께 다룰 수 있게 했다.

서로 관련된 변수들을 정의하고 그 것들에 대한 작업을 수행하는 함수들을 함께 정의한 것이 바로 클래스이다. C언어에서는 문자열을 문자의 배열로 다루지만, 자바에서는 String 이라는 클래스로 문자열을 다룬다. 문자열을 단순히 문자의 배열로 정의하지 않고 클래스로 정의한 이유는 '문자열'과 '문자열을 다루는데 필요한 함수들'을 함께 묶기 위해서이다. 그렇게 데이터와 함수를 묶으면 작업이 간단하고 명료해진다.

### 사용자정의 타입
프로그래밍 언어에서 제공하는 자료형 외에 프로그래머가 서로 관련된 변수들을 묶어서 하나의 타입으로 새로 추가하는 걸 사용자정의 타입(user-defined type)이라고 한다.

다른 프로그래밍 언어에서도 사용자정의 타입을 정의할 수 있는 방법을 제공하고 있으며 자바와 같은 객체지향언어에서는 클래스가 곧 사용자 정의 타입이다.

시간을 표현하기 위해 `int hour`, `int minute`, `float second`를 선언했다고 가정하자. 만일 세 개의 시간을 다뤄야 한다면 다음과 같이 해야할 것이다.

```java
int hour1, hour2, hour3;
        int minute1, minute2, minute3;
        float second1, second2, second3;
```
이렇게 기본형으로 정의하기만 한다면 '다뤄야 하는 시간의 갯수'가 늘어날 때마다 시분초를 위한 변수를 추가해줘야 하기에 큰 비용이 드는 문제가 생긴다.

```java
int[] hour = new int[3];
int[] minute = new int[3];
float[] second = new float[3];
```
위와 같이 배열로 처리하면 '다뤄야 하는 시간의 갯수'가 늘어나더라도 배열의 크기만 변경해주면 되지만, 시분초가 서로 분리되어 있기 때문에 프로그램 수행과정에서 시, 분, 초가 따로 뒤섞여서 올바르지 않은 데이터가 될 가능성이 생긴다. 따라서 시분초를 하나로 묶는 사용자정의 타입, 즉 클래스를 정의해 사용해야 한다.


# 3. 변수와 메서드
## 3.1 선언 위치에 따른 변수의 종류
변수는 클래스 변수, 인스턴스 변수, 지역 변수, 이렇게 세 가지가 있다. 이런 변수의 종류를 결정짓는 중요한 요소는 '변수가 선언된 위치'이다. 멤버 변수를 제외한 나머지 변수들은 모두 지역 변수이며, 멤버 변수 중 static이 붙은 것은 클래스 변수, 붙지 않은 것은 인스턴스 변수이다.

### 인스턴스 변수
클래스 영역에 선언되며, 클래스의 인스턴스를 생성할 때 만들어진다. 그렇기 때문에 인스턴스 변수의 값을 읽어 오거나 저장하기 위해서는 먼저 인스턴스를 생성해야 한다.

인스턴스는 독립적인 저장 공간을 가지므로 서로 다른 값을 가질 수 있다. 따라서 인스턴스마다 고유한 상태를 유지해야하는 속성의 경우, 인스턴스 변수로 선언한다.

### 클래스 변수
인스턴스 변수 앞에 static 제어자를 붙이기만 하면 클래스 변수가 된다. 클래스 변수는 모든 인스턴스가 공통된 저장공간(변수)를 공유하게 된다. 그래서 한 클래스의 모든 인스턴스들이 공통적인 값을 공유해야 하는 속성의 경우, 클래스 변수로 선언한다.

클래스 변수는 인스턴스를 생성하지 않고도 언제라도 바로 사용할 수 있다는 특징이 있다. 이 변수는 클래스가 메모리에 로딩될 때 생성되어 프로그램이 종료될 때까지 유지된다.

### 지역 변수
메서드 내에서 선언되어 메서드 내에서만 사용 가능하며, 메서드가 종료되면 소멸되어 사용할 수 없게 된다. for문 이나 while문의 블럭 내에 선언된 지역 변수는, 지역 변수가 선언된 블럭 내에서만 사용 가능하며, 블럭 안의 로직을 다 수행하고 빠져나오면 소멸되어 사용할 수 없게 된다.

## 3.3 메서드
메서드는 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것이다. 기본적으로 수학의 함수와 유사하며, 어떤 값을 입력하면 이 값으로 작업을 수행해서 결과를 반환한다.

그저 메서드가 작업을 수행하는데에 필요로 하는 값을 넣고 원하는 결과를 얻으면 될 뿐, 이 메서드가 내부적으로 어떤 과정을 거쳐 결과를 만들어내는지 전혀 몰라도 된다. 그래서 메서드를 내부가 보이지 않는 '블랙박스'라고도 한다.

### 메서드를 사용하는 이유
메서드를 통해 얻는 이점은 여러 가지가 있지만 그 중에 대표적인 세 가지를 살펴보자.

1. 높은 재사용성
    - Java API에서 제공하는 메서드들 처럼 한 번 만들어 놓은 메서드는 몇 번이고 호출할 수 있으며, 다른 프로그램에서도 사용이 가능하다.
2. 중복 코드 제거
    - 중복되는 코드를 묶어서 하나의 메서드로 작성해놓으면, '반복되는 문장들' 대신 '메서드를 호출하는 한 문장'으로 대체할 수 있다. 그러면 전체 소스 코드의 길이가 짧아지고, 변경사항이 생겨났을 때 수정해야 할 코드 양이 줄어들어 오류가 발생할 가능성도 함께 줄어든다. 
3. 프로그램의 구조화
    - 프로덕트가 성장하면 프로그램의 코드 양은 계속해서 커지는데, 몇 만 줄이 넘는 프로그램의 코드를 메인 메소드에 모두 넣을 수는 없다. 큰 규모의 프로그램에서는 문장들을 '작업 단위'로 나눠서 여러 개의 메소드에 담아 프로그램의 구조를 단순화시키는 것이 필수적이다. 

## 3.4 메서드의 호출
### 메서드의 실행 흐름
같은 클래스 내의 메서드끼리는 참조변수를 사용하지 않고도 서로 호출이 가능하지만 static 메서드는 같은 클래스 내의 인스턴스 메서드를 호출할 수 없다.

### 매개변수의 유효성 검사
메서드를 작성하는 사람은 '호출하는 쪽에서 알아서 적절한 값을 넘겨주겠지.'와 같은 생각을 절대로 가져서는 안 된다. 타입만 맞으면 어떤 값도 매개변수를 통해 넘어올 수 있기 때문에, 가능한 모든 경우의 수에 대해 고민하고 그에 대비한 코드를 작성해야 한다.

아래에 정의된 메서드 divide는 두 매개변수를 가지고 나눈 결과를 float 타입으로 반환하는데, 0으로 나눠지도록 인자로 값이 주어지면 `Error`가 발생되며 프로그램이 종료되기 때문에, 즉 처리 불가능하기 때문에 나누기 전에 0이 연산자 값으로 들어왔는지 확인해야 한다. 

```java
float divide(int x, int y) {
    if (y == 0) {
        System.out.println("0으로 나눌 수 없다.");
        return 0; 
    }
    
    return x / y;
}
```

## 3.11 클래스 메서드(static 메서드)와 인스턴스 메서드
변수와 동일하게 static 제어자가 붙은 메서드는 클래스 메서드이며 붙어 있지 않으면 인스턴스 메서드이다.

클래스 메서드도 클래스 변수처럼, 인스턴스를 생성하지 않고도 `클래스이름.메서드이름(매개변수)` 와 같은 식으로 호출이 가능하다. 반면 인스턴스 메서드는 반드시 인스턴스를 생성한 후에만 호출이 가능하다.

클래스 메서드는 인스턴스와 관계 없는, 즉 인스턴스 변수나 인스턴스 메서드를 사용하지 않는 메서드로써 정의된다. 물론 인스턴스 변수를 사용하지 않는다고 해서 반드시 클래스 메서드로 정의해야 하는 것은 아니지만 특별한 이유가 없는 한 그렇게 하는 것이 일반적이다.

# 4. 오버 로딩
메서드도 변수와 마찬가지로 같은 클래스 내에서 서로 구별될 수 있어야 하기 때문에 각각 다른 이름을 가져야 한다. 그러나 자바에서는 한 클래스 내에 이미 사용하려는 이름과 같은 메서드가 있어도 매개변수의 개수 또는 타입이 다르면, 같은 이름을 사용해서 메서드를 정의할 수 있다. 

그렇게 한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것을 '메서드 오버 로딩' 혹은 '오버 로딩'이라고 한다.

## 4.2 오버 로딩의 조건
같은 이름의 메서드를 정의한다고 해서 무조건 오버 로딩이 성립하는 것은 아니다. 성립하기 위해서는 다음과 같은 조건들을 만족해야 한다.

1. 메서드 이름이 같아야 한다.
2. 매개변수의 개수 또는 타입이 달라야 한다.

위 조건을 만족시키지 않는 메서드는 중복 정의로 간주되어 컴파일 시에 에러가 발생한다. 그리고 오버 로딩된 메서드들은 매개변수에 의해서만 구별될 수 있으므로 **반환 타입은 오버 로딩을 구현하는데에 아무런 영향을 주지 못한다**는 것에 주의하자.

## 4.5 가변 인자(varargs)와 오버 로딩
기존에는 메서드의 매개변수 개수가 고정적이었으나 JDK 1.5부터 동적으로 지정해줄 수 있게 되었으며, 이 기능을 가변 인자(variable arguments)라고 한다.

가변 인자는 `타입... 변수명`과 같이 선언한다. 만약 가변 인자 외에 다른 매개변수가 더 있다면, 가변 인자를 매개 변수 중에서 제일 마지막(오른쪽) 위치에서 선언해야 한다. 그렇지 않으면, 컴파일 에러가 발생한다. 그 이유는 가변 인자인지 아닌지 여부를 구별할 방법이 없기 때문이다. 

가변 인자는 내부적으로 배열을 이용한다. 그래서 가변 인자가 선언된 메서드를 호출할 때마다 배열이 새로 생성된다. 가변 인자가 편리하지만, 이런 비효율이 숨겨져 있으므로 꼭 필요한 경우에만 사용하는 걸 권장한다.

그럼 배열과 가변 인자는 무슨 차이가 있는 걸까?

매개변수 타입을 배열로 하면 반드시 인자를 지정해줘야 하기 때문에 인자를 생략할 수 없다. 그에 반해 가변 인자는 생략이 가능하다.

가변 인자를 호출할 때와 오바라이딩할 때 주의할 점이 있다. 호출할 때는 인수로 `new` 없이 배열을 생성(ex. `{"100", "200"}`)하여 지정할 수 없다. 그리고 가변인자를 선언한 메서드를 오버라이딩하면, 메서드 호출 시 구별되지 않아 문제가 생기는 일이 쉽게 생겨나기 때문에 가능하면 가변 인자는 오버 로딩을 하지 않는 것이 좋다.  

# 5. 생성자
생성자는 인스턴스가 생성될 때 호출되는 '인스턴스 초기화 메서드'이다. 그렇기에 인스턴스 변수의 초기화 작업에 주로 사용되며, 인스턴스 생성 시에 실행되어야 하는 작업을 위해서도 사용된다.

생성자 역시 메서드처럼 클래스 내에 선언되며, 구조도 메서드와 유사하지만 메서드와 다르게 리턴값이 없다. 그렇다고 시그니처에 void 키워드를 사용하지도 않는다. 생성자의 조건은 다음과 같다.

1. '생성자의 이름'은 '클래스의 이름'과 같아야 한다.
2. 생성자는 리턴 값이 없다.

> 생성자도 오버 로딩이 가능해 하나의 클래스에 여러 개의 생성자가 존재할 수 있다.

생성자가 인스턴스를 생성하는 것은 아니며, 인스턴스를 생성하는 건 연산자 new가 한다. 생성자라는 용어 때문에 오해하기 쉬운데, 생성자는 단순히 인스턴스 변수들의 초기화에 사용되는 조금 특별한 메서드일 뿐이다. 생성자가 갖는 몇 가지 특징만 제외하면 메서드와 다르지 않다.

```java
Jewoo j = new Jewoo();
```
위의 코드를 예로 들어 인스턴스 생성 과정을 단계별로 나누어보면 다음과 같다.

1. 연산자 new에 의해 메모리(heap)에 Jewoo 클래스의 인스턴스가 생성된다.
2. 생성자 Jewoo()가 호출되어 수행된다.
3. 연산자 new의 결과로, 생성된 Jewoo 인스턴스의 주소가 반환되어 참조변수 j에 저장된다.

## 5.2 기본 생성자(default constructor)
사실 모든 클래스에는 반드시 하나 이상의 생성자가 정의되어 있어야 한다. 프로그래머가 생성자를 작성하지 않아도 문제가 생기지 않았던 이유는 컴파일러가 기본 생성자를 자동으로 추가하기 때문이다. 컴파일러가 자동으로 추가하는 기본 생성자는 매개변수도 없고 생성자 안에 아무 코드도 없다. 만약 프로그래머가 어떤 종류의 생성자든 작성하면 컴파일러는 기본 생성자를 자동으로 추가하지 않는다.

## 5.4 생성자에서 다른 생성자 호출하기
같은 클래스의 멤버들끼리 호출할 수 있는 것처럼 생성자 간에도 서로 호출하는 것이 가능하다. 다만, 다음의 두 조건을 만족시켜야 가능하다.

- 생성자의 이름으로 클래스이름 대신 this를 사용한다.
- 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.

생성자에서 다른 생성자를 호출하는 것이 첫 줄에서만 가능한 이유는 생성자 내에서 초기화 작업을 수행하는 도중에 다른 생성자를 호출하게 되면, 호출된 다른 생성자 내에서도 멤버변수들의 값을 초기화할 것이므로, 다른 생성자를 호출하기 이전의 초기화 작업이 무의미해질 수 있기 때문이다. 

'this'는 참조변수로, 인스턴스 자신을 가리킨다. 그래서 참조변수를 통해 인스턴스의 멤버에 접근할 수 있는 것처럼 인스턴스 변수에 접근할 수 있다.

하지만, 'this'를 사용할 수 있는 건 인스턴스 멤버뿐이다. 왜냐하면 static 메서드(클래스 메서드)는 인스턴스와는 관계가 없기 때문이다. static 메서드가 호출되는 시점에 인스턴스가 존재하지 않을 수도 있다.

사실 생성자를 포함한 모든 인스턴스 메서드에는 자신이 관련된 인스턴스를 가리키는 참조변수 'this'가 지역변수로 숨겨져 있다. 일반적으로 인스턴스 메서드는 특정 인스턴스와 관련된 작업을 하기 때문에 자신과 관련된 인스턴스의 정보가 필요하기 때문이다. 반면 static 메서드는 인스턴스와 관련 없는 작업을 하며 인스턴스에 대한 정보를 필요로 하지 않는다.  

- this: 인스턴스 자신을 가리키는 참조변수. 인스턴스의 주소가 저장되어 있다. 모든 인스턴스 메서드에 지역변수로 숨겨진 채 존재한다.
- this(), this(매개변수): 같은 클래스의 다른 생성자를 호출할 때 사용한다.

## 5.5 생성자를 이용한 인스턴스의 복사
어떤 인스턴스와 같은 상태를 갖는 인스턴스를 생성자로 만들 수 있다. 

인스턴스마다 다른 값을 가질 수 있는 건 인스턴스 변수 뿐이다. 이를 이용해 다음과 같은 생성자를 만들 수 있다.

```java
class Jewoo {
    String name;
    int age;
    
    Jewoo(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    Jewoo(Jewoo j) { // 인스턴스를 복사하는 생성자
        this.name = j.name;
        this.age = j.age;
    }
}
```
이 방법을 통한 복사는 옅은 복사이므로, 원본 객체의 상태가 변경되어도 복사본은 영향을 받지 않는다. 

다만 위의 방법보다 `Jewoo(String name, int age)`를 호출하는 방법이 더 바람직하다. 무작정 새로 코드를 작성하는 것보다 기존의 코드를 활용할 수 있기 때문이다.

```java
class Jewoo {
    String name;
    int age;
    
    Jewoo(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    Jewoo(Jewoo j) { // 인스턴스를 복사하는 생성자
        this(j.name, j.age);
    }
}
```

