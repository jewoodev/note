# 운영체제의 심장, 커널
운영체제가 응용 프로그램에 제공하는 서비스는 다양하지만, 그중에서도 가장 핵심적인 서비스들이 있다. 바로 자원에 접근하여 조작하는 기능, 프로그램이 올바르고 안전하게 실행되게 하는 기능이다. 이런 핵심적인 서비스들을 담당하는 운영체제의 한 부분을 **커널**(kernel)이라고 한다.

운영체제가 설치된 모든 기기에는 커널이 있다. 어떤 커널을 사용하는지에 따라 실행되고 개발되는 프로그램이 하드웨어를 이용하는 양상이 달라지고, 컴퓨터 전체의 성능이 달라진다.

운영체제에는 속하지만 커널에 포함되지 않는 것들도 있다. 그러한 것들 중 사용자 인터페이스(UI, User Interface)가 대표적이다. UI는 사용자와 컴퓨터 간의 상호작용을 위한 통로, 수단일 뿐 운영체제가 존재하는 목적, 핵심 기능(커널)은 아니다.

운영체제가 제공하는 사용자 인터페이스 종류는 그래픽 유저 인터페이스(GUI, Graphical User Interface)와 커맨드 라인 인터페이스(CLI, Command Line Interface)가 있다. 

이런 사용자 인터페이스는 운영체제가 제공하는 서비스이지만, 이는 그저 컴퓨터와 상호작용하기 위한 통로일 뿐 커널에 속한 기능은 아니라서 같은 커널을 사용하더라도 사용자 인터페이스는 다를 수 있다.

---

# 이중 모드와 시스템 호출
응용 프로그램이 운영체제의 도움 없이 하드웨어 자원에 마음대로 접근하고 조작할 수 있다면 어떻게 될까?

1. 프로세스 A가 CPU를 쓰고 있는데 B가 쓰려고 해서 충돌이 발생할 수 있다.
2. A가 보조 기억 장치에 정보를 저장한 후, 다시 읽으려 했는데 B가 그 사이에 삭제했을 수 있다.

이렇게 응용 프로그램이 자원에 직접 접근하는 건 위험한 상황을 초래한다. 그래서 운영체제는 응용 프로그램들이 자원에 접근하려고 할 때, 오직 자신을 통해서만 접근하도록 제한함으로써 자원을 보호한다.

응용 프로그램이 하드디스크에 접근해서 데이터를 저장할 때 어떤 과정을 거쳐 해당 작업이 처리되는지 살펴보면,

1. 운영체제에 도움을 요청해야 한다.
2. 도움 요청을 받은 운영체제는 커널 영역 내의 "하드디스크에 데이터를 저장하는 코드"를 실행해 응용 프로그램의 작업을 대신 수행한다.

이런 운영체제의 문지기 역할은 이중 모드로써 구현된다. 이중 모드는 CPU가 명령어를 실행하는 모드를 크게 사용자 모드와 커널 모드로 구분하는 방식이다.

- **사용자 모드**
  - 운영체제 서비스를 제공받을 수 없는, 즉 커널 영역의 코드를 실행할 수 없는 모드
  - 그래서 사용자 모드로 실행되는 프로그램은 자원에 접근할 수 없다.
  - 일반적인 응용 프로그램은 기본적으로 사용자 모드로 실행된다.
- **커널 모드**
  - 운영체제 서버스를 제공받을 수 있는 실행 모드
  - CPU가 커널 모드로 명령어를 실행하면 자원에 접근하는 명령어를 포함한 모든 명령어를 실행할 수 있다.


- CPU의 플래그 레지스터
  - 이 레지스터 안에 슈퍼바이저 플래그가 있다.
    - 현재 커널 모드로 실행 중인지, 사용자 모드로 실행 중인지 나타낸다.
    - 운영체제는 이 플래그 값을 보고 실행하려는 명령어를 실행해도 되는지 여부를 판단한다.

이렇듯 모드에 따라서 커널 영역의 코드 사용을 사용할 수 있는지, 없는지가 달라지기 때문에 사용자 모드로 실행되는 프로그램이 자원에 접근하려면 운영체제에 요청을 보내 커널 모드로 전환되어야 한다. 언제 커널 모드로 바뀔 수 있을까? 바로 **시스템 호출**(System call)을 하면 된다. 시스템 호출을 하면 커널 모드로 전환되어서 커널 영역에 있는 명령어들을 실행할 수 있다.

시스템 호출은 일종의 **인터럽트**이다. 정확하게는 소프트웨어적인 인터럽트이다. 인터럽트는 입출력장치에 의해 발생하기도 하지만 인터럽트를 발생시키는 특정 명령어에 의해 발생하기도 하는데, 이를 **소프트웨어 인터럽트**라고 한다.

- 시스템 콜 또한 인터럽트이기 때문에 처리되는 방식이 하드웨어 인터럽트가 처리되는 방식과 굉장히 유사하다.
  - 하드디스크에 접근해야 할 때
  - 시스템 호출을 하고
  - 하드디스크에 접근하는 코드를 실행하고
  - 시스템 호출에서 복귀해서 기존의 실행 흐름을 이어가듯이

## 시스템 호출 과정
시스템 호출 과정은 다음과 같다.

시스템 호출을 발생시키는 명령어가 실행되면 CPU는 지금까지의 작업을 백업하고, 커널 영역 내에 시스템 호출을 수행하는 코드(인터럽트 서비스 루틴)를 실행한 뒤 다시 기존에 실행하던 응용 프로그램으로 복귀해서 실행을 계속해 나간다.

일반적으로 응용 프로그램은 실행 과정에서 운영체제 서비스들을 매우 빈번하게 이용한다. 그 과정에는 모두 시스템 호출을 발생시키고 사용자 모드와 커널 모드를 오가는 과정이 포함된다.

---

# 운영체제의 핵심 서비스
우리가 실행하는 프로그램이 어떤 도움을 운영체제에게 받는지, 세 가지 핵심 서비스를 꼽아보자면 

1. 프로세스 관리
2. 자원 접근 및 할당
3. 파일 시스템 관리

가 된다고 볼 수 있다.

## 프로세스 관리
- 프로세스 == 실행 중인 프로그램
- 수많은 프로세스들이 동시에 실행
- 기본적으로 프로세스는 모두 메모리에 적재되어 있어야 하지만, 
  - 운영체제의 어떤 기법을 통해 모든 프로세스가 적재되어 있지 않을 수도 있다.
    - 페이징, 스와핑
- 동시다발적으로 실행되고 종료되는 프로세스들을 일목요연하게 관리할 수 있어야 함
  - 실행되는 프로그램을 메모리에 적재하고, 
  - 실행이 끝난 프로세스는 메모리에서 삭제(올바르게 종료)해야 함
- 프로세스의 '현재 상황'이 다양함, 거기에 맞춰 알맞게 관리 필요
  - 특정 입출력 장치를 써야할 수 있고
  - 빨리 CPU를 써야할 수 있고
  - 당장 실행이 불가능할 수 있음

## 자원 접근 및 할당
운영체제가 수행하는 자원 접근 및 할당은 크게 세 가지가 있다.

1. CPU
2. 메모리
3. 입출력장치

### CPU
**CPU 스케줄링**을 통해서 수행한다. CPU 스케줄링은 CPU를 공정하게 사용하도록 **어떤 프로세스를 먼저**, **얼마나 오래** 이용하게 할지를 결정하는 작업이다. 하나의 CPU는 한 번에 하나의 프로세스만 실행할 수 있기 때문에 중요한 역할이다. 

### 메모리(페이징, 스와핑, ...)
1. 새로운 프로세스를 적재할 메모리 공간을 어떻게 찾을 것인지, 효율적인 방법으로 찾는 작업을
2. 실행 중인 프로세스를 모두 메모리에 적재하는 게 효율적인지 확인해보고, 적재할 필요가 없다면 하지 않고 실행시키기 위한 작업을

수행한다. 

메모리에 적재된 프로세스들은 크기와 적재되는 주소가 가지각색이다. 같은 프로세스여도 실행될 때마다 적재되는 주소가 달라질 수 있다. 이렇게 메모리 공간을 효율적으로 사용할 수 있도록 운영체제는 새로운 프로세스를 어디에 적재해야 할지를 결정해야 한다.

어떤 경우에는 메모리가 꽉 차 있어 꼭 실행해야 하는 프로세스를 적재할 수 없을 수 있고, 메모리에 공간이 남아 있는데도 공간의 물리적으로 분리되어 있어 프로세스를 적재할 수 없을 수 있다.

이럴땐 가상 메모리를 사용해서 메모리를 할당한다.

### 입출력장치
운영체제는 인터럽트 서비스 루틴을 제공함으로써 

1. 각각의 응용 프로그램들이 입출력 장치에 접근할 수 있게 해준다.
2. 입출력 장치를 할당한다. 

## 파일 시스템 관리
컴퓨터를 사용할 때 파일을 열고, 생성하고, 삭제하고, 디렉토리에 묶어 관리하는 파일 시스템은 운영체제가 지원하는 핵심 서비스이다. 