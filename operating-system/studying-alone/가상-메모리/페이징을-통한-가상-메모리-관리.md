# 들어가며
- 연속 메모리 할당의 문제점
  - 외부 단편화
  - 물리 메모리보다 큰 프로세스 실행 불가


- 가상 메모리
  - 실행하고자 하는 프로그램의 일부만 메모리에 적재하여 실제 물리 메모리 크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술
  - **페이징**, 세그멘테이션

# 페이징이란?
- 외부 단편화가 발생했던 근본적인 문제?
  - 각기 다른 크기의 프로세스가 메모리에 연속적으로 할당되었기 때문

- 프로세스를 일정한 크기로 자르고, 이를 메모리에 불연속적으로 할당할 수 있다면 어떨까?
- 페이징은 프로세스의 **논리 주소 공간**을 **페이지**라는 일정 단위로 자르고,
- 메모리의 **물리 주소 공간**을 **프레임**이라는 페이지와 동일한 일정 단위로 자른 뒤
- 페이지를 프레임에 할당하는 가상 메모리 기법
  - 페이지가 균일한 크기를 갖기에 외부 단편화가 매우 적어짐

## 페이징에서의 스와핑
- 프로세스 단위가 아닌 페이지 단위의 스왑-인(페이지-인), 스왑-아웃(페이지-아웃)
- 메모리에 적재될 필요가 없는 페이지들은 보조기억장치로 페이지-아웃
- 실행에 필요한 페이지들은 페이지-인

이 기술은 다음과 같은 내용을 시사함

- 어떤 프로세스가 실행되기 위해선 모든 페이지가 꼭 메모리에 저장되어 있어야 하는 것이 아님
- 일부 페이지는 보조기억장치의 스왑 영역에 있어도 실행할 수 있음


- 프로세스가 페이징이 되었다면 CPU가 '페이지가 어느 프레임에 적재되어 있는지'를 알아야 함
  - CPU 자체적으로 이를 알고 있기는 어려움
  - 그렇기 때문에 CPU는 순차적으로 프로세스를 실행하기 어려울 것

## 페이지 테이블
- (실제 메모리 내의 주소인) 물리 주소에 불연속적으로 배치되더라도
- (CPU가 바라보는 주소인) 논리 주소에는 연속적으로 배치되도록 하는 방법
- 페이지 번호와 프레임 번호를 짝지어 주는 일종의 이정표
- 프로세스마다 페이지 테이블이 있음

## 내부 단편화
- 페이지 크기가 10KB, 프로세스 크기 108KB?
- 2KB: 내부 단편화
- 하나의 페이지 크기보다 작은 크기로 발생

---

# PTBR
- 프로세스마다 페이지 테이블이 있고,
- 각 페이지 테이블은 CPU 내의 **프로세스 테이블 베이스 레지스터**(PTBR)가 가리킨다.
- 프로세스의 페이지 테이블 각각이 어디에 있는지 나타내기 위해 사용되는 레지스터


- 그런데, 페이지 테이블이 메모리에 있으면? 메모리 접근 시간 두배로
  - 페이지 테이블 참조하기 위해 한 번
  - 페이지 참조하기 위해 한 번
- 그래서 페이지 테이블이 메모리에 저장되어 있는 게 효율적인 방식이 아닐 수 있음

# TLB
- CPU 곁에 페이지 테이블의 캐시 메모리
- 페이지 테이블의 일부를 가져와 저장
- 자주 참조하는 페이지가 있는 경우 효율이 높아짐, 불필요한 메모리 접근을 줄일 수 있음


- CPU가 접근하려는 논리 주소가 TLB에 있다면? TLB 히트
  - 메모리 접근 한 번
- CPU가 접근하려는 논리 주소가 TLB에 없다면? TLB 미스
  - 메모리 접근 두 번

---

# 페이징에서의 주소 변환
- 특정 주소에 접근하고자 한다면 어떤 정보가 필요할까?
  - 어떤 페이지/프레임에 접근하고 싶은지
  - 접근하려는 주소가 그 페이지 혹은 프레임으로부터 얼마나 떨어져 있는지


- 그래서 페이징 시스템에서의 논리 주소는
  - 페이지 번호와 변위(offset), 두 가지 정보로 이루어짐
- **<페이지 번호, 변위>**로 이루어진 논리 주소는
  - 페이지 테이블을 통해 **<프레임 번호, 변위>**로 변환됨
    - 두 변위는 같음
    - 페이지와 프레임의 크기는 같기 때문

# 페이지 테이블 엔트리
- 페이지 테이블의 각각의 행
- 줄여서 PTE라고 부름
- 페이지 번호, 프레임 번호 말고 담기는 정보가 또 다른게 있음
  - 유효 비트
    - 현재 해당 페이지에 접근 가능한지 여부
    - 유효 비트가 0인 페이지에 접근하려고 하면?
      - 페이지 폴트라는 인터럽트가 발생
        1. CPU는 기존의 작업 내역을 백업
        2. 페이지 폴트 처리 루틴을 실행
           - 페이지 폴트 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤 유효 비트를 1로 변경함
           - 페이지 폴트를 처리했다면 CPU가 해당 페이지에 접근 가능
  - 보호 비트
    - 페이지 보호 기능을 위해 존재하는 비트
    - 프로세스의 코드 영역은 read-only 이기에 보호 비트의 쓰기 비트를 0으로 설정
      - 권한 별로 비트 값으로 가능 여부를 명시
  - 참조 비트
    - CPU가 이 페이지에 한 번이라도 접근한 적이 있는지 여부
  - 수정 비트 (= dirty bit)
    - CPU가 이 페이지에 데이터를 쓴 적이 있는지 여부
    - 존재 이유?
      - 페이지가 스왑-아웃될 때 보조기억장치에 쓰기 작업을 해야 하는지 판단하기 위함