# 쓰기 시 복사
- 이론적인 fork()
  - 프로세스는 기본적으로 자원을 공유하지 않음
    - 부모 프로세스가 적재된 별도의 공간에 자식 프로세스가 통째로 복제되어 적재 
  - 단점: 프로세스 생성 지연 시간, 메모리 낭비
- 쓰기 시 복사
  - 부모 프로세스와 동일한 자식 프로세스가 복제되어 생성되면
  - 자식 프로세스는 부모 프로세스와 **동일한 프레임**을 가리킴(쓰기 작업 없다면 이 상태 유지)
  - 부모/자식 프로세스 둘 중 하나가 페이지에 쓰기 작업 수행 시, 해당 페이지는 별도의 공간으로 복제
  - 장점: 프로세스 생성 시간 절약, 메모리 절약

# 계층적 페이징
- 프로세스를 이루는 모든 페이지 테이블 엔트리를 메모리에 두는 것은 낭비
- 따라서, 엔트리를 메모리에 유지하지 않을 방법이 필요
- 그 방법이 계층적 페이징
  - 다단계 페이지 테이블이라고도 부름


- **페이지 테이블을 페이징**하여 여러 단계의 페이지를 두는 방식
  - 페이지 테이블을 여러 페이지로 쪼개고 이 페이지를 가리키는 페이지 테이블(Outer 페이지 테이블)을 두는 방식
- 모든 페이지 테이블을 항상 메모리에 둘 필요가 없어짐
  - CPU와 가장 가까이에 위치한 페이지 테이블(Outer 페이지 테이블)은 항상 메모리에 유지


- 계층적 페이징을 이용하는 환경의 논리 주소 $\Rightarrow$ 물리 주소로 변환
  - `논리 주소 = [외부 페이지 번호 | 내부 페이지 번호 | 오프셋]` 형태를 띄고
  - 변환 과정 (2단계 페이징 예시)
    - 1단계: 외부 페이지 테이블 접근
      - PTBR이 외부 페이지 테이블의 시작 주소를 가리킴
      - 논리 주소의 외부 페이지 번호를 인덱스로 사용
      - 해당 엔트리에서 내부 페이지 테이블의 물리 주소를 얻음
    - 2단계: 내부 페이지 테이블 접근
      - 1단계에서 얻은 주소 + 내부 페이지 번호로 접근
      - 해당 엔트리에서 실제 프레임 번호를 얻음
    - 3단계: 물리 주소 계산
      - 물리 주소 = 프레임 번호 × 페이지 크기 + 오프셋
- 계층은 3, 4... 늘어날 수 있지만 많으면 많을수록 페이지 폴트 발생 시 메모리 참조가 많이 발생한다는 단점이 있음
