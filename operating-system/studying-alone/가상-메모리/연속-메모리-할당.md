# 들어가며
- 연속 메모리 할당: 프로세스에 연속적인 메모리 공간을 할당
  - 가장 기본적인 메모리 관리 방식

# 스와핑
- 운영체제가 메모리를 관리하는 아주 기본적인 기능
- 현재 사용되지 않는 프로세스들을 '보조기억장치의 일부 영역(스왑 영역)'으로 쫓아내고(스왑-아웃)
  - 스왑-아웃 되었던 프로세스가 다시 메모리로 적재되는 것을 스왑-인이라고 부름
- 그렇게 생긴 빈 공간에 새 프로세스 적재
- 스와핑을 이용하여 다음과 같은 경우에도 프로세스들을 동시에 실행할 수 있음
  - 프로세스들이 요구하는 메모리 공간 크기 > 실제 메모리 크기
  - 실제 메모리보다 큰 프로세스들을 동시에 실행할 수 있게 됨
- 스왑 영역 크기 확인하기: free, top 명령어

# 연속 메모리 할당
- 프로세스는 메모리의 빈 공간에 할당되어야 한다.. 그런데 빈 공간이 여러 개 있다면?
  - 연속 메모리 할당 방식에 최초 적합, 최적 적합, 최악 적합 세 가지 방식이 있음


- First-Fit 
  - 운영체제가 메모리 내의 빈 공간을 순서대로 검색하다 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식
  - 검색 최소화, 빠른 할당
- Best-Fit
  - 운영체제가 빈 공간을 모두 검색해본 뒤, 적재 가능한 가장 작은 공간에 할당
- Worst-Fit
  - 운영체제가 빈 공간을 모두 검색해본 뒤, 적재 가능한 가장 큰 공간에 할당

## 외부 단편화
- 사실, 프로세스를 연속적으로 메모리에 할당하는 방식은 메모리를 효율적으로 사용하는 방법이 아니다.
- 외부 단편화(external fragmentation)이라는 문제가 발생하기 때문


- 사용자 영역이 200MB일 때
  - 크기가 50MB인 프로세스 A
  - 30MB인 프로세스 B
  - 100MB인 프로세스 C
  - 20MB인 프로세스 D를 차례대로 적재해야 한다면?
    - A,B,C,D 연속적으로, 차례대로 적재하면 될 것이다.
    - B,D 프로세스가 실행이 끝나면 빈 공간이 50MB 생김(나뉘어진 두 개의 공간) 
      - 빈 공간이 50MB 일지라도 50MB 크기의 프로세스는 적재될 수 없음

- 프로세스들이 실행되고 종료되길 반복하며 메모리 사이 사이에 빈 공간이 발생
- **외부 단편화**
  - 프로세스를 할당하기 어려울만큼 작은 메모리 공간들이 생겨 메모리가 낭비되는 현상

### 해결법: 메모리 압축(compaction)
- 여기저기 흩어져 있는 빈 공간들을 하나로 모으는 방식
- 프로세스들을 적당히 재배치시켜 흩어져 있는 빈 공간들을 하나의 큰 빈 공간으로 만드는 방법
- 부작용
  - 프로세스들을 재배치 하는 과정에서의 오버헤드
    - 그 과정동안 자기가 해야할 일을 제대로 하지 못함

## 해결법: 가상 메모리 기법, 페이징
- 메모리 압축보다 부작용이 덜하며 현대 운영체제가 사용하는 가장 대중적인 방식