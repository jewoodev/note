# 들어가며
- 물리 메모리보다 큰 프로세스를 실행할 수 있지만,
- 그럼에도 물리 메모리의 크기는 한정되어 있다


- 기존에 적재된 '불필요한 페이지'를 선별해 보조기억장치로 내보내고
  - 이 문제를 해결할 수 있는 방법 $\Rightarrow$ 페이지 교체 알고리즘
- 프로세스들에게 적절한 수의 프레임을 할당할 수 있어야 함
  - 이 문제를 해결할 수 있는 방법 $\Rightarrow$ 프레임 할당

# 요구 페이징
- 처음부터 모든 페이지를 적재하지 않고 필요한 페이지만 메모리에 적재하는 기법
- **요구되는 페이지만** 적재하는 기법
- 요구 페이징이 실행되는 기본적인 양상
  1. CPU가 특정 페이지에 접근하는 명령어를 실행
  2. 해당 페이지가 현재 메모리에 있을 경우(유효 비트가 1일 경우) CPU는 페이지가 적재된 프레임에 접근
  3. 해당 페이지가 현재 메모리에 없을 경우(.. 0일 경우) 페이지 폴트 발생
     - 페이지 폴트 처리 루틴은 해당 페이지를 메모리에 적재하고 유효 비트를 1로 설정
  4. 다시 1번 수행

> ## 순수 요구 페이징
> - 어떤 페이지도 적재하지 않고 프로세스를 실행하는 기법
> - 처음엔 페이지 폴트가 빈번하게 발생 $\Rightarrow$ 갈수록 적게 발생

# 페이지 교체 알고리즘
- 요구 페이징 기법으로 페이지를 적재하다보면 언젠가 메모리가 가득 차게 됨
- 당장 실행에 필요한 페이지를 적재하려면 적재된 페이지를 보조기억장치로 내보내야 함
- 이때, 어떤 페이지를 내보내야 할까? 를 결정하는 알고리즘이 페이지 교체 알고리즘

- 무엇이 좋은 페이지 교체 알고리즘일까?
  - 페이지 폴트가 적은 알고리즘!
    - 페이지 폴트가 발생하면 보조기억장치에 접근해야 해서 성능 저하
  - 페이지 폴트 횟수는 어떻게 알 수 있을까?
    - 페이지 참조열(page reference string)
      - CPU가 참조하는 페이지들 중 연속된 페이지를 생략한 페이지열

## FIFO 페이지 교체 알고리즘
- 가장 단순한 방식
- 메모리에 가장 먼저 올라온 페이지부터 내쫓는 방식
- "오래 머물렀다면 나가라."


- 프로그램 실행 초기에 잠깐 필요한 페이지
  - FIFO로 처리되어도 적합
- 프로그램 실행 내내 사용될 페이지
  - 먼저 적재되었다고 해서 내쫓아선 안됨
- 그래서 성능이 좋지 못함

## 2차 기회(second-chance) 페이지 교체 알고리즘
- FIFO 페이지 교체 알고리즘 보완책
- 참조 비트 1: CPU가 한 번이라도 참조한 적이 있는 페이지 / 0: 참조 한번도 X
- 참조 비트 1: 한 번 더 기회를 줌(참조 비트를 0으로 초기화 후 적재 시간을 현재 시간으로 설정)
- 참조 비트 0: 내쫓기

## 최적 페이지 교체 알고리즘
- CPU에 의해 참조되는 횟수를 고려
- 메모리에 오래 남아야 할 페이지는 자주 사용될 페이지
- 메모리에 없어도 될 페이지는 오랫동안 사용될 페이지
- 앞으로의 사용 빈도가 가장 낮은 페이지를 교체하는 알고리즘


- 가장 낮은 페이지 폴트율을 보장하는 알고리즘
  - 하지만, 구현이 어려움
  - "앞으로 사용 빈도가 가장 낮은 페이지를 예측할 방법이 모호"
  - 다른 페이지 교체 알고리즘 성능을 평가하기 위한 하한선으로 간주

## LRU(Least-Recently-Used) 페이지 교체 알고리즘
- 최적 페이지 교체 알고리즘: 가장 오래 사용되지 **않을** 페이지 교체
- LRU 페이지 교체 알고리즘: 가장 오래 사용되지 **않은** 페이지 교체
  - "최근에 사용되지 않은 페이지는 앞으로도 사용되지 않지 않을까?"

---

# 스래싱과 프레임 할당
- 페이지 폴트가 자주 발생하는 이유
  - 나쁜 페이지 교체 알고리즘을 사용해서
  - 프로세스가 사용할 수 있는 프레임 자체가 적어서


- 스래싱
  - 프로세스가 실행되는 시간보다 페이징에 더 많은 시간을 소요해서 성능(CPU 이용률)이 저해되는 문제
  - 동시 실행되는 프로세스의 수를 늘린다고 CPU 이용률이 높아지는 것이 아니다
    - '멀티 프로그래밍의 정도'를 계속해서 높이면 CPU 이용률이 점점 올라가다가, 어느 기점부터 급격히 떨어진다.
      - 그 기점부터 스래싱이 발생하는 것
      - 멀티 프로그래밍의 정도: 메모리에 적재되어 동시에 실행되는 프로세스의 수
  - 각 프로세스가 필요로 하는 최소한의 프레임 수가 보장되지 않았기 때문에 발생
    - 각 프로세스가 필요로 하는 최소한의 프레임 수를 파악하고 프로세스들에게 적절한 프레임을 할당해야 함


- 균등 할당(equal allocation)
  - 가장 간단한 할당 방식
  - 모든 프로세스들에게 균등하게 프레임을 할당


- 비례 할당(proportional allocation)
  - 프로세스의 크기를 고려하여 프레임을 할당하는 방식
  - 크기가 큰 프로세스인데 막상 실행해보니 많은 프레임을 필요로 하지 않으면?
  - 크기가 작은 프로세스인데 막상 실행해보니 많은 프레임을 필요로 하면?
    - 결국 프로세스가 필요로 하는 프레임 수는 **실행해봐야 암**

> 균등/비례 할당은 프로세스의 실행 과정을 고려하지 않고 프로세스의 크기나 물리메모리의 크기만을 고려한 할당 방식이라는 점에서 **정적 할당 방식**이라고도 부름

- 작업 집합 모델
  - 프로세스를 실행하는 과정에서 배분할 프레임을 결정
  - 스레싱이 발생하는 이유는 빈번한 페이지 교체 때문
    - 그렇다면 CPU가 특정 시간동안 주로 참조한 페이지 개수만큼만 프레임을 할당하면 됨 
  - '프로세스가 일정 기간동안 참조한 페이지 집합'을 기억해서 빈번한 페이지 교체를 방지
    - **작업 집합**이란 '실행 중인 프로세스가 일정 기간동안 참조한 페이지의 집합'
  - 작업 집합을 구하려면
    1. 프로세스가 참조한 페이지
    2. 시간 간격이 필요


- 페이지 폴트 빈도 기반의 프레임 할당 방식
  - 프로세스가 실행되는 과정에서 배분할 프레임을 결정
  - 두 개의 가정에서 생겨난 아이디어
    1. 페이지 폴트율이 너무 높으면 그 프로세스는 너무 적은 프레임을 갖고 있다
    2. 페이지 폴트율이 너무 낮으면 그 프로세스는 너무 많은 프레임을 갖고 있다
  - 페이지 폴트율의 상한선과 하한선을 정하고, 그 내부 범위 안에서만 프레임을 할당하는 방식

> 작업 집합 모델 기반의 프레임 할당 방식과 페이지 폴트 기반의 방식은 모두 프로세스가 실행되는 과정을 통해, 실행되는 과정을 관찰함으로써 프레임을 할당한다는 점에서 **동적 할당 방식**이라고도 부름