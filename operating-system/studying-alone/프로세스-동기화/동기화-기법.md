# 뮤텍스 락
- 상호 배제를 위한 동기화 도구(자물쇠 역할)
- 뮤텍스 락의 단순한 형태
  - 전역 변수 하나, 함수 두 개
  - 자물쇠 역할: 프로세스들이 공유하는 전역 변수 lock
  - 임계 구역을 잠그는 역할: acquire 함수
  - 임계 구역의 잠금을 해제하는 역할: release 함수

```
acquire() {
    while (lock == true)    /* 만약 임계 구역이 잠겨 있다면 */
    ;                       /* 임계 구역이 잠겨 있는지를 반복적으로 확인 */
    lock = true;
}

release() {
    lock = false;           /* 임계 구역 작업이 끝났으므로 잠금 해제 */
}
```

- 바쁜 대기(busy waiting)
  - 무한히 대기하면서 임계 구역이 열려 있는지 반복적으로 확인하는 꼴이 탈의실 문이 잠겨 있는지 아닌지 쉴새없이 확인하는 것과 같아 이름붙여짐
  - 뮤텍스 락을 부르는 다른 이름이기도 함

# 세마포
- 좀 더 일반화된 방식의 동기화 도구
- 공유 자원이 여러 개 있는 경우에도 적용 가능
- 열차 신호기(or 철도 신호기)에 빗댈 수 있음
  - 임계 구역 앞에서 멈춤 신호를 받으면 잠시 기다리기
  - 임계 구역 앞에서 가도 좋다는 신호를 받으면 임계 구역 진입

> 세마포의 종류(이진 세마포, 카운팅 세마포) 중 여기선 카운팅 세마포를 말함

## 세마포의 단순한 형태
전역 변수 하나, 함수 두 개

- 임계 구역에 진입할 수 있는 프로세스의 개수(사용 가능한 공유 자원의 개수)를 나타내는 전역 변수 S
- 임계 구역에 진입해도 좋은지, 기다려야 하는지를 알려주는 wait 함수
- 임계 구역 앞에서 기다리고 있는 프로세스에게 "이제 가도 좋다."고 신호를 주는 signal 함수

```
wait() {
    while (S <= 0)    /* 만일 임계 구역에 진입할 수 있는 프로세스 개수가 0 이하라면 */
    ;                 /* 사용할 수 있는 자원이 있는지 반복적으로 확인하고 */
    S--;              /* 임계 구역에 진입할 수 있는 프로세스 개수가 하나 이상이면 S를 감소시키고 임계 구역 진입 */
}

signal() {
    S++;              /* 임계 구역에서의 작업을 마친 뒤 S를 1 증가시킨다 */ 
}
```

- 이 것도 busy waiting이라고 할 수 있음
  - 이는 비효율적!
- 실제로는 다른 방법으로 구현
  - 사용할 수 있는 자원이 없을 경우 **대기 상태**로 만듬
    - 해당 프로세스의 PCB를 대기 큐에 삽입
  - 사용할 수 있는 자원이 생겼을 경우 대기 큐의 프로세스를 **준비 상태**로 만듬
    - 해당 프로세스의 PCB를 대기 큐에서 꺼내 준비 큐로 삽입

busy waiting을 해결한 방식의 수도코드는 다음과 같다.

```
wait() {
    S--;
    if (S < 0) {     
        add this process to Queue;      /* 해당 프로세스의 PCB를 대기 큐에 삽입한다 */
        sleep();                        /* 대기 상태로 접어든다 */ 
    }   
}

signal() {
    S++;
    if (S <= 0) {
        remove a process p from Queue;  /* 대기 큐에 있는 프로세스 p를 제거한다 */
        wakeup(p);                      /* 프로세스 p를 대기 상태에서 준비 상태로 만든다. */
    } 
}
```

## 세마포를 활용한 실행 순서 동기화
세마포는 실행 순서 동기화도 제공한다. 

- 세마포의 변수 S를 0으로 두고
- 먼저 실행할 프로세스 뒤에 signal 함수,
- 다음에 실행할 프로세스 앞에 wait 함수를 붙이면 된다

# 모니터
- 매번 임계 구역 앞뒤로 wait(), signal()을 호출해야 하나? 그러다가 실수라도 하면?
- 세마포를 이용한 동기화 로직에 실수가 생겼을 때 큰 문제점은, 디버깅하기 어려운 경우가 많다는 것
- 그래서 등장하게 된 동기화 도구가 모니터 
- 모니터를 활용하는 가장 대표적인 언어로 자바가 있음

## 상호 배제를 위한 동기화 
- 인터페이스를 위한 큐
  - 인터페이스: 공유 자원 연산
- 공유 자원에 접근하려는 프로세스를 (인터페이스를 위한) 큐에 삽입
- 큐에 삽입된 순서대로 (한 번에 하나의 프로세스만) 공유 자원 이용 

## 실행 순서 제어를 위한 동기화
- 조건 변수(condition variable) 이용
  - 조건 변수: 프로세스나 스레드의 실행 순서를 제어하기 위해 사용하는 특별한 변수
  - 조건변수.wait(): 대기 상태로 변경, 조건 변수에 대한 큐에 삽입
  - 조건변수.signal(): wait()으로 대기 상태로 접어든 조건 변수를 실행 상태로 변경

### 모니터 안에는 하나의 프로세스만 있을 수 있다
- 모니터의 동기화 구현 방식은 두 가지 방식이 있음
  - wait()를 호출했던 프로세스는 signal()을 호출한 프로세스가 모니터를 떠난 뒤에 실행을 재개
  - signal()을 호출한 프로세스의 실행을 일시 중단하고 자신이 실행된 뒤 다시 signal()을 호출한 프로세스의 수행을 재개

## 정리
모니터는 상호 배제를 위한 동기화 뿐만아니라 실행 순서 제어를 위한 동기화까지 제공하는데 

1. 특정 프로세스가 실행될 조건이 아직 안됐을 땐, 즉 나중에 실행되어야 할 땐 조건변수.wait()를 통해 실행을 중단하고
2. 실행되어야 할 땐, 실행이 되어도 괜찮을 땐 다른 프로세스나 스레드가 시그널을 호출해주면 실행을 재개

하는 방식으로 동기화를 이룸
