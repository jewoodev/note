# 프로세스
- 운영체제에서 프로세스는 '실행 중인 프로그램'을 말한다. 
- 실행되기 전의 프로그램은 보조기억장치에 데이터 덩어리로 저장되어있다가 메모리에 적재되어 실행되는 과정을 거쳐 프로세스가 된다. 
  - 이 과정을 "프로세스를 생성한다." 라고 표현한다.

프로세스의 종류를 나누어 보면 크게 두 가지가 된다. 

1. 사용자가 볼 수 있는 공간에서 실행되는 **포그라운드 프로세스**(foreground process)
2. 사용자가 보지 못하는 뒷편에서 실행되는 **백그라운드 프로세스**(background process)
   1. 사용자와 직접 상호작용할 수 있는 것
   2. 사용자와 상호작용하지 않고 묵묵히 작업을 수행하는 것
      1. 이걸 유닉스 체계의 운영체제에서는 **데몬**(daemon)이라 부르고, 윈도우 운영체제에서는 **서비스**라고 부른다.

---

# 프로세스 제어 블록
- CPU라는 자원은 한정되어 있기 때문에 프로세스들은 돌아가며 한정된 시간 만큼만 CPU를 이용한다. 
  - 프로세스는 자신의 차례가 되면 정해진 시간만큼 사용하고, 
  - 시간이 끝났음을 알리는 인터럽트(**타이머 인터럽트**)가 발생하면 자신의 차례를 양보하고 다음 차례가 올 때까지 기다린다.
- 빠르게 번갈아가면서 수행되는 프로세스들을 운영체제는 관리해야 한다.
  - 운영체제가 관리하기 위해 사용하는 자료구조가 프로세스 제어 블록(PCB, Process Control Block)이다.
    - 프로세스 관련 정보를 저장하는 자료 구조
    - 마치 상품에 달린 태그와 같은 정보
    - 프로세스 생성 시 **커널 영역**에 생성, 종료 시 폐기

> PCB에 담기는 정보는 운영체제마다 차이가 있다. 

## PCB에 담기는 대표적인 정보
### 프로세스 ID(PID)
- 특정 프로세스를 식별하기 위해 부여하는 고유한 번호
- 같은 일을 수행하는 프로그램이여도 두 번 실행하면 PID가 다른 두 개의 프로세스가 생성된다. 

### 레지스터 값
- 프로세스는 자신의 실행 차례가 돌아오면 이전까지 사용했던 레지스터의 중간값들을 모두 복원 $\Rightarrow$ 실행 재개 
  - 프로그램 카운터, 스택 포인터, ...
- 레지스터 값들을 PCB에 명시하는 이유는 이전까지 실행했던 내용을 다시 자기 차례가 왔을 때 실행을 재개하기 위해서라고 볼 수 있다. (컨텍스트 스위칭, 문맥 교환 개념과 관련되어짐)

### 프로세스 상태
- 입출력 장치를 사용하기 위해 기다리고 있는 상태
- CPU를 사용하기 위해 기다리고 있는 상태
- CPU를 이용하고 있는 상태인지 등의 상태
- ...

위와 같은 다양한 프로세스의 상태값들이 있고, 그것이 담긴다.

### CPU 스케줄링 정보
- 프로세스가 언제, 어떤 순서로 CPU를 할당받을지에 대한 정보

### 메모리 관리 정보
- 프로세스가 (현재) 어느 주소에 저장되어 있는지에 대한 정보
- 페이지 테이블 정보

### 사용한 파일과 입출력장치 목록
- 프로세스 실행 과정에서 사용한 입출력장치와 파일 정보

---

# 문맥 교환(context switch)
- 프로세스 A가 실행되다가 프로세스 B로 실행 순서가 넘어간다면 컴퓨터 내부에서는 어떤 작업을 거치게 될까? 
  - 프로세스 A는 지금까지의 중간 정보를 백업해야 한다.
    - 중간 정보: 프로그램 카운터 + 각종 레지스터 값, 메모리 정보, 열었던 파일, 사용한 입출력장치 등
    - 이런 중간 정보를 **문맥**(context)라고 한다. 
      - 문맥: 하나의 프로세스의 실행을 재개하기 위해 기억해야 할 정보
      - "실행 문맥을 백업해두면 언제든 해당 프로세스의 실행을 재개할 수 있다."
    - 하나의 프로세스 문맥은 해당 프로세스의 PCB에 표현되어 있다. PCB에 기록되는 정보들을 문맥이라고 봐도 무방하다.
  - 뒤이어 실행할 B의 문맥을 복구해야 한다.
    - 자연스럽게 실행 중인 프로세스가 바뀜
- 이처럼 기존에 실행 중인 프로세스 문맥을 백업하고
  - 새로운 프로세스 실행을 위해 문맥을 복구하는 작업을
  - **문맥 교환**(context switch)이라고 한다. 
    - 여러 프로세스가 끊임없이 빠르게 번갈아 가면서 실행되는 원리

---

PCB는 사용자 영역이 아니라 커널 영역에 적재되어 있는, 옷에 달려있는 태그와 같은 자료구조라고 했다. 사용자 영역에는 프로세스가 저장되지 않는 걸까? 그렇지 않다. 한 번 어떤 식으로 저장되는지 알아보자.

# 프로세스의 메모리 영역
프로세스가 사용자 영역에 배치될 땐 크게 **코드** 영역(**텍스트** 영역), **데이터** 영역, **힙** 영역, **스택** 영역으로 나뉘어서 저장된다.

## 코드 영역
- 실행할 수 있는 코드, 기계어로 이루어진 명령어가 저장됨
- 데이터가 아닌 CPU가 실행할 명령어가 담겨 있기 때문에 쓰기가 금지된 영역 (read-only)

## 데이터 영역
- 잠깐 썼다가 없앨 데이터가 아닌, 프로그램이 실행되는 동안 유지할 데이터가 저장됨
  - e.g) 전역 변수(global variable)
- 코드 영역과 데이터 영역은 그 크기가 변하지 않는다. 
  - 왜냐하면, 프로그램이 실행되다가 '프로그램을 이루는 명령어'들이 갑자기 바뀔 일이 없고
    - 데이터 영역은 프로그램이 실행되는 내내 유지할 데이터이기에 실행 중에 바뀔 일이 없다. 
  - 그래서 두 영역을 **정적 할당 영역**(크기가 고정된 영역)이라고 부른다.

## 힙 영역
- 프로그램을 만드는 사용자, 즉 프로그래머가 직접 할당할 수 있는 저장 공간
- 힙 영역에 메모리 공간을 할당했다면 언젠가는 해당 공간을 반환해야 함 
  - 메모리 공간을 반환한다는 의미 == "더 이상 해당 메모리 공간을 사용하지 않겠다" 라고 운영체제에 말해주는 것
- 메모리 공간을 반환하지 않는다면 할당한 공간은 메모리 내에 계속 남아 메모리 낭비를 초래
  - 이런 문제를 **메모리 누수**(memory leak)라고 함

## 스택 영역
- 스택 영역(stack segment)은 데이터를 일시적으로 저장하는 공간
- e.g) 매개 변수, 지역 변수가 있음
- 일시적으로 저장할 데이터는 스택 영역에 PUSH되고, 
  - 더 이상 필요하지 않은 데이터는 POP됨으로써 스택 영역에서 제거됨
- 힙 영역과 스택 영역의 크기는 가변적
  - 그래서 **동적 할당 영역**이라 부름
  - 일반적으로 힙 영역은 메모리의 낮은 주소에서 높은 주소로,
  - 스택 영역은 높은 주소에서 낮은 주소로 할당
  - 서로의 영역이 충돌이 일어나지 않도록 하기 위함

두 영역이 동적으로 할당되어도 주소가 겹치지 않도록 하기 위해서 로, 되는게 일반적이다.
