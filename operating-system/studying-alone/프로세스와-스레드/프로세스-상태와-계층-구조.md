# 프로세스 상태
문맥 교환이 일어나는 과정에서 하나의 프로세스는 여러 상태를 거쳐가며 실행된다. 그리고 운영체제는 프로세스의 상태를 PCB를 통해 인식하고 관리한다.

프로세스 상태를 표현하는 방식은 운영체제마다 조금씩 다르지만 대표적인 것들은 아래와 같다.

## 생성 상태
- 막 메모리에 적재되어 PCB를 할당받은 상태
- 실행할 준비가 된 프로세스는 곧바로 실행되지 않고 준비 상태가 되어 CPU의 할당을 기다림

## 준비 상태
- 당장이라도 CPU를 할당받아 실행할 수 있지만, 아직 자신의 차례가 아니기 때문에 기다리고 있는 상태
- 차례가 되면 CPU를 할당받아 실행 상태가 됨(= 디스패치)

## 실행 상태
- CPU를 할당받아 실행 중인 상태
- 실행 상태인 프로세스는 할당된 일정 시간 동안만 CPU를 사용 가능
- 할당된 시간을 모두 사용 시(타이머 인터럽트가 발생 시) 준비 상태로
- 실행 도중 입출력장치를 사용하면 입출력 작업이 끝날 때까지 대기 상태로

## 대기 상태
- 프로세스는 실행 도중 입출력 장치를 사용하는 경우
- 입출력 작업은 CPU에 비해 느리기에 대기 상태(blocked)로 접어듬
- 입출력 작업이 끝나면(입출력 완료 인터럽트를 받으면) 준비 상태로 

> - 프로세스가 대기 상태가 되는 이유에 입출력 작업만 있는 건 아님
> - 더 일반적으로 표현하면 특정 이벤트가 일어나길 기다릴 때 프로세스는 대기 상태로 
> - 다만 대부분이 입출력 작업을 이유로 대기 상태가 되므로 위처럼 표현해도 무방

## 종료 상태
- 프로세스가 종료된 상태
- PCB와 프로세스의 메모리 영역 정리

## 프로세스 상태의 관계도

![img.png](https://github.com/jewoodev/blog_img/blob/main/operating-system/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EC%83%81%ED%83%9C_%EA%B4%80%EA%B3%84%EB%8F%84.png?raw=true)

---

# 프로세스의 계층 구조
- 프로세스는 실행 도중 (시스템 호출을 통해) 다른 프로세스를 생성 가능
  - 새 프로세스를 생성한 프로세스: **부모 프로세스**
  - 부모 프로세스에 의해 생성된 프로세스: **자식 프로세스**
    - 두 프로세스는 엄연히 다른 프로세스이기 때문에 각기 다른 PID를 가짐
    - 자식 프로세스 또한 실행 과정 중에 또 다른 자식 프로세스를 생성할 수 있고, 그 자식 프로세스도 마찬가지
- 일부 운영체제에서는 자식 프로세스의 PCB에 부모 프로세스의 PID인 PPID(Parent PID)가 기록되기도 함
- 많은 운영체제는 이처럼 프로세스가 프로세스를 낳는 계층적인 구조로 프로세스를 관리함
  - 컴퓨터가 부팅될 때 최초의 프로세스가 자식 프로세스들을 생성
  - 생성된 자식 프로세스들이 새로운 프로세스들을 낳는 형식으로 여러 프로세스가 동시에 실행됨
  - 이 과정을 도표로 그리면 트리 구조를 띄어서 이를 프로세스 계층 구조라고 함

## 최초의 프로세스
모든 프로세스의 가장 위에 있는 최초의 프로세스는 아래와 같다.

- 유닉스 운영체제: init
- 리눅스 운영체제: systemd
- macOS : launchd

최초의 프로세스 PID는 항상 1번이고 모든 프로세스의 최상단에 있는 부모 프로세스이다. 리눅스와 mac에서 `pstree` 명령어로 이를 확인할 수 있다.

---

# 프로세스 생성 기법
부모 프로세스는 자식 프로세스를 어떻게 만들어 내고, 자식 프로세스가 어떻게 자신만의 코드를 실행할까?

많은 운영체제에서 그러한 것들을 동일한 방식으로 구현하는데, 그 방식을 현실 세계의 개념에 쉽게 비유해보면 복제와 옷 갈아입기라고 하는 두 가지 과정을 거친다. 이게 어떤 의미를 갖는지 설명해보겠다.

- 부모 프로세스는 **fork 시스템 호출**을 통해 **자신의 복사본을 자식 프로세스로**써 생성
  - fork 시스템 호출
    - 복사본(=자식 프로세스) 생성
    - 부모 프로세스의 자원 상속
    - 엄연히 별개의 프로세스이기 때문에 PID, 저장된 메모리 위치는 다름
- 자식 프로세스는 **exec 시스템 호출**을 통해 자신의 메모리 공간을 **다른 프로그램으로 교체**
  - exec 시스템 호출
    - 메모리 공간을 새로운 프로그램으로 덮어쓰기
    - 코드/데이터 영역은 실행할 프로그램 내용으로 바뀌고 나머지 영역은 초기화

fork 한 후에 exec 시스템 호출을 통해 새로운 프로그램으로 전환된다. 새로운 프로그램으로 전환되면서 코드 영역과 데이터 영역의 내용이 실행할 프로그램으로 바뀌고, 나머지 영역은 초기화된다.

어떤 경우에는 부모 프로세스가 자식 프로세스를 fork(복사)하고 나서 부모, 자식 프로세스 모두 exec를 호출하지 않을 때가 있다. 이 경우엔 부모 프로세스와 자식 프로세스는 같은 코드를 병행해서 실행하는 프로세스가 된다.
