# CPU 스케줄링?
운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것. 스케줄링이 잘 이루어지지 않으면 꼭 실행되어야 하는 프로세스가 실행되지 못하거나 당장 급하지 않은 프로세스들만 계속해서 실행되는 상태가 될 수 있다.

## 가장 공정한 CPU 스케줄링?
- 단순하게 CPU를 사용하고 싶어하는 프로세스들이 차례대로 돌아가며 사용하게 한다면
- 빨리 처리해야 하는, 우선순위가 높은 프로세스가 있기 때문에 우리의 목표에 부합하지 않음
- 어떤 프로세스의 우선순위가 높고, 낮은지는 사용자가 설정할 수도, 운영체제가 내부적으로 정해둔 것도 있음

## 프로세스 우선순위
CPU 스케줄링을 위해 프로세스 우선순위에 따라 스케줄링을 해야 한다.

우선순위가 높은 프로세스는 대표적으로 입출력 작업이 많은 프로세스가 있다. 왜 우선순위가 높은걸까?

### 입출력 작업이 우선순위가 높은 이유
대부분의 프로세스들은 CPU와 입출력장치를 모두 사용하며 실행된다. 따라서 실행 상태와 대기 상태를 반복한다.

그런데 프로세스 종류마다 입출력장치를 이용하는 시간과 CPU를 이용하는 시간의 양에는 차이가 있다.

비디오 재생이나 디스크 백업 작업을 담당하는 것과 같이 입출력 작업이 많은 것이 있고, 복잡한 수학 연산, 컴파일, 그래픽 처리 작업을 담당하는 프로세스처럼 CPU 작업이 많은 것이 있다. 전자를 **입출력 집중 프로세스**, 후자를 **CPU 집중 프로세스**라 한다.

입출력 집중 프로세스는 입출력 작업이 많아서 실행 상태보다 대기 상태에 더 많이 머무르게 된다. CPU 집중 프로세스는 반대로, 실행 상태에 더 많이 머무르게 된다. 따라서 두 프로세스가 동일한 빈도로 CPU를 사용하는 것은 적합하지 못하다.

> **입출력 버스트와 CPU 버스트**
>
> 입출력장치를 기다리는 작업을 입출력 버스트(I/O burst)라 부르고, CPU를 이용하는 작업을 CPU 버스트라고 부른다.
>
> 그리고 프로세스는 입출력 버스트와 CPU 버스트를 반복하면서 실행된다.

CPU 집중 프로세스와 입출력 집중 프로세스가 동시에 CPU 자원을 요구했다고 가정해보자. 이 상황에서 자원이 효율적으로 사용되기 위해서는 입출력 집중 프로세스를 빨리 실행시켜서 입출력장치를 끊임없이 작동시키고, 그 다음 CPU 집중 프로세스에 CPU를 할당하는 것이 더 효율적이다. 입출력 장치가 작업을 완료하기 전까지 입출력 집중 프로세스는 대기 상태가 되기 때문에 이걸 빨리 처리해야 다른 프로세스가 CPU를 사용할 수 있기 때문이다.

상황에 맞게, 프로세스 중요도에 맞게 CPU가 사용될 수 있도록 하기위해 운영체제는 프로세스에 **우선순위**(priority)를 PCB에 명시한다.

## 스케줄링 큐
운영체제가 자원 배분할 때마다 PCB에서 우선순위를 확인하는 것은 효율적이지 않다. 그래서 운영체제는 프로세스들에게 '줄을 서서 기다릴 것'을 요구한다. 그리고 운영체제는 이 줄을 **스케줄링 큐**로 구현하고 관리한다.

운영체제가 관리하는 대부분의 자원은 큐로 관리된다. 그런 큐는 다양한데 대표적으로 준비 큐와 대기 큐가 있다. 준비 큐는 CPU를 이용하고 싶은 프로세스들이 서는 줄을 의미하고, 대기 큐는 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄을 의미한다. 이걸 프로세스 상태 다이어그램에 표현하면 더 세밀하게 완성할 수 있다.

![img.png](https://github.com/jewoodev/blog_img/blob/main/operating-system/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4_%EC%83%81%ED%83%9C_%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8_%ED%81%90_%ED%91%9C%ED%98%84.png?raw=true)

> '스케줄링 큐'에서의 큐는 반드시 FIFO일 필요는 없다.

### 준비 큐와 대기 큐
- 가장 대표적인 스케줄링 큐
- 준비 큐: CPU를 이용하고자 하는 프로세서들이 서는 줄
- 대기 큐: 입출력 장치를 이용하려고 서는 줄
- 프로세스마다 우선순위가 다르기 때문에 먼저 큐에 삽입되었다고 해서 먼저 처리되는 것은 아님

---

# 선점형과 비선점형 스케줄링
프로세스가 이미 CPU를 사용 중인 상황에서 갑자기 급한 프로세스가 "나 먼저 좀 쓰면 안돼냐?"고 하는 상황을 생각해보자. 이때 CPU 자원을 사용 중인 애한테서 뺏어서 급한 애한테 할당할 수도 있고, 쓰던 거 다 끝나고 나면 할당할 수도 있다. 전자가 선점형(preemptive) 스케줄링, 후자가 비선점형(non-preemptive) 스케줄링이다.

- 선점형 스케줄링
  - 장점: 어느 한 프로세스가 자원을 독점하는 걸 막고 프로세스들에게 골고루 자원을 배분할 수 있다.
  - 단점: 그만큼 문맥 교환 과정에서 오버헤드가 발생할 수 있다.
- 비선점형 스케줄링
  - 장점: 선점형 스케줄링에 비해 문맥 교환으로 인한 오버헤드가 적다.
  - 단점: 모든 프로세스가 골고루 자원을 이용하기 어렵다.
