# PC를 구성하는 주요 하드웨어
## CPU
명령을 수행할 수 있는 하드웨어. 

CPU가 읽어들여 이해하는 명령어들은 0과 1로 구성된 binary code로 표현되기 때문에 흔히 기계어라고도 많이 부른다.

그리고 우리가 흔히 말하는 **프로그램**이라는 것은 이런 명령어들과 명령어들의 타겟이 되는 데이터들의 조합이다.

### Register
CPU 안에 데이터를 저장할 수 있는 작은 공간. IR(Instruction Register)에서 메모리에 올라가 있는 명령어 데이터를 읽어들여 연산을 수행하기 위해 필요한 데이터를 메모리에서 R1, R2, R3 등에 저장하고 연산을 수행한 후 결과를 메모리에 반영한다.  

### Instruction Set
CPU는 CPU가 이해하고 수행할 수 있는 명령어들이 있다. 그 명령어를 **instruction set**이라고 부른다. 이는 제조사 별로 달라지며 ISA라는 용어가 이것과 관련이 깊다. 

### ISA, Instruction Set Architecture
Instruction set이 어떤 원리로, 어떤 구조로 동작하는지 정의하는 것을 말한다.

## RAM
수행해야 할 **명령어**가 있는 곳. 명령을 수행하기 위해서는 데이터 또한 필요하다. 따라서 데이터도 메모리에 저장되어 있어야 한다.

RAM은 휘발성 기억 장치, 전원이 차단되면 저장하고 있던 데이터가 사라진다.

프로그램이 실제로 RAM에 올라와서 컴퓨터에서 실행되고 있는 상태일 때, 이것을 **프로세스**라고 부른다.

## Secondary Storage (SSD or HDD)
전원이 끊기더라도 데이터가 손실되지 않는 장치로, 전원이 다시 공급되면 여기에 저장된 데이터는 다시 사용 가능하다. 파일 형식으로 저장된다.

> SSD는 Solid State Drive의 약자, HDD는 Hard Disk Drive의 약자. 

## NIC (Network Interface Card)
네트워크를 통해 멀리있는 컴퓨터와 데이터를 주고 받을 수 있게 해주는 장치.

# High level 언어 실행 방식
사람이 개발을 할 때 기계어를 직접 써서 개발하진 않는다. 사람이 읽고 이해할 수 있는 High level 언어로 개발한다.

High level로 작성된 소스코드들은 아래 방식 중 하나로 기계어로 변환되어 실행된다.

- 컴파일 방식
  - 컴파일러를 통해 소스코드를 기계어로 변환해서 실행 파일 생성
  - **실행 파일을 실행**
  - 소스코드가 프로세스가 됨
- 인터프리팅 방식
  - **인터프리터 실행** 후 소스코드 해석
  - 소스코드에 해당하는 동작을 인터프리터가 대신 수행
  - 즉, 이미 실행 중인 인터프리터의 코드(기계어)가 실행
  - 인터프리터가 프로세스가 됨

# 하드웨어 사용을 돕는 역할, OS
프로그램이 컴퓨터 하드웨어 장치들을 직접 사용하기엔 어려움들이 많다.

1. 컴퓨터의 하드웨어를 직접 제어하는 건 너무 복잡하고 어렵고 난해하다.
2. 잘못 건드리면 시스템 전체에 문제가 생길 수 있다.
3. 여러 프로세스를 한 컴퓨터에서 동시에 실행할 때 자원 괸리와 분배도 필요하다.

이런 어려움들 때문에 컴퓨터라는 하드웨어를 좀 더 쉽고 효율직이며 안전하게 잘 쓸 수 있도록 중재하는 것이 필요한데, 그것이 바로 OS다.

## OS가 하는 일
1. 좀 더 쉽게
   1. **system call**: 컴퓨터의 핵심 기능들을 쉽게 사용할 수 있도록 **하드웨어를 추상화**해서 제공하는 인터페이스
      1. e.g. read(), write(), socket(), clone(), **mmap()** (메모리 매핑), brk()
      2. OS 표준 라이브러리로 제공
      3. 시스템 콜은 여러 종류가 있음
         1. CPU 마다 동작하는 방식, 레지스터 이름 등이 달라서 같은 시스템 콜이라도 CPU 제조사 마다 다르게 정의됨
   2. **OS standard library**: 여러 유용한 핵심 기능을 함수 형태로 제공
      1. system call을 wrapping해서 제공
      2. 편의성이 더 강화된 고차원 기능을 여러 개 제공
         1. e.g. pthread_create() (내부적으로 clone()과 mmap()이라는 시스템 콜을 호출함), malloc() (동적으로 메모리를 할당하는 함수, 내부적으로 mmap()과 brk() 호출)
2. 효율적
   1. **process/thread scheduling**: 한정된 CPU 자원을 적절히 분배
      1. **time-sharing**(feat. **context switching**)
   2. **virtual memory**: 당장 필요한 **page**만 메모리에 올려 RAM 자원을 여러 프로세스가 더 효율적으로 사용하게 함
3. 안전
   1. **system call**: 크리티컬한 instruction set은 kernel만 쓰도록 보호
   2. **virtual memory**: 독립된 가상의 주소 공간을 제공해서 RAM에 직접 접근하지 못하게 막음으로써 보안 강화
   3. **synchronization**: 공유 자원에 동시에 접근해서 race condition이 발생하는 걸 막을 수 있는 기능을 제공

## system call
- CPU는 시스템 콜에 해당하는 기계어(e.g. syscall)를 받으면 해당하는 커널 코드로 점프
- 유저 모드를 커널 모드로 바꾸는 함수

## Virtual Memory
Virtual Memory는 프로세스에겐 트루먼쇼와 같다. 프로세스에게 독립된 (물론 가상이지만) 주소를 주며 "너만을 위한 공간이야, 네 마음대로 사용해도 좋아."라고 하는 것과 같은 꼴이기 때문이다. 

그럼 프로세스는 정말로 자신만의 독립적이고 연속적인 RAM을 가지는 걸까? 반은 맞고 반은 틀리다. 실제론 자신만의 독립적이고 연속적인 가상의 주소 공간(virtual address space)를 가지게 된다. 

CPU는 항상 프로세스를 실행할 때 VAS를 바라본다. VAS에는 실제 데이터는 없고 RAM의 주소로 변환하기 위한 '가상 주소'만 존재한다. CPU는 VAS에서 읽은 값으로 프로세스를 실행하기 위해 MMU(Memory Management Unit)에 접근한다. MMU는 가상 메모리 주소를 실제 메모리 주소로 바꿔주는데, 변환을 위해 변환 참조 버퍼(Translation Lookaside Buffer, TLB)라는 고속 보조기억장치를 참조한다. 이 보조기억장치에 원하는 변환 참조가 없을 때 더 느린, 다른 방법으로 페이지 변환 정보를 얻어오는데, 이 페이지 변환 정보가 담겨 있는 자료구조를 페이지 테이블이라고 한다.

TLB에서도 페이지 테이블에서도 물리 메모리 주소가 매핑된 엔트리를 찾지 못하면, page fault가 발생하고 VAS의 영역에 따라 다른 처리를 수행한다. Heap 혹은 Stack 영역에서 발생한 것이면 새로운 변수 같은 것을 메모리에 할당하다가 발생한 것이므로 I/O가 따라오지 않고, 다른 영역이면 수반된다.

VAS와 RAM의 단위를 부르는 것에 차이가 있다. VAS는 page, RAM은 frame으로 서로 다른 명칭을 사용하지만 크기는 동일하게 4K이다.

### 물리 메모리에 여유가 없어지면
상황에 따라서 해당 frame을 버리거나 스와핑하거나, write back을 수행한다. 프로그램 실행 중에 생성된 Heap 영역의 데이터는 Swap Space에, static 영역에 올라와있던 디스크의 어떤 파일 데이터가 바뀌었다면 그리고 그게 오래 사용되지 않아 내려야 한다면 (이건 할 수도 안할 수도) write back으로 디스크에 내리고 여유 공간을 만들어낸다.

참고로 이러한 스와핑과 write back이 발생하면 성능에 악영향이 온다는 것을 기억하자. 결국 속도가 느린 보조기억장치에 I/O를 수행하는 것이기 때문이다.

### Demand Paging
프로세스가 실행 중에 실제로 코드나 데이터가 필요한 순간에 해당 page를 메모리로 올리는 방식

### User Space vs Kernel Space
VAS도 두 영역으로 나뉜다.

- **User Space**:
  - **Code (Text) 영역**
    - 실행 가능한 프로그램 코드(기계어)가 저장됨 
    - 읽기 전용으로 설정되어 실행 중 변경 X
  - **Data 영역** 
    - 초기화된 전역 변수, static 변수가 저장됨 
    - 프로그램 시작 시 값이 할당된 변수들임
  - **BSS (Block Started by Symbol) 영역** 
    - 초기화되지 않은 전역 변수, static 변수가 저장됨
    - 실행 시 0으로 자동 초기화됨
  - **Heap 영역** 
    - 동적으로 할당되는 메모리 공간 
    - Java에서는 new 키워드로 생성한 객체들이 여기 저장됨 
    - 낮은 주소에서 높은 주소 방향으로 증가함
  - **Stack 영역** 
    - 함수 호출 시 지역 변수, 매개변수, 리턴 주소 등이 저장됨 
    - 높은 주소에서 낮은 주소 방향으로 증가함
    - LIFO 구조로 동작함 
  - **Memory Mapped Region** 
    - 파일이나 라이브러리가 메모리에 매핑되는 영역
    - 공유 라이브러리(.so, .dll) 등이 로드됨
- **Kernel Space**:
  - 커널 코드와 매핑되는 영역

### Process vs Thread
- 같은 프로세스에 속한 스레드 간의 컨텍스트 스위칭이 더 빠른 이유는 같은 가상 주소 공간을 공유해서 주소 공간 switching이 필요하지 않기 때문

## JVM
JVM도 OS 관점에서는 하나의 프로그램이고 프로세스일 뿐이다.(대부분 C++로 구현되어 있음)