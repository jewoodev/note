## 2. Process scheduling

### 2.2 CPU scheduling

프로세스는 자신의 lifetime 동안 ready queue 에서 다양한 종류의 wait queue 로 이동하는 것을 반복한다. CPU 스케줄러의 역할은 프로세스들 중에서 하나를 선택해 CPU 자원을 할당하는 것이다. I/O-bound process 에 비해 CPU 를 사용해야 하는 시간이 더 긴 CPU-bound process 는 CPU 스케줄러가 더 높은 CPU 할당 우선순위에 둘 것 같지만, 그렇지 않다. 스케줄러는 더 긴 기간동안 사용하려는 프로세스에게 CPU 를 넘겨주는 것을 좋아하지 않는다. 

일부 운영체제는 스와핑(swapping)이라 불리는 중간 형태의 스케줄링을 사용하는데, 이 것의 핵심 아이디어는 프로세스를 메모리에서 제거하고(CPU 사용 경쟁에서도 제외시켜) multi-programming degree 를 줄이는 것이 때때로 더 유리할 수 있다는 것에 있다. 스와핑이 적용되고 있는 와중에 프로세스는 메모리에 다시 적재되고, 그것의 중단된 상태로부터 다시 실행될 수 있다. 스와핑은 메모리가 오버 커밋되거나 정리될 필요가 있을 때 필수적이다.

### 2.3 Context switch

인터럽트는 운영체제가 CPU core 의 작업을 변경하고, 커널 루틴을 실행하도록 한다. 인터럽트가 일어나면 시스템은 CPU core 를 사용해 실행되던 프로세스의 context(문맥)을 저장할 필요가 있는데, 중단된 프로세스를 다시 이어서 실행하는 것이 가능하려면 필요하기 때문이다. 문맥에는 CPU registers, 프로세스 상태, 메모리 관리 정보가 포함된다. 이를 PCB 에 저장하고, resume 할 때 load 한다.

Context switch 에 소요되는 시간은 하드웨어 지원에 매우 강하게 달려있다. 

## 5. IPC in shared-memory systems

공유 메모리를 사용하는 프로세스 간 통신은 공유 메모리 지역을 확정짓는데에 의사소통 과정이 필요하다. 일반적으로 공유 메모리 자원은 공유 메모리 세그먼트를 생성한 프로세스의 주소 공간에 위치한다. 이 공간으로 통신하려는 다른 프로세스는 모두 이 공간을 그들의 주소 공간에 attach 해야 한다. 

일반적으로 운영체제가 다른 프로세스가 하나의 프로세스의 메모리에 접근하는 것을 막는다는 것을 다시 떠올려보자. 그래서 공유 메모리는 두 개 혹은 더 많은 프로세스가 restriction을 지우는 것을 허용해야 한다.

그리고 이 곳을 사용하는 프로세스들은 simultaneously 하게 서로 같은 위치에 writing 하지 않는 것을 ensure 해야 한다. 

협력하는 프로세스의 컨셉을 알아보기 위해 프로듀서-컨슈머 문제를 살펴보자. 이는 클라이언트-서버의 관계와 같다. 프로듀서-컨슈머의 문제를 해결하는 방법 중 하나가 공유 메모리다. 프로듀서와 컨슈머가 동시에 동작하기 위해, 생산자가 데이터를 채우고 소비자가 데이터를 꺼낼 수 있는 버퍼가 필요하다.

공유 버퍼는 두 개의 논리적 포인터가 있는 원형 배열로 구현된다. 그 중 하나인 in 은 프로듀서가 생성한 새로운 item 이 저장될 식별자, out 은 컨슈머가 다음으로 소비할 item 의 식별자이다. 

하지만 프로듀서와 컨슈머가 동시에 공뷰 버퍼에 접근하는 것에 대한 문제는 해결될 필요가 있다.

## 6. IPC in message-passing systems

IPC 는 운영체제가 협력 프로세스들이 message passing facility 를 통해 의사소통 할 수 있도록 수단을 제공하는 것으로 가능하다. 이 방법은 특히 분산환경에서 유용한데, 통신하는 프로세스들이 네트워크로 연결된 서로 다른 컴퓨터에 위치할 수 있기 때문이다.

## 6.1 Naming

통신하고 싶은 프로세스들은 서로를 조회할 수 있는 방법이 필요하다. 이는 직접적이거나 직접적이지 않은 통신으로 가능하다.

직접적인 통신은 아래와 같은 특징이 있다.

- 송신자 또는 수신자의 분명한 이름이 반드시 필요하다. 
- 이 방식에서는 링크가 각 쌍마다 자동적으로 생성된다. 프로세스들은 서로의 식별자만 알면 된다.
- 링크는 정확히 두 프로세스에 연관된다.
- 한 쌍의 프로세스에는 하나의 링크만 존재한다.

이 전략은 주소 관리에서 대칭성을 보인다. 송신자와 수신자가 모두 이름짓는 것을 필요로 하는 것처럼 말이다. 비대칭적으로 주소 관리하는 것도 가능한데, 수신자만 송신자에게 이름짓고 수진자는 송신자에게 자신의 이름을 알리지 않는 방식이다. 이 방식은 프로세스 정의로 인한 모듈화의 한계를 갖는다. 식별자를 변경할 필요가 있을 때 많은 오버헤드가 생기는 문제도 있다. 일반적으로, 하드 코딩은 간접 참조를 사용하는 방식보다 바람직하지 않다.

비직접적인 통신은 메일박스나 포트로부터 메세지를 주고 받는다. 하나의 프로세스는 여러 개의 서로 다른 메일박스를 통해 다른 프로세스와 통신할 수 있지만, 두 프로세스가 통신하려면 반드시 공유된 메일박스가 있어야 한다. 

비직접적 통신의 링크는 다음과 같은 특징이 있다.

- 프로세스들의 한 쌍에 생성되는 링크는 그 쌍이 공유 메일박스를 가질 때만 생성된다.
- 링크에 두 개 이상의 프로세스가 연관된다.
- 통신하는 프로세스들의 각 쌍 사이에 여러 개의 다른 링크들이 존재한다면 그 링크들은 하나의 메일박스에 해당된다.

## 8. Communication in client-server systems

프로세스 간 통신에 사용할 수 있는 '공유 메모리'와 '메세징'은 클라이언트-서버 시스템의 통신에도 사용할 수 있다. 이 섹션에서 우리는 두 가지의 다른 전략을 살펴볼 것이다. 이 전략은 클라이언트-서버 시스템에서의 통신 방법: sockets 와 remote procedure calls(RPCs) 이다.

### 8.1 Sockets

소켓은 통신의 엔드포인트로 정의된다. 그리고 아이피 주소에 포트번호를 연결한 것으로 식별당한다. 일반적으로, 클라이언트-서버 구조에서 사용된다.

클라이언트 프로세스가 연결을 위한 요청을 시도할 때, 호스트 컴퓨터로부터 포트를 할당받는다. 이 포트 번호는 1024보다 큰 임의의 숫자이다. Connection 은 한 쌍의 소켓으로 구성된다. 호스트 간 이동하는 패킷은 도착지의 포트 번호를 기반으로해서 적절한 프로세스에게 전달된다.

모든 커넥션은 유일하다. 이는 모든 커넥션이 유일한 쌍의 소켓들로 이루어지는 결과로 이어진다.

자바는 세가지의 각기 다른 타입의 소켓을 제공한다. Connection-oriented(TCP) 소켓은 Socket class 에 구현되어있다. Connectionless(UDP) 소켓은 DatagramSocket class 에서 사용한다. 마지막으로 MulticastSocket class 는 DatagramSocket class 의 하위 클래스이다. 이 것은 데이터가 다수의 수신자에게 보내지는 것을 가능케 한다.

소켓을 통한 통신은 일반적이고 능률적임에도 low-level 형식이라고 간주된다. 그 이유는 unstructured stream of bytes 만 소켓이 받아들이기 때문이다. 데이터를 구조화하는 것은 클라이언트와 서버 애플리케이션의 역할로 넘어간다. 

### 8.2 Remote procedure calls

RPC paradigm 은 네트워크 연결을 통해 사용되는 시스템들의 procedure-call mechanism 을 추상화하는 일반적인 방법 중 하나이다. 이 것은 많은 측면에서 IPC 메커니즘과 닮아있고, 시스템의 고위층에 build 되어 있다. 

IPC 메세지 방식과 다르게, RPC 통신에서는 구조화된 메세지를 사용하고 데이터를 패킷화하지 않는다. 

RPCs 의 의미들은 remote host 의 procedure 를 마치 local 에서 호출하듯 클라이언트가 호출하는 것을 허용한다. 이러한 시스템이 가능할 수 있는 건 클라이언트 측에 stub 을 제공하는 디테일에 있다. 클라이언트가 remote procedure 를 호출하면, RPC 시스템은 적절한 stub 을 호출하고, 주어진 remote procedure 에 parameter 들을 넘겨준다.

그런데 파라미터를 넘겨주는 것에는 클라이언트와 서버의 서로 다른 데이터 표현체계 때문에 문제가 있다. 이 문제는 external data representation(XDR) 이라는 machine 에 independent 한 데이터 표현체계를 사용함으로써 해결할 수 있다. 

또 다른 중요한 문제는 호출하는데서 온다. local procedure call 은 극단적인 상황에서만 실패하는 반면, RPC 는 일반적인 네트워크 오류로 인해 실패하거나, 중복되어 한 함수가 여러 번 실행될 수도 있다. 이 문제의 해결법 중 하나는 운영체제가 각 메세지가 정확히 '한 번만 작동한다.' 라는 절 보증하는 것이다. 대부분의 local procedure call 들은 '한 번만' 기능을 가지고 있지만, 이는 구현하기 어렵다.

'많아봐야 한 번' 의 경우를 생각해보자. 이 의미는 각 메세지마다 timestamp 를 첨부하는 것으로 구현할 수 있다. 

'정확히 한 번만' 의 경우에 우리는 서버가 절대 요청을 받지 않는 위험을 제거해야 한다. 이를 위해, 서버는 '많아봐야 한 번' 프로토콜을 구현해야 하며 RPC 호출이 받아들여졌다거나 실행됐다는 것을 클라이언트에게 알려야 한다. 