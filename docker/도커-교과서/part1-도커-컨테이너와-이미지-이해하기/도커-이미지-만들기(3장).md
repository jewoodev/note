# 도커 허브에 공유된 이미지 사용하기
도커 이미지는 설정값의 기본값을 포함해 패키징되지만, 컨테이너를 실행할 때 이 설정값을 바꿀수 있어야 한다. 이는 `--env` 옵션을 사용해 가능하다. 이러한 명령어의 예시는 다음과 같다.

```bash
docker container run --name web-ping --env TARGET=google.com [이미지 이름]
```

호스트 컴퓨터에도 고유의 환경 변수가 있다. 그러나 컨테이너의 환경 변수는 별개다. 컨테이너는 도커가 부여한 환경 변수만을 갖는다. 

지금부터 Dockerfile을 작성해 직접 도커 이미지를 만드는 방법을 알아보자.

# Dockerfile 작성하기
Dockerfile은 애플리케이션을 패키징하기 위한 간단한 스크립트이다. Dockerfile은 일련의 인스트럭션으로 구성되어져 있는데, 인스트럭션을 실행한 결과로 도커 이미지가 만들어진다. 여타 스크립트 언어와 마찬가지로 Dockerfile 문법도 매우 유연하다. 자주 쓰이는 작업은 별도의 명령이 마련되어져 있으며, 원하는 작업을 직접 작성할 수 있고, 표준 쉘 문법도 사용 가능하다.

```dockerfile
FROM diamol/node

ENV TARGET=google.com
ENV METHOD="HEAD"
ENV INTERVAL="3000"

WORKDIR /web-ping
COPY app.js .

CMD ["node", "/web-ping/app.js"]
```
위 스크립트에 나온 인스트럭션은 FROM, ENV, WORKDIR, COPY, CMD다. 대문자로 작성되어 있지만 소문자를 사용해도 잘 작동한다.

- FROM: 모든 이미지는 다른 이미지로부터 출발한다. 이 이미지는 diamol/node 이미지를 시작점으로 지정했다. 
- ENV: 환경 변수값을 지정하기 위한 인스트럭션이다. 값을 지정하기위해 "[key]=[value]" 형식을 따른다. 
- WORKDIR: 컨테이너 이미지 파일 시스템에 디렉터리를 만들고, 해당 디렉터리를 작업 디렉터리로 지정하는 인스트럭션이다. 리눅스와 윈도 컨테이너 모두 구분자로 슬래시를 사용한다. 
- COPY: 로컬 파일 시스템의 파일 또는 디렉토리를 컨테이너 이미지로 복사하는 인스트럭션이다. 파라미터를 "[원본경로] [복사경로]" 형식으로 기입하면 된다. 
- CMD: 도커가 이미지로부터 컨테이너를 실행했을 때 실행할 명령어를 지정하는 인스트럭션이다. 

# 컨테이너 이미지 빌드하기
이미지를 빌드하려면 Dockerfile 스크립트 외에 필요한 게 몇 개 더 있다. 이미지의 이름, 패키징에 필요한 파일의 경로를 추가가 바로 그 것이다. 다음의 명령어로 빌드가 진행된다.

```bash
docker image build --tag web-ping .
```
`--tag`의 인자값은 이미지의 이름이고, 그 다음 인자는 Dockerfile과 이미지에 포함될 '파일이 위치한 경로'이다. 도커에서는 이 디렉터리를 컨텍스트라고 한다.

## 추가 명령어 메모
- `docker image ls j*`
  - j로 시작하는 이미지 목록을 출력하라.

# 도커 이미지와 이미지 레이어 이해하기
도커 이미지에는 우리가 패키징에 포함시킨 모든 파일이 들어 있다. 이들 파일은 나중에 컨테이너의 파일 시스템을 형성한다. 이 외에도 이미지에는 자신에 대한 여러 메타데이터 정보도 들어 있다. 이 정보에는 이미지가 어떻게 빌드됐는지에 대한 간단한 이력도 포함된다. 이 정보를 확인하면 이미지를 구성하는 각 레이어는 무엇이고 이들 레이어가 어떤 명령으로 빌드됐는지를 알 수 있다.

```bash
docker image history web-ping
```
이 명령을 입력하면 한 줄마다 한 레이어에 대한 정보가 출력된다. CREATED BY는 해당 레이어를 구성한 Dockerfile 스크립트의 인스트럭션이다. Dockerfile 인스트럭션과 이미지 레이어는 1:1 관계를 갖는다. 

도커 이미지는 이미지 레이어가 모인 논리적 대상이다. 그리고 이미지 레이어는 여러 이미지와 컨테이너에서 공유될 수 있다. 우리가 만든 web-ping 이미지 또한 diamol/node 이미지를 최하위의 이미지 레이어로 둔 이미지이다. 만약 diamol/node 이미지를 이미지 레이어로 둔 다른 이미지를 빌드한다면 그 이미지와 web-ping 이미지는 diamol/node 이미지를 각각 독립적으로 레이어로 두지 않고 공유되는 것이 이미지 레이어 개념이다. 

그래서 그런 공유하는 이미지 레이어가 있는 경우 `docker images` 명령어로 확인할 수 있는 SIZE값과 `docker system df` 명령어로 확인할 수 있는 SIZE 값이 달라질 수 있다. 전자의 경우 논리적 용량을 보여주기 때문이다.

이미지 레이어를 여러 이미지가 공유한다면, 공유되는 레이어는 수정할 수 없어야 한다. 만약 이미지의 레이어를 수정할 수 있다면 그 수정이 레이어를 공유하는 다른 이미지에도 영향을 미치게 되기 때문이다. 도커는 이미지 레이어를 읽기 전용으로 만들어 두어 이런 문제를 방지한다. 이미지를 빌드하면서 레이어가 만들어지면 레이어는 다른 이미지에서 재사용될 수 있다. 그러나 레이어를 수정할 수는 없다. 이 특징은 Dockerfile 스크립트를 최적화해서 도커 이미지 용량을 줄이고 빌드를 빠르게 만드는 걸 가능케 한다.

# 이미지 레이어 캐시를 이용한 Dockerfile 스크립트 최적화
Dockerfile로 한 번 빌드하고 나면 빌드 과정에서 생성된 이미지 레이어들은 캐시되어 재사용된다. 그리고 재사용될 땐 처음과 달리 캐시된 레이어를 가져와 사용하기 때문에 효율적으로 빌드된다. 예시의 경우에서 app.js 파일을 수정하고 다시 빌드하면, 새로운 이미지 레이어가 생긴다. 도커의 이미지 레이어가 특정한 순서로만 배치된다고 가정하자. 그러면 이 순서 중간에 있는 레이어가 변경되면 변경된 레이어보다 위에 오는 레이어는 재사용할 수 없다.

Dockerfile의 인스트럭션은 이미지 레이어와 1:1로 연결되고, 인스트럭션의 결과가 이전 빌드와 같다면 이전의 캐시된 레이어를 재사용한다. 이를 통해 똑같은 인스트럭션을 다시 실행하는 낭비를 줄일 수 있다. 

도커는 캐시에 일치하는 레이어가 있는지 확인하기 위해 해시값을 이용한다. 해시는 입력값이 같은지 확인할 수 있는 일종의 디지털 지문이다. 해시값은 Dockerfile 스크립트의 인스트럭션과 인스트럭션에 의해 복사되는 파일의 내용으로부터 계산되는데, 기존 이미지 레이어에 해시값이 일치하는 것이 없다면 캐시 미스가 발생하고 해당 인스트럭션이 실행된다. 한 번 인스트럭션이 실행되면 그 다음에 오는 인스트럭션은 수정된 것이 없더라도 모두 실행된다.

따라서 Dockerfile 스크립트의 인스트럭션은 잘 수정되지 않는 인스트럭션을 앞에 위치시키고 자주 수정될수록 뒤에 위치시킬 필요가 있다. 

# 연습문제
- docker container run -it --name ch03lab diamol/ch03-lab
- echo Elton >> ch03.txt
- exit
- docker container commit ch03lab ch03-lab-soln
- docker container run ch03-lab-soln cat ch03.txt