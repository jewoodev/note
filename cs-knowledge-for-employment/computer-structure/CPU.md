# 레지스터
- CPU 안에 있는 작은 임시 저장장치
  - CPU 안에는 다양한 레지스터들이 있고, 각기 다른 이름과 역할
  - 프로그램을 이루는 데이터와 명령어가 프로그램의 실행 전후로 레지스터에 저장
  - 레지스터는 WinDbg(윈도우 운영체제), gdb(리눅스, 맥OS 운영체제) 등의 디버깅 도구를 이용해 관찰

## 주요 레지스터
1. 프로그램 카운터
   - 프로그램 카운터(PC, Program Counter)는 메모리에서 다음으로 읽어 들일 명령어의 주소를 저장
   - 프로그램 카운터를 명령어 포인터(IP, Instruction Pointer)라고 부르는 CPU도 있음
   - 일반적으로 프로그램 카운터는 1씩 증가, 이는 곧 다음으로 읽어 들일 메모리 주소가 1씩 증가하는 것과 같음
2. 명령어 레지스터
   - 명령어 레지스터(IR, Instruction Reigister)는 해석할 명령어, 즉 메모리에서 방금 읽어 들인 명령어를 저장
   - CPU 내의 제어장치는 명령어 레지스터 속 명령어를 해석한 뒤 ALU로 하여금 연산하도록 시키거나 다른 부품으로 제어 신호를 보내 해당 부품을 작동시킴
3. 범용 레지스터
   - 범용 레지스터(general purpose register)는 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터
   - 데이터와 명령어, 주소 모두를 저장할 수 있음
   - 일반적으로 CPU 안에는 여러 개의 범용 레지스터들이 있음
4. 플래그 레지스터
   - 플래그 레지스터는 연산의 결과 혹은 CPU 상태에 대한 부가 정보인 플래그 값을 저장
5. 스택 포인터
   - 스택 포인터는 메모리 내 스택 영역의 최상단 스택 데이터 위치를 가리키는 특별한 레지스터

---

# 인터럽트
- 인터럽트 - CPU의 작업을 방해하는 신호
  - 동기 인터럽트
    - CPU에 의해 발생하는 인터럽트
      - ex) CPU가 프로그래밍 오류와 같은 예외적인 상황(예상치 못한 상황)을 마주쳤을 때 발생하는 인터럽트
    - 동기 인터럽트는 예외라고도 부름
  - 비동기 인터럽트 또는 하드웨어 인터럽트
    - 주로 입출력장치에 의해 발생하는 인터럽트
      - ex) 세탁기나 전자레인지의 완료 알림과 같은 알림의 역할
    - CPU가 프린터와 같은 입출력장치에게 입출력 작업을 부탁하고, 작업을 끝낸 입출력장치가 CPU에게 완료 알림(인터럽트)을 보냄
    - 키보드, 마우스와 같은 입출력장치가 어떤 입력을 받아들였을 때, 이를 처리하기 위해 CPU에게 입력 알림(인터럽트)을 보냄

## 하드웨어 인터럽트
- CPU는 효율적으로 명령어를 처리하기 위해 하드웨어 인터럽트를 사용
- CPU가 하드웨어 인터럽트를 처리하는 순서
  1. 입출력장치는 CPU에게 인터럽트 요청 신호를 보냄
  2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전에 항상 인터럽트 여부를 확인
  3. CPU는 인터럽트 요청을 확인하고, **인터럽트 플래그**를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인
  4. 인터럽트를 받아들일 수 있다면 CPU가 지금까지의 작업을 백업
  5. CPU는 **인터럽트 백업**을 참조해서 **인터럽트 서비스 루틴**을 실행
  6. 인터럽트 서비스 루틴 실행이 끝나면 4번에서 백업해둔 작업을 복구하여 실행을 재개

- 인터럽트 요청 신호
  - 인터럽트는 CPU의 정상적인 실행 흐름을 끊는 것이기 때문에 인터럽트하기 전에 CPU에게 인터럽트의 가능 여부를 확인
- 인터럽트 플래그
  - CPU가 인터럽트 요청을 수용하기 위해서는 플래그 레지스터가 활성화되어 있어야 함
  - 인터럽트 플래그는 하드웨어 인터럽트를 받아들일지, 무시할지를 결정하는 플래그
  - 만약 인터럽트 플래그가 불가능으로 설정되어 있다면 CPU는 인터럽트 요청이 오더라도 무시

하드웨어 인터럽트 중에는 플래그 레지스터로 막을 수 있는 인터럽트와 막을 수 없는 인터럽트가 있다. 막을 수 없는 인터럽트는 NMI(Non Maskable Interrupt)라고도 한다.

- 인터럽트 서비스 루틴(ISR, Interrupt Service Routine)
  - CPU가 인터럽트 요청을 받아들이기로 했다면 CPU는 인터럽트 서비스 루틴을 실행
  - 인터럽트 서비스 루틴은 인터럽트를 처리하기 위한 프로그램으로, 인터럽트 핸들러라고도 함
  - CPU가 인터럽트를 처리 = 인터럽트 서비스 루틴을 실행하고, 본래 수행하던 작업으로 다시 되돌아온다는 의미

- 인터럽트 벡터(interrupt vector)
  - 인터럽트 벡터는 인터럽트 서비스 루틴을 식별하기 위한 정보
    - CPU가 인터럽트를 처리 - 인터럽트 서비스 루틴을 실행하고, 본래 수행하던 작업으로 다시 되돌아옴
    - CPU가 인터럽트 서비스 루틴을 실행하려면 인터럽트 서비스 루틴의 시작 주소를 알아야 함

## 예외(동기 인터럽트)
- 예외의 종류
  - 폴트
  - 트랩
  - 중단
  - 소프트웨어 인터럽트 등
- CPU는 예외가 발생하면 하던 일을 중단하고 해당 예외를 처리
  - 예외를 처리하고 나면 다시 본래 하던 작업으로 되돌아와 실행을 재개
  - CPU가 본래 하던 작업으로 되돌아왔을 때
    - 폴트 - 예외가 발생한 명령어부터 실행
      - 실행하려는 명령어가 메모리에 적재되지 않았을 때 발생
    - 트랩 - 예외가 발생한 명령어의 다음 명령어부터 실행
      - ex) 디버깅의 브레이크 포인트
    - 중단(abort)
      - CPU가 실행 중인 프로그램을 강제로 중단시킬 수밖에 없는 심각한 오류를 발견했을 때 발생하는 예외
    - 소프트웨어 인터럽트
      - 시스템 콜이 발생했을 때 발생하는 예외

---

# 성능 향상
_CPU 성능 향상을 위한 설계_

## CPU 클럭 속도
- 클럭 - 컴퓨터의 부품을 일사분란하게 움직일 수 있게 하는 시간의 단위(작업이 양이 많을 땐 짧아지기도 하고 적을 땐 길어지기도 함)
  - 클럭 속도는 헤르츠 단위로 측정
- 클럭 속도는 CPU의 속도 단위로 간주
  - 하지만 클럭 속도를 필요 이상으로 높이면 컴퓨터의 발열이 심해질 수 있기 때문에 클럭 속도를 높이는 것만으로 CPU의 성능을 높이는 데에는 한계가 있음

## 멀티코어와 멀티스레드
- 코어: CPU 내에서 명령어를 읽어 들이고, 해석하고, 실행하는 부품

- 스레드
  - 하드웨어적인 스레드
  - 프로그래밍 언어 및 운영체제에서 사용하는 소프트웨어적인 스레드

- 하드웨어 스레드 - 하나의 코어가 동시에 처리하는 명령어의 단위
  - 멀티스레드 프로세서, 혹은 멀티스레드 CPU
  - 논리 프로세서(logical processor)
- 소프트웨어 스레드 - 하나의 프로그램에서 독립적으로 실행되는 단위

- 멀티 코어/ 멀티 스레드
  - 병렬성: 작업을 물리적으로 동시에 처리하는 성질
  - 4코어 8스레드 CPU가 4개의 명령어를 동시에 실행
- 소프트웨어 스레드
  - 동시성: 동시에 작업을 처리하는 것**처럼 보이는** 성질
  - 논리적인 실행 단위

## 파이프라이닝 통한 명령어 병렬 처리
- 명령어 병렬 처리 기법(ILP, Instruction-Level Parellelism)
  - 여러 명령어를 동시에 처리하여 CPU를 한시도 쉬지 않고 작동시킴으로써 CPU의 성능을 높이는 기법
  - 명령어 파이프라이닝

- 명령어가 처리되는 과정
  - 비슷한 시간 간격으로 나눔
    1. 명령어 인출(Instruction Fetch)
    2. 명령어 해석(Instruction Decode)
    3. 명렁어 실행(Execute Instruction)
    4. 결과 저장(Write Back)
  - 같은 단계가 겹치지만 않는다면 CPU가 각각의 단계를 동시에 실행할 수 있음
    - 그러한 방법을 사용해 병렬로 명령어를 실행하는 방법이 **명령어 파이프라이닝**이다.

- 명령어 파이프라이닝
  - 공장의 생산 라인과 같이 명령어들을 명렁어 파이프라인에 넣고 동시에 처리하는 기법

이러한 파이프라이닝이 실패하는 사례를 살펴보자
- 파이프라인 위험(pipeline hazard)
  - 파이프라이닝이 실패하여 성능 향상이 이루어지지 않는 상황
    - 데이터 위험(data hazard)
      - 명령어 간의 데이터 의존성에 의해 발생
        - 명령어 1의 결과물이 명령어 2가 사용하는 값일 때
    - 제어 위험(control hazard)
      - 프로그램 카운터의 갑작스러운 변화에 의해 발생
    - 구조적 위험(structural hazard) 또는 자원 위험(resource hazard)
      - 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려고 할 때 발생

