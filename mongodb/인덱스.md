MongoDB 쿼리의 개발이나 튜닝에 앞서서 MongoDB에서 사용할 수 있는 인덱스의 종류 및 인덱스와 관련해서 주로 언급되는 내용을 살펴보겠다.  
각 인덱스들의 특성과 차이는 상당히 중요하며, 물리 수준의 모델링 및 성능에서 중요한 요소다. 또한 DBMS 성능에서 빠질 수 없는 "랜덤 I/O"와 "순차 I/O" 에 대해서 살펴보겠다.

# 디스크 읽기 방식
짧은 시간 동안 컴퓨터의 CPU나 메모리와 같은 전기적 특성을 가진 장치의 성능은 매우 빠른 속도로 발전했지만, 디스크와 같은 기계식 장치의 성능은 상당히 제한적인 편이다. 그렇지만 데이터베이스와 관련된 성능의 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건인 것들이 상당히 많다.

## 1. 디스크 저장 매체
보통 기계식 장치인 디스크가 가장 취약한 성능을 보인다. 그런데 MongoDB를 사용하는 서버라면 고가의 스토리지를 사용하는 경우가 많지 않다. 중요한 건 내장 디스크이든지 DAS 장비나 SAN 장비든지 관계없이 거의 모든 시스템에서 디스크가 가장 취약한 장치의 자리를 차지하고 있다는 것이며, 쿼리 튜닝의 가장 핵심이 되는게 이런 디스크의 단점을 보완하기 위해 쿼리의 작동 방식을 개선하는 것이다.

요즘은 기계식으로 작동하는 디스크는 상대적으로 빠른 전자식 장치로 교체되고 있다. 그 대표적인 예시인 SSD는 컴퓨터의 주 메모리에 사용되는 D-RAM과는 달리 전원 공급에 관계없이 한 번 기록한 내용을 영구적으로 보존하는 플래시 메모리를 내장하고 있으며 D-RAM보다는 접근 속도가 떨어지지만, 기계식보다는 월등히 뛰어나다.

메모리와 디스크의 처리 지연은 최대 100만 배 이상의 차이를 보인다. 그에 배해 플래시 메모리를 사용하는 SSD는 1,000배 가량의 차이를 보인다.

SSD의 가장 큰 장점은 랜덤 I/O에 매우 적합하다는 것이다. 순차 I/O 성능 또한 기존의 HDD와 비교해서 떨어지지 않지만, 일반적으로 데이터베이스 시스템에서 순차 I/O 성능은 그다지 중요하지 않다고 볼 수 있다. 그리고 HDD도 순차 I/O 성능은 크게 문제되지 않아서 순차 I/O를 위해 SSD를 선택하는 것은 적절하지 않다.

# MongoDB 인덱스의 개요
DBMS의 종류별로 아키텍처 차이가 있기 때문에 이름이 같아도 인덱스가 구현되는 방식과 특성이 조금씩 다르기 마련이다. MongoDB 인덱스도 그러하며, 그런 작은 차이점이 엄청난 성능 차이를 만들어 내기도 한다.

## 1. 클러스터링 인덱스
MongoDB 3.6 버전까진 MongoDB의 모든 스토리지 엔진에서 사용되는 인덱스는 클러스터링 인덱스를 지원하지 않는다. 아직 지원하지도 않는데 이에 대해 설명할 것인데, 그 이유는 그만큼 클러스터링 인덱스가 성능에 미치는 영향이 크기 때문이다.

일반적인 인덱스(클러스터링 되지 않은 인덱스)는 레코드를 저장하는 시점에 임의의 빈 공간에 레코드를 저장한다. 하지만 클러스터링 인덱스는 인덱스 키 값 순서대로 데이터를 저장하는 인덱스 구조라서 INSERT가 느리게 처리된다. 하지만 클러스터링 키 값을 대상으로 범위 검색을 수행하는 경우엔 별도의 랜덤 액세스 없이 레코드를 읽기 때문에 매우 빠르게 레인지 스캔을 수행할 수 있다.

## 2. 인덱스 내부
MongoDB의 프라이머리 키는 클러스터링 인덱스가 아니므로 프라이머리 인덱스와 세컨더리 인덱스 간의 내부 구조는 차이가 전혀 없다. MongoDB의 B-Tree 구조에서 브랜치 노드에 있는 인덱스 키 엔트리는 키로 "인덱스 키 값, 사용자가 인덱스를 생성할 때 선택한 필드의 값"이며 이 값은 1개 이상일 수도 있다. 그리고 값으로 "B-Tree의 자식 노드 주소"를 갖는데, 이 값은 현재 B-Tree 상에서 자식노드(브랜치이거나 리프 노드일 수도 있음)의 주소를 저장한다.

그리고 B-Tree 리프 노드의 인덱스 키 엔트리는 다음과 같이 키와 값 쌍을 가진다. 리프 노드에서도 키로 갖는 "인덱스 키 값"은 사용자가 선택한 필드의 값이며, 값은 "Record-Id"로 MongoDB에서 내부적으로 키 값과 연결된 도큐먼트의 저장 주소를 의미한다. 여기에서 도큐먼트가 저장된 주소를 관리하는 "Record-Id"는 논리적인 주소일 수도 있지만 물리적인 주소일 수도 있다.

### 2.2 WiredTiger 스토리지 엔진의 Record-Id
WiredTiger 스토리지 엔진은 인덱스 키 엔트리에 논리 주소를 사용한다. 더 정확하게는 논리 주소라기보다 도큐먼트마다 고유의 식별자를 할당해서 Record-Id로 부여한다. 여기서 말하는 고유한 식별자는 자동 증가(Auto-Increment) 방식을 사용한다.

WiredTiger의 Record-Id도 64비트 정수 타입을 사용하며, 이 값은 컬렉션 단위로 별도의 자동 증가 값을 사용한다. 

WiredTiger 스토리지 엔진의 Record-Id는 도큐먼트 크기가 커져서 데이터 파일 내에서 위치가 이동되더라도 처음 할당된 논리적인 주소 값은 변하지 않고 계속 유지된다. 그래서 그런 이유로 저장된 위치가 변경되더라도 크게 부하가 없기 때문에, paddingFactor와 같은 빈 공간을 준비해둘 필요가 없다.

WiredTiger 스토리지 엔진은 그런 논리 주소로 어떻게 실제 데이터 파일의 도큐먼트를 찾는 걸까? 이를 위해 WiredTiger 스토리지 엔진은 내부적으로 Record-Id 값을 인덱스 키로 갖는 내부 인덱스를 하나 더 가진다. 더 정확하게는 Record-Id 값을 키로 하는 클러스터링 인덱스를 갖는다. 이 인덱스는 Record-Id 값을 키로 갖고 Document 실제 내용을 값으로 가진다.

그래서 WiredTiger 스토리지 엔진에서는 프라이머리 키나 세컨더리 인덱스를 이용해 도큐먼트를 검색할 때 두 번의 인덱스 검색을 수행해야 최종 결과를 얻을 수 있다. 이런 방식은 느리지만, 데이터 변경은 훨씬 더 유연하게 처리할 수 있게 해준다.

## 3. 로컬 인덱스(Local Index)
MongoDB는 다른 NoSQL DBMS와는 다르게 아주 다양한 형태의 세컨더리 인덱스를 지원한다. 사실 MongoDB가 지원하는 인덱스의 종류는 범용의 RDBMS보다 많아서 MongoDB를 온라인 트랜잭션(OLTP) 서비스에 사용하는 데 있어서 전혀 문제가 되지 않는다.  
MongoDB의 세컨더리 인덱스는 로컬(local) 인덱스로 관리되므로 각 샤드가 저장하고 있는 도큐먼트에 대한 인덱스만 갖는다. 정확하게 표현하면 MongoDB의 모든 인덱스는 샤드 단위로 로컬 데이터에 대한 인덱스를 관리한다. 그래서 프라이머리 인덱스나 유니크 인덱스는 샤드 키를 반드시 포함해야 하거나 응용 프로그램 수준에서 유니크함을 보장해야 한다.

MongoDB 인덱스도 다른 RDBMS의 인덱스와 동일하게 쿼리의 성능을 높이는 반면 도큐먼트의 생성 및 변경 처리 성능을 저하시킨다.  
RDBMS에서는 일반적으로 데이터의 생성 및 변경 작업을 유저의 요청에 따라 처리하지만, MongoDB에서는 각 샤드의 데이터를 균등하게 배치하기 위해서 밸런서(Balancer)가 백그라운드로 샤드 간 데이터를 자동으로 분산한다. 이때에도 밸런서는 데이터의 생성 및 삭제 작업을 수행하는데, 결국 인덱스가 많은 컬렉션은 그만큼 데이터 밸런싱 작업을 지연시키고 부하를 일으키는 원인이 될 수도 있다.

## 4. 인덱스 키 엔트리 자료 구조
MongoDB는 도큐먼트 데이터베이스이다. 그리고 이 도큐먼트들은 MongoDB 내부적으로 BSON이라는 형태의 JSON의 변형된 포맷으로 저장된다. MongoDB의 도큐먼트는 키-값(Key-Value) 쌍으로 된 JSON 포맷을 사용하므로 데이터 파일에 필드명과 필드 값이 같이 저장된다. 그래서 MongoDB 데이터는 RDBMS보다 디스크에 저장되는 데이터의 용량이 더 크다. 이렇게 키-값 쌍으로 구성된 도큐먼트는 MongoDB의 컬렉션에만 해당되는 이야기이지, 인덱스의 내부 저장 구조는 도큐먼트나 BSON 자료 구조를 사용하지 않는다.

일반적으로 MongoDB를 "스키마 프리 데이터베이스"로 많이 생각한다. 이는 컬렉션에는 맞는 이야기지만 인덱스에는 맞지 않은 이야기다. MongoDB의 인덱스는 내부적으로 별도의 스키마를 가지고 있으며, 각 인덱스가 어떤 종류의 인덱스고 그 인덱스들을 구성하는 필드가 어떤 것인지에 대한 메타 정보를 갖고 있다. 컬렉션에는 언제든지 원하는 필드를 가감하여 저장할 수 있지만, 인덱스를 다시 생성하지 않는 이상 user_name 필드로 생성된 인덱스에 새로운 필드를 추가할 수 없다.

# B-Tree 인덱스
B-Tree는 컬럼의 원래 값을 변형시키지 않고 (물론 값의 앞 부분만 잘라서 관리하기는 하지만) 인덱스 구조체 내에서 항상 정렬된 상태로 유지한다는 점이 가장 기본적으로 알고 있어야 할 부분이다. 

## 1. 구조 및 특성
컬렉션의 도큐먼트에는 필드의 이름과 값의 쌍이 저장되지만, 인덱스 데이터에는 필드 이름을 관리하지 않고 인덱스의 메타 정보에만 필드 이름이 관리된다. 그런데 서브 도큐먼트를 갖는 필드에 인덱스를 생성하면 그 땐 인덱스에도 필드 이름과 값의 쌍이 저장된다.

일반적으로 단일 값을 가지는 필드나 배열 값을 가지는 필드는 인덱스를 생성해도 필드의 이름이 인덱스에 저장되지 않으므로 필드 명이 길어도 인덱스의 크기에는 영향을 미치지 않는다. 하지만 서브 도큐먼트를 값으로 가지는 필드는 그 서브 도큐먼트의 자식 필드 이름이 모두 인덱스에 저장되므로 자식 필드의 이름이 길면 그만큼 인덱스의 크기에 영향을 미친다. 또 WiredTiger 스토리지 엔진은 인덱스가 저장되는 데이터 파일은 압축을 하지 않는다. 그래서 서비 도큐먼트의 필드명이 길면 인덱스의 크기를 훨씬 더 크게 만드는 역효과를 만들기도 한다.

그뿐만 아니라 서브 도큐먼트 필드에 대해서 생성되는 인덱스를 사용하려면 조건절이 서브 도큐먼트의 필드를 모두 가지고, 순서가 같을 때만 인덱스를 활용할 수 있다.

## 2. B-Tree 인덱스 키 추가 및 삭제
### 2-1. 인덱스 키 추가
기본적으로 B-Tree는 트리 상의 키 값이 변경되는 즉시 그 내용을 반영하는데, 만약 키 값이 존재하지 않으면 B-Tree의 리프 노드에 인덱스 값을 추가하고 그 하위에 데이터 레코드가 저장된 위치를 저장한다.  
만약 노드가 꽉 차게 되면 노드를 분리(Split)해야 하는데 이 경우에는 브랜치 노드의 변경이 필요할 수도 있고, 상위 연관 노드까지 변경해야 하는 경우도 있다. 이런 작업들로 인해 B-Tree는 상대적으로 쓰기 작업(새로운 키를 추가하는 작업)이 고비용인 것으로 알려져 있다. 또한 일반적으로 인덱스를 추가함에 따라서 INSERT 쿼리나 UPDATE 등의 쿼리들이 얼마나 성능상 영향을 받는지 궁금해 하는 경우가 많다.  

이 질문에 답변을 하려면 테이블의 필드 개수, 필드의 사이즈, 인덱스 필드의 특성 등을 확인해야 한다. 아주 대략적으로 계산하는 방법은 테이블에 레코드를 추가하는 비용을 1이라고 가정했을 때, 그 테이블의 인덱스에 키를 추가하는 작업 비용을 1~1.5 정도로 예측하는 것이 일반적이다. 일반적으로 컬렉션에 인덱스가 하나도 없다면 작업 비용이 1이고, 컬렉션에 3개의 인덱스(컬렉션의 모든 인덱스가 B-Tree라고 가정)가 있다면 5.5 정도의 비용(1.5*3 + 1)이 든다고 예측해볼 수 있다. 중요한 건 이 비용의 대부분이 메모리와 CPU에서의 비용이 아니라 디스크로부터 인덱스 페이지를 읽어 오는 비용이라는 것이다.

### 2-2. 인덱스 키 삭제
B-Tree의 키 값을 삭제할 땐 상당히 간단하다. 해당 키 값을 찾아서 그냥 삭제 마크만 하면 된다. 그렇게 마킹된 인덱스 키 공간은 그대로 방치되거나 재활용될 수 있다. 인덱스 키 삭제로 인한 마킹 작업 또한 디스크 쓰기가 필요하므로 이 작업 또한 자원이 소모되는 작업이다. 하지만 MongoDB에서는 내부적으로 캐시를 가지고 있기 때문에 변경된 데이터를 디스크에 기록하는 작업은 사용자의 데이터 변경 요청과는 별도로 비동기 처리된다.  

또한 WiredTiger 스토리지 엔진은 캐시의 페이지를 디스크에 기록할 때 항상 페이지의 내용을 리빌드하므로 이렇게 삭제 표기된 채로 남아있는 키 엔트리는 디스크의 데이터 파일에는 없다.

### 2-3. 인덱스 키 변경
인덱스의 키 값은 그 값에 의해 위치를 결정하게 하므로 B-Tree의 키 값을 변경하는 경우에는 (컬렉션의 도큐먼트와는 달리) 키 값을 찾아서 그 키 값을 변경하면 되는 것이 아니다.  
그래서 B-Tree의 키 값을 변경하는 작업은 먼저 키 값을 삭제한 다음, 다시 새로운 키 값을 추가하는 형태로 처리된다. 키 값의 변경으로 인해 발생하는 B-Tree 인덱스 키 값의 삭제와 추가 작업은 위에서 설명한대로 처리된다.

### 2-4. 인덱스 키 검색
인덱스를 검색하는 작업은 B-Tree의 루트 노드부터 시작해서 브랜치 노드를 거쳐 최종 리프 노드까지 비교하는 과정을 거치는데, 이 과정을 트리 검색(**Tree traversal**)이라고 한다. 검색은 FIND 쿼리에서만 사용되는 게 아니라 UPDATE나 DELETE에서도 사용되는데, 이 경우에도 인덱스가 있으면 빠르게 검색이 된다. B-Tree 인덱스를 이용한 검색은 100% 일치 또는 값의 앞 부분(Left-most part)이 일치할 때만 사용할 수 있고, 부등호(`<>`) 비교에는 B-Tree 인덱스의 검색 기능을 이용할 수 없다. 

인덱스를 이용한 검색에서 중요한 사실은 인덱스의 컬럼 값에 변형이 가해지면 비교 검색에 절대 B-Tree의 빠른 기능을 사용할 수 없다는 것이다. 변형된 값은 B-Tree에 존재하지 않기 때문에 함수나 어떤 연산을 적용한 결과로 정렬한다거나 검색하는 작업은 B-Tree의 특성을 이용할 수 없게 만들어 버리므로 주의해야 한다.

## 3. B-Tree 인덱스 사용에 영향을 미치는 요소
인덱스를 구성하는 필드들의 사이즈와 도큐먼트의 건수 그리고 해당 필드에서 유니크한 값의 개수 등에 따라 검색이나 변경 작업의 성능이 영향을 받는다.

### 3-1. 인덱스 키 값의 사이즈
MongoDB에서 디스크에 데이터를 저장하는 기본 다누이를 페이지 또는 블록이라고 하며, 모든 디스크의 읽기 및 쓰기 작업의 최소 작업 단위다. 페이지는 디스크의 저장 및 읽기 뿐만 아니라 MongoDB의 각 스토리지 엔진이 데이터를 관리하는 기본 단위이기도 하다. 인덱스도 페이지 단위로 관리되며, B-Tree 구조에서 루트와 브랜치 그리고 리프 노드를 구분한 기준 또한 페이지 단위이다. 그리고 B-Tree가 자식 노드를 몇 개 가지는지가 인덱스의 페이지 크기와 키 값의 사이즈에 따라 결정된다. 

그렇게 결정된 자식 노드 갯수가 하나의 페이지에 저장할 수 있는 노드 개수가 되고, 그 갯수가 한 번의 I/O로 조회할 수 있는 도큐먼트의 개수가 되어 성능과 연관되어 진다.

물론 내부적인 MongoDB의 스토리지 엔진은 메모리 캐시를 활용하기 때문에 이 결과가 정확하지 않을 수도 있지만, 기본적으로 그렇다는 것이다. 

### 3-2. B-Tree 깊이
B-Tree의 깊이는 MongoDB에서 값을 검색할 때 몇 번이나 랜덤하게 디스크를 읽어야 하는지와 직결된다. 인덱스 키 값의 사이즈가 커질수록 인덱스 페이지가 담을 수 있는 키 값의 개수가 작아지고, 그로 인해서 동일한 레코드 건수라 하더라도 B-Tree의 깊이가 깊어져서 디스크 읽기가 더 많이 수행되어야 한다는 걸 의미한다.

그런데 깊이에 대해 깊게 고려할 필요는 없다. 실제 서비스에서 아무리 대용량의 데이터베이스라도 B-Tree의 깊이가 5 이상까지 깊어지는 경우는 거의 없기 때문이다. 

## 5. 컴파운드 인덱스
실제 서비스용 데이터베이스에서는 2개 이상의 필드를 갖는 인덱스가 더 일반적이다. 필드가 1개이든 그 이상이든 지금까지 이야기했던 내용과 차이는 없다.  
컴파운드 인덱스는 2개 이상의 필드가 연결됐다고 해서 "Concatenated Index"라고도 불린다.

데이터 건수가 작은 경우엔 브랜치 노드가 없는 경우도 있다. 

### 5.1 MongoDB의 복합 필드 인덱스
MongoDB의 인덱스는 하나의 필드로, 또는 여러 필드를 복합적으로 연결해서 구성할 수도 있다. 하나의 필드로만 구성된 경우를 단일 필드 인덱스라고 하며, 여러 필드가 복합적으로 연결된 인덱스를 컴파운드 인덱스라고 한다. MongoDB의 해시 인덱스는 단일 필드로만 생성할 수 있으며, 나머지 인덱스 알고리즘은 대부분 여러 필드를 복합적으로 묶어서 생성할 수 있도록 지원하고 있다.

MongoDB에서 여러 필드를 이용해 컴파운드 인덱스를 생성하는 경우 인덱스를 구성하는 각 필드가 서로 다른 정렬 방식을 가질 수도 있다. 

### 5.3 복합 인덱스의 장점
일반적으로 RDBMS의 컴파운드 인덱스는 단일 값을 가지는 컬럼을 결합해서 B-Tree 인덱스를 생성하는 개념이다. 하지만 MongoDB의 컴파운드 인덱스는 여러 타입의 인덱스를 혼합해서 결합할 수도 있다. 대표적으로 이미 살펴본 바와 같이 전문 검색 인덱스를 일반 단일 값을 가지는 필드와 결합해서 컴파운드 인덱스를 생성할 수 있으며, 공간 인덱스와 단일 값을 가지는 필드를 결합할 수도 있다. 

## 6. B-Tree 인덱스의 정렬 및 스캔 방향
인덱스 내에서 각 필드를 어떻게 정렬할 것인지는 인덱스를 최초에 생성하는 시점에 결정되며, 그 인덱스를 어떤 방향으로 읽을지는 쿼리가 원하는 값에 따라 옵티마이저가 실시간으로 만드는 실행 계획에 의해 결정된다.

### 6.1 인덱스의 정렬
만약 2개의 필드로 생성한 인덱스를 사용한 쿼리의 선행 필드가 상수로 고정된 경우에는 그 다음 필드가 오름차순이든지 내림차순이든지 관계없이 옵티마이저가 아무 방향으로나 인덱스를 사용할 수 있다.

### 6.2 인덱스 스캔의 방향
MongoDB는 인덱스를 처음부터 오름차순 또는 내림차순으로 혼합해서 생성할 수도 있지만, 그와 무관하게 인덱스 자체를 오름차순 또는 내림차순으로 스캔할 수도 있다. 

인덱스의 기본 정렬은 항상 오름차순으로 구현돼 있지만 이 인덱스를 읽는 방향에 따라 오름차순 또는 내림차순의 효과를 얻을 수 있다.  
인덱스를 오름차순으로 읽으면 최종적으로 출력되는 결과 레코드는 자동으로 오름차순으로 정렬된 결과이며, 내림차순으로 읽으면 그 결과는 내림차순으로 정렬된 상태의 결과를 받게 된다.   
인덱스의 읽기 방향이 달라지는 것은 주로 쿼리 문장의 정렬 처리나 최댓값 또는 최솟값 등의 최적화 처리가 수행되는 쿼리들이다. 

## 7. B-Tree 인덱스의 가용성과 효율성
### 7-1. 비교 조건의 종류와 효율성
인덱스가 조회에 사용될 때 비교 작업의 범위를 좁히는 데에 도움을 주는 사용 케이스가 있고, 아무런 도움을 주지 못하는 사용 케이스가 있다.  

공식적인 명칭은 아니지만 전자처럼 작업 범위를 결정하는 조건을 "작업 범위 결정 조건", 후자처럼 비교 작업의 범위를 제한하지 못하고 단순히 걸러주는 역할만 하는 조건을 "필터링 조건" 또는 "체크 조건"이라고 표현한다.  
작업 범위 결정 조건은 많으면 많을수록 쿼리의 처리 성능을 높이지만, 체크 조건은 많으면 많을수록(최종적으로 가져오는 레코드는 작게 만들지 몰라도) 쿼리의 처리 성능을 높이진 못한다. 오히려 더 느리게 만드는 경우도 많다.

### 7-2. 인덱스의 가용성
B-Tree 인덱스의 특징은 왼쪽 값을 기준(Left-most)으로 오른쪽 값이 정렬돼 있다는 것이다.   
여기서 왼쪽이라 함은 하나의 컬럼 안에서 뿐만 아니라 다중 컬럼 인덱스의 컬럼에 대해서도 동일하게 적용된다. 즉 하나의 컬럼에서도 왼쪽 값 없이는 인덱스 검색이 불가능하고, 다중 컬럼 인덱스에서도 왼쪽 컬럼 없이는 인덱스를 사용한 검색이 불가능하다. 

### 7-3. 가용성과 효율성 판단
기본적으로 B-Tree 인덱스의 특성 상 다음과 같은 조건을 사용할 땐 인덱스를 활용할 수 없다. 여기서 활용할 수 없다는 표현은 작업 범위 결정 조건으로 사용할 수 없다는 뜻이며, 경우에 따라서 인덱스의 체크 조건으로는 사용할 수 있다.

- NOT-EQUAL로 비교된 경우(`$ne`, `$nin`)
- 문자열 패턴 검색에서 프리픽스 일치가 아닌 경우
- 문자열 데이터 타입의 콜레이션이 컬렉션이나 인덱스의 콜레이션과 다른 경우

# 멀티 키 인덱스
MongoDB는 도큐먼트 기반의 비정규화된 데이터를 저장하는 데이터베이스이므로 도큐먼트가 배열 형태의 데이터를 가지는 경우에 배열의 각 아이템을 검색할 수 있는 인덱스가 꼭 필요하다. 만약 없다면 **컬렉션 스캔(Collection Scan)**을 수행해야 한다. 이는 다음과 같은 문제를 야기한다.

1. **전체 도큐먼트 검사** 
   - 배열 내 특정 값을 찾기 위해 모든 도큐먼트를 순차적으로 검사 
   - 각 도큐먼트의 배열을 하나씩 펼쳐서 확인해야 함
2. **O(n) 시간 복잡도**
   - 데이터량이 증가할수록 검색 시간이 선형적으로 증가 
   - 수백만 개의 도큐먼트가 있다면 검색 시간이 급격히 늘어남

그래서 MongoDB에 멀티 키 인덱스가 존재한다. 멀티 키는 이름 그대로 하나의 도큐먼트가 여러 개의 인덱스 키를 가지는 형태다. 반대로 표현하면 여러 개의 인덱스 키가 하나의 도큐먼트를 가리키는 구조이다. 

멀티 인덱스는 일반 B-Tree 인덱스를 생성하는 구문과 아무런 차이가 없다. MongoDB는 하나의 도큐먼트에서 인덱스가 된 필드가 여러 번 나타나는 경우에 자동으로 그 인덱스를 멀티 키 인덱스로 정의한다. 실제 MongoDB 내부에선 멀티 키 인덱스인지 단일 키 인덱스인지 구분하는 것이 거의 무의미하며, 단순히 플래그 수준으로만 관리한다.   
인덱스를 생성하는 시점에는 배열 값이 없었는데, 서비스하는 도중에 응용 프로그램의 요건이 바뀌어서 배열이 저장될 수도 있기 때문이다. 그렇게 사용하는 도중에 배열이 저장되는 경우에는 MongoDB의 인덱스가 단일 키 인덱스로 사용되다가 배열 값이 저장되는 시점부터 멀티 키 인덱스로 변경된다. 

## 1. 멀티 키 인덱스의 주의 사항
멀티 키 인덱스는 여러 개의 인덱스 키 엔트리가 하나의 도큐먼트를 가리키고 있기 때문에, 쿼리 검색 조건으로 멀티 키 인덱스를 사용할 땐 검색 조건의 바운드에 주의해야 한다.  
검색 조건에서 바운드는 쿼리 조건이 원하는 결과를 얻기 위해 인덱스를 스캔해야 하는 범위를 의미하는데, 멀티 키 인덱스의 스캔 범위 결정 방식은 일반 인덱스와는 조금 다르게 결정된다. 

일반적으로 범위 조건을 사용할 때  쓰는 BETWEEN 연산자가 MongoDB에는 없기 때문에 `db.some.find({'특정필드': { $gte: 3, $lte: 6} })` 같이 작성하게 된다. 근데 이는 BETWEEN 연산자와 다르게 3보다 같거나 큰 것과 6보다 작거나 같은 것들의 합집합이 결과이다.

우리가 아는 BETWEEN 연산자와 같은 결과를 얻기 위해서는 `$elemMatch` 연산자를 사용해야 한다. `db.some.find({'특정필드': { $elemMatch: { $gte: 3, $lte: 6} } })` 처럼 사용한다. 이는 두 결과의 교집합을 구하는 것으로 결과가 조합된다.

서브 도큐먼트의 필드에 멀티 키 인덱스를 생성한 경우에는 또 다르다. `$elemMatch` 연산자를 사용하지 않을 땐 `db.some.find({'서브도큐먼트.특정필드': { $gte: 3, $lte: 6} })` 처럼 사용하면 되는데 `$elemMatch` 연산자를 사용할 땐 

```
db.some.find(
{'서브도큐먼트': { $elemMatch: { '특정필드': { $gte: 3, $lte: 6} } } })
```
와 같이 JSON 경로를 분리해서 `$elemMatch` 조건을 기재해야 한다. 그렇지 않고 `db.some.find({'서브도큐먼트.특정필드': { $elemMatch: { $gte: 3, $lte: 6 } } })` 처럼 사용하면 잘못된 문법으로 작성한 쿼리인데도 아무런 에러를 반환하지 않는다. 그래서 실수하기 쉽다. 결과는 `Not-Found` 로 나올 것이다.

# 인덱스 속성
MongoDB는 여타의 NoSQL DBMS보다 인덱스의 종류(알고리즘)도 다양하지만, 각각의 인덱스가 가질 수 있는 속성도 다양하다. 일반적인 RDBMS가 제공하는 유니크 인덱스뿐 아니라 인덱스 필드가 NULL이 아니어야 한다는 조건이나 다른 지정된 조건을 만족하는 경우에만 인덱스에 추가하는 것도 가능하다.  
그리고 MongoDB에선 LSM 스토리지 엔진이 일반적으로 제공하는 TTL 인덱스도 제공한다. 

## 1. 프라이머리 키와 세컨더리 인덱스
MongoDB에서도 컬렉션마다 단 하나의 프라이머리 키만 가질 수 있으며, 그 이외의 인덱스는 모두 세컨더리 인덱스라고 한다. 프라이머리 키는 반드시 유일한 값을 가져야 해서 유니크 인덱스를 생성할 수 없는 해시 인덱스는 사용할 수 없다. 

MongoDB의 프라이머리 키는 _id 필드로 고정되어 있어서 컴파운드 인덱스를 프라이머리 키로 선정할 수 없다. 하지만 여러 필드를 묶어서 프라이머리 키로 설정하는 건 가능하다.

```
db.user.insert( { _id: {name: "matt", birth_year: 1980},
    address: "경기도 광주",
    ...
})
```

이렇게 하나의 필드에 도큐먼트를 저장하는 경우에는 검색 쿼리를 작성할 때 주의해야 할 점이 있다. 서브 도큐먼트를 인덱스 키로 사용하는 경우엔 서브 도큐먼트의 필드 개수와 필드 이름, 그리고 필드 값까지 같아야만 같은 값으로 판정한다는 것이다.

물론 검색 조건에 사용된 도큐먼트의 필드 개수나 순서에 상관없이 검색하고자 한다면 다음과 같이 각 필드(`_id.birth_year`와 `_id.name`)를 조건에 명시하면 된다.

```
db.user.find({"_id.birth_year": "1980-01-01", "_id.name": "matt})
```

하지만 이렇게 쿼리 조건에 각 필드를 나열하면 _id 필드에 생성된 프라이머리 키 인덱스를 사용하지 못하게 되어 풀 컬렉션 스캔을 하게 된다.

