# 잠금
MongoDB 서버에서도 멀티 스레드의 동시 처리 중에 발생할 수 있는 스레드 간의 충돌 문제를 막기 위해 데이터베이스와 컬렉션, 그리고 도큐먼트의 잠금을 사용한다. 그리고 여러 계층의 데이터베이스 오브젝트들에 대한 동시 처리를 위해 인텐션 락(Intention Lock)과 다중 레벨의 잠금(Multiple granularity locking)을 활용하고 있다. 또한 MongoDB의 잠금은 MongoDB 서버 3.0 버전부터 스토리지 엔진 아키텍처를 채용하면서 MongoDB 서버 차원에서 처리되는 잠금과 각 스토리지 엔진에서 처리되는 잠금으로 나누어 볼 수 있다.

MMAPv1 스토리지 엔진은 자체적인 잠금 없이 MongoDB 서버의 잠금에만 의존했었다. 그래서 단순히 데이터베이스의 각 오브젝트에 대한 공유 잠금(Shared Lock)과 배타적 잠금(Exclusive Lock)만 존재했었다.  
하지만 WiredTiger 스토리지 엔진이 도입되면서 데이터베이스와 컬렉션에 대한 공유 잠금과 배타적 잠금만으로는 동시성 처리 능력을 확장하는데 제한이 있고, WiredTiger 스토리지 엔진의 능력을 최대한 활용하는데에 어려움이 있었다. 그래서 WiredTiger 스토리지 엔진이 도입된 3.2 버전부터는 오브젝트에 대한 인텐션 잠금이 도입됐다.

## 1. MongoDB 엔진의 잠금
MongoDB 서버에서 제공하는 잠금은 크게 명시적 잠금과 묵시적 잠금으로 나눠볼 수 있는데, MongoDB에서 전자는 글로벌 잠금 뿐이며 나머지는 모두 후자이다.  
데이터베이스와 컬렉션에 대한 잠금은 모두 묵시적 잠금이며, 이는 쿼리가 실행될 때 자동으로 획득됐다가 자동으로 해제되는 잠금이다. 

### 1.1 글로벌 잠금
MongoDB 서버에서 유일하게 명시적으로 사용할 수 있는 잠금은 글로벌 잠금 뿐이다. 3.4 버전에서의 다른 모든 잠금은 묵시적으로만 사용된다.  
즉, 쿼리나 데이터 변경 명령이 실행되면 묵시적으로 MongoDB 서버에서 잠금을 획득했다가 필요 없는 시점에 자동으로 해제된다.

글로벌 잠금은 MongoDB 서버 인스턴스에 단 하나만 있는 잠금으로써, 인스턴스 잠금이라고도 부른다. 이를 사용하는 방법은 다음과 같다.

```
db.fsyncLock({fsync:1, lock:true})
```

fsync 옵션을 1로 설정하면 MongoDB 서버는 디스크에 기록되지 못한 데이터를 모두 디스크로 플러시(기록)한다. 그리고 lock 옵션이 true로 설정되면 MongoDB 서버의 글로벌 잠금을 획득한다.  
만약 lock 옵션이 false가 되면 MongoDB 서버의 데이터 파일만 디스크로 플러시하고, 잠금을 걸지는 않는다. 

`fsyncLock()` 며영은 내부적으로 쓰기 잠금이 아니라 읽기 잠금에 해당한다. 그래서 MongoDB 서버의 데이터가 변경되는 것을 막는 용도의 잠금이다. 다른 커넥션이 데이터를 읽는 걸 막지는 않는다.

글로벌 잠금은 `fsyncUnlock()` 명령으로 풀 수 있다. MongoDB 메뉴얼에서는 `fsyncLock()` 명령을 실행한 커넥션을 닫지 말고 그대로 유지했다가 그 커넥션에서 `fsyncUnlock()`을 실행하라고 권고하고 있다. 

실제 테스트 해본 결과 다른 커넥션에서 실행해도 문제가 발생하지 않았지만 MongoDB 개발자는 문제가 생길 수 도 있으므로 그런 내용을 메뉴얼에 포함시켰다고 한다.

### 1.2 오브젝트 잠금
MongoDB 3.0 으로 업그레이드되면서 MMAPv1 스토리지 엔진은 '데이터베이스 수준의 잠금'에서 '컬렉션 수준의 잠금'으로 조금 더 최적화됐다. 컬렉션 단위의 잠금의 도입되면서 MongoDB 서버도 다른 RDBMS와 같이 계층형 오브젝트(데이터베이스와 컬렉션의 관계)에 대한 동시성 처리를 보장하기 위해 다중 레벨의 잠금(Multiple granularity locking) 방식이 도입됐다. 

이를 위해 MongoDB 서버에선 S 잠금(Shared Lock)과 X 잠금(Exclusive)에 더불어 IS 잠금(Intent Shared Lock)과 IX 잠금(Intent Exclusive Lock)을 제공한다. IS와 IX 잠금은 이름 그대로 의도(Intent)를 표현하는 잠금인데, 둘을 묶어 인텐션 잠금(Intention Lock)이라고도 한다.

## 2. WiredTiger 스토리지 엔진의 잠금
WiredTiger 스토리지 엔진은 다른 RDBMS처럼 도큐먼트(레코드) 기반의 잠금을 사용한다. 하지만 여전히 다양한 레벨의 오브젝트(데이터베이스와 컬렉션)에 대한 잠금을 위해 다중 레벨의 잠금(Multiple granularity locking) 방식도 같이 사용한다. WiredTiger 스토리지 엔진은 글로벌(인스턴스 레벨) 그리고 데이터베이스와 컬렉션 레벨의 인텐션 잠금을 활용하며, 인텐션 잠금은 데이터베이스 레벨이나 컬렉션 레벨의 명령과 도큐먼트 레벨의 명령이 최적의 동시성을 유지하면서 실행될 수 있게 해준다.

인텐션 잠금은 이름 그대로 특정 오브젝트에 대해 배타적 또는 공유 잠금에 대한 의도를 가지고 있다는 것을 의미하는데, 이는 현재 스레드가 특정 오브젝트에 대해서 읽기뿐만 아니라 변경 의도를 가지고 있음에도 다른 변경 의도를 가진 스레드도 허용하는 형태의 잠금이다.  
이런 형태의 요건은 주로 계층형 데이터 구조에서 사용되는데, 대표적으로 데이터베이스와 컬렉션 그리고 컬렉션 하위에 있는 도큐먼트의 관계이다. MongoDB의 각 오브젝트는 계층 구조를 가지며, 각 계층 구조에서 하위 오브젝트에 대한 잠금을 획득하려면 상위 계층의 인텐션 잠금을 먼저 획득해야 한다.

특정 도큐먼트를 변경하려면 해당 도큐먼트에 대해 쓰기 잠금(Exclusive Lock)을 획득해야 하는데, 이를 위해서는 먼저 글로벌 인텐션 잠금(Global Intention Exclusive Lock)과 데이터베이스 인텐션 잠금(Database Intention Exclusive Lock) 그리고 컬렉션 인텐션 잠금(Collection Intention Exclusive Lock)을 가져야 한다. 그리고 컬렉션의 도큐먼트를 읽기 위해서도 동일하게 글로벌 인텐션 잠금과 데이터베이스 인텐션 잠금, 그리고 컬렉션의 인텐션 감금을 획득해야 하는데, 이때에는 도큐먼트의 데이터를 변경하는 것이 아니고 읽는 것이므로 오브젝트 계층별로 읽기 인텐션 잠금(Intention Shared Lock)을 획득하게 된다. 

WiredTiger 스토리지 엔진에서는 데이터를 변경할때만 해당 도큐먼트에 대한 쓰기 잠금을 획득해야 하고, 읽기만 하는 경우엔 별도의 잠금을 이용하지 않는다. 이를 MVCC라고 한다.

## 3. 잠금 Yield
대부분의 RDBMS는 쿼리를 처리하기 위해 한 번 잠금을 획득하면 쿼리의 처리가 완료(또는 실패)될 때까지 한 번 획득한 잠금을 다시 해제하지는 않는다. 하지만 MongoDB 서버는 트랜잭션을 지원하지 않는 NoSQL DBMS로부터 시작했기 때문에 트랜잭션의 요건이 그다지 크지 않았을 뿐만 아니라 트랜잭션이 주요 목표가 아니었다. 트랜잭션보다는 높은 동시성 처리가 더 우선순위였는데, 이런 목표를 위해 MongoDB 서버에서는 설정된 조건보다 오랜 시간 실행되거나 자원을 소모하는 경우에는 잠깐 쉬었다가 다시 처리를 재게하도록 구현했다.

이렇게 쿼리를 실행하는 도중에 잠깐 쉬었다가 쿼리의 실행을 재개하는 것을 MongoDB 서버에서는 Yield(양보)라고 한다. MongoDB 서버의 Yield는 단순히 쿼리의 처리를 멈추고 잠깐 쉬는(Sleep) 것이 아니라, 처리 중인 쿼리를 위해서 획득했던 잠금까지 모두 해제하고 지정된 시간 동안 쉬게 된다.

Yield를 수행하는 규칙은 다음 두 가지이다.
1. 쿼리가 지정된 건 수의 도큐먼트를 읽은 경우
2. 쿼리가 지정된 시간 동안 수행된 경우

MongoDB 서버의 기본값은 128개의 도큐먼트를 읽었거나 10밀리초 이상 실행했을 때 Yield를 수행한다. 지금 서버의 설정이 어떻게 되어있는지 확인하려면 getParameter 명령을 사용하면 된다.

`db.runCommand( { setParmeter: 1, "intervalQueryExecYieldIterations" : 256 } )` 명령을 사용해 조정할 수 있다.

## 4. 잠금 진단
MongoDB 서버에서는 `db.currentOp()` 명령으로 현재 실행 중인 명령들의 목록을 조회할 수 있다. 이를 통해 클라이언트 정보, 쿼리의 내용, 그리고 잠금의 내용도 확인할 수 있다. 



# 트랜잭션
WiredTiger 스토리지 엔진이 제공하는 트랜잭션의 ACID(Atomicity, Consistency, Isolation, Durability) 속성은 다음과 같은 특성이 있다.
- 최고 레벨의 격리 수준은 Snapshot(Repeatable-Read)
- 트랜잭션의 커밋과 체크포인트 2가지 형태로 영속성(Durability) 보장
- 커밋되지 않은 변경 데이터는 공유 캐시 크기보다 작아야 함

기존의 RDBMS에서는 일반적으로 READ-UNCOMMITTED와 READ-COMMITTED 그리고 REPEATABLE-READ와 SERIALIZABLE 4가지 격리 수준을 제공한다.  

WiredTiger 스토리지 엔진은 SERIALIZABLE 격리 수준은 제공하지 않으며, REPEATABLE-READ와 같은 수준인 Snapshot 격리 수준이 최고 수준이다. 또한 WiredTiger 스토리지 엔진은 트랜잭션 로그(저널 로그)뿐만 아니라 체크포인트로도 영속성이 보장된다. 즉 트랜잭션 로그가 없어도 마지막 체크포인트 시점의 데이터를 복구할 수 있다. 

마지막으로 WiredTiger 스토리지 엔진의 트랜잭션 특성 중 중요한 것은 트랜잭션이 커밋되기 전에는 트랜잭션 로그를 디스크로 기록하지 않는다는 것이다. 그래서 하나의 트랜잭션이 변경할 수 있는 데이터 크기는 WiredTiger 스토리지 엔진이 가진 공유 캐시의 크기로 제한된다. 이는 서비스 특성에 따라 문제가 될 수도 있고 아닐 수도 있다. 하지만 MongoDB 서버는 기본적으로 도큐먼트 기반의 트랜잭션만 지원하므로 MongoDB 서버에 내장된 WiredTiger 스토리지 엔진에서는 큰 문제가 되지 않는다.

WiredTiger 스토리지 엔진에선 READ-UNCOMMITTED와 READ-COMMITTED 그리고 SNAPSHOT(REPEATABLE-READ) 격리 수준을 제공하지만, 실제 MongoDB 서버에 내장된 WiredTiger 스토리지 엔진의 격리 수준을 선택해서 사용할 수는 없다. 현재 MongoDB 서버에서는 WiredTiger 스토리지 엔진의 격리 수준을 SNAPSHOT 레벨로 고정해서 초기화하기 때문이다. 그렇다고 MongoDB 서버가 WiredTiger 스토리지 엔진의 SNAPSHOT(REPEATABLE-READ) 격리 수준을 100% 보장하는 건 아니다. 

## 1. 쓰기 충돌
데이터 변경하는 도중 MongoDB 서버는 다른 RDBMS와 달리 쓰기 충돌이 발생할 수도 있다. 

하나의 데이터(도큐먼트)를 동시에 변경하려고 하는 상황에서 MongoDB는 어떻게 처리할까?  
MongodB 서버는 변경하고자 하는 도큐먼트가 이미 다른 커넥션에 의해 잠금이 걸려있으면 즉시 업데이트를 취소한다. 이때 MongoDB 서버의 각 스토리지 엔진은 WriteConflict Exception을 반환한다. 그러면 업데이트 명령을 실행했던 세션은 WriteConflict Exception을 받고, 같은 업데이트 문장을 재실행한다. 이런 재처리(Retry) 과정은 MongoDB 서버 프로세스 내부에서만 실행되며, 실제 응용 프로그램에서는 이런 재처리 과정이 있었는지 알아채지 못한다. 즉 WriteConflict로 인한 재처리 과정은 응용 프로그램에는 투명하게 작동하다.

기존의 RDBMS에서도 마찬가지이지만 MongoDB 서버에서 하나의 도큐먼트를 많은 스레드가 동시에 변경하려고 하는 경우에는 심각한 문제가 될 수도 있다. 기존의 RDBMS에서는 잠금 대기를 하는 세션의 개수가 늘어나게 되지만, MongoDB 서버에서는 UPDATE 문장의 실행이 폭증하는 현상이 발생한다. 그래서 MongoDB 서버에서 하나의 도큐먼트에 변경이 집중되면 CPU 사용량은 높아지지만 실제 처리 성능은 떨어질 가능성이 높다. 

