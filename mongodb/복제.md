MongoDB에서는 '마스터-슬레이브 복제'와 '레플리카 셋 복제'라는 두 가지의 복제 방식을 제공한다. 전자는 3.2 버전부터 Deprecated 방식으로 후자가 권장된다.

# 복제란?
복제는 여러 서버가 서로의 데이터를 동기화하는 것을 의미하는데, 서로 주고받는 데이터에 따라 논리 복제와 물리 복제로 나뉠 수 있다.  
물리적 복제는 DRBD처럼 리눅스 서버가 데이터의 내부를 전혀 모르는 상태에서 디스크의 블록만 복제하는 형태의 복제이다. 논리 복제는 데이터베이스 서버가 직접 서버 간에 데이터를 동기화하는 방식을 말한다.  
물리적 복제는 데이터베이스 서버가 전혀 관여하지 않으므로 운영체제 차원에서 응용 프로그램에 투명하게 복제를 처리할 수 있지만, 응용 프로그램의 캐시나 내부 처리 로직에서 변경된 데이터를 사용하지 못한다.   
특히 데이터베이스 서버처럼 복잡한 처리를 수행하는 응용 프로그램에서는 물리적 복제 방식은 장점보다 단점이 더 많은 편이다.

MongoDB는 MySQL 서버의 복제와 아주 비슷한 형태의 복제 기능을 가지고 있는데, 거기에 더해 프라이머리 노드의 선출과 네트워크 단절로 인한 스플릿 브레인(Split-Brain) 현상을 막을 수 있는 기능까지 내장하고 있다.

## 1. 컨센서스 알고리즘
여러 서버가 복제에 참여해 서로 같은 데이터를 동기화하는 형태에서 데이터를 공유하는 그룹을 **레플리카 셋**이라고 한다. 그리고 하나의 레플리카 셋의 멤버들은 프라이머리와 세컨더리로 역할이 나뉘어진다.  
레플리카 셋의 멤버들이 어떻게 서로의 데이터를 동기화하고, 특정 노드의 장애 발생 시 어떻게 대처할 것인지 등등에 대해 결정하는 것을 컨센서스 알고리즘이라고 하는데, MongoDB 서버는 확장된 형태의 *Raft 컨센서스 모델*을 사용한다.

*Raft 컨센서스 알고리즘*의 가장 큰 특징은 **리더 기반의 복제**와 각 멤버 노드가 **상태를 가진다**는 것이다.  
하나의 레플리카 셋에는 반드시 **리더가 하나만** 존재할 수 있고, 리더만이 사용자의 모든 데이터 변경 요청을 처리한다. 그리고 리더는 사용자의 데이터 변경 요청 내용을 로그에 기록하고, 모든 팔로워는 리더의 로그를 가져와서 동기화를 수행한다.  
Raft 컨센서스 알고리즘의 리더를 MongoDB에서는 프라이머리 노드라고 하며, 팔로워는 세컨더리 노드라고 한다. 그리고 로그를 OpLog라고 한다.

## 2. 복제의 목적
가장 큰 목적은 동일한 데이터를 이중 삼중으로 유지해서 특정 노드에서 데이터 손실이 발생하더라도 다른 멤버의 데이터로 대체할 수 있도록 하기 위함이다. 즉, **고가용성**을 위해 중복된 데이터 셋을 준비하는게 목적의 방향이다.

고가용성을 위해 MongoDb 레플리카 셋 멤버들은 서로 확인 메세지를 주고받는 걸 계속하는데, 이를 **하트비트 메시지**라고 한다. 만약 특정 멤버(프라이머리 멤버)가 통신이 되지 않으면, 다른 멤버들이 새로운 프라이머리 멤버를 선출해서 서비스가 지속적으로 처리될 수 있게 한다. 이렇게 새로운 프라이머리 멤버를 선출하는 과정은 MongoDB 샤딩이나 MongoDB 컨피그 서버와 무관하게 진행된다.

복제의 또 다른 목적으로는 데이터 조회 쿼리의 로드 분산이 있다. 고가용성을 위해 레플리카 셋에 너무 많은 멤버를 투입할 필요는 없다. 일반적으로 3대 정도의 서버로 구성하는데, 데이터 조회가 아주 많은 서비스에서는 로드 분산의 용도로 더 추가할 수도 있다. 데이터 쓰기 작업은 어차피 프라이머리 노드만 처리할 수 있기 때문에 멤버를 늘린다고 해서 성능을 높일 수 없다. 읽기 쿼리를 프라이머리에서 수행할지 세컨더리에서 수행할지 결정할 수 있도록 MongoDB 클라이언트 드라이버들은 **Read Preference 옵션**을 제공한다.

마지막으로 백업의 목적성도 어느정도 있다고 할 수 있다. 복제와 백업은 동떨어진 개념이지만, 백업을 실 서비스에서 활용하기에 애로사항이 있어서 그렇다.  
MongoDB는 아직 서비스 도중에 가능한 물리적인 백업 기능(온라인 물리 백업)을 제공하지는 않는다. 논리적인 백업은 서비스 도중에도 가능하지만 데이터 복구 시간이 상대적으로 길어서 긴급하게 데이터를 복구해야 하는 시점에는 도움이 되지 못할 수도 있다. 그래서 MongoDB에선 세컨더리 멤버를 멈추고 데이터 파일을 복사해야 할 수도 있다. 


# 레플리카 셋 멤버
하나의 MongoDB 레플리카 셋에는 최대 50개까지 멤버가 복제에 참여할 수 있다. 그런데 멤버끼리의 하트비트 메세지는 P2P 방식이므로 멤버 수가 많아질 수록 통신 비용이 매우 커진다. 따라서 불필요하게 많은 멤버를 추가하는 것은 피해야 한다.

그리고 멤버가 몇명이건 프라이머리 멤버 선출에 참여할 수 있는 멤버의 수는 7개이다. 선출 작업이 복잡한 과정을 거쳐야 하기 때문에 있는 전략이다. 따라서 멤버가 7개가 넘어서게 되면 7개 이외의 멤버는 Non-Voting 멤버로 설정돼야 한다.

## 1. 프라이머리
프라이머리 멤버는 레플리카 셋에서 데이터 변경을 처리할 수 있는 유일한 멤버다. 데이터 조회 쿼리도 처리할 수 있어 기본적으로는 프라이머리로 요청이 처리된다. 만약 특정 데이터 조회 쿼리를 세컨더리로 요청하고자 한다면 Read Preference 옵션을 조정해 쿼리를 실행하면 된다.

## 2. 세컨더리
하나의 레플리카 셋에서 세컨더리 멤버는 1개 이상 존재할 수 있으며, 프라이머리 멤버가 응답 불능 상태가 되면 투표를 통해 하나가 프라이머리 멤버가 된다. 그렇게 세컨더리 멤버가 프라이머리 멤버로 역할이 변경되는 걸 프로모션 또는 **스텝 업**이라고 한다.

세컨더리 멤버는 사용자의 데이터 변경 요청을 직접 처리할 수는 없지만 Read Preference 옵션을 이용해 읽기 요청은 처리할 수 있다. 이를 통해 읽기 쿼리의 부하를 분산할 수 있지만, 특정 세컨더리 멤버를 선택해서 요청하는 건 불가능하다. 응용 프로그램이 특정 세컨더리 멤버에 접속하지 못하도록 "hidden" 레플리카 셋 옵션을 이용할 수는 있다.

세컨더리 멤버는 고가용성과 읽기 쿼리의 부하를 분산시키는 용도로는 활용될 수 있지만, 데이터 백업의 용도로는 활용되기 어렵다. 프라이머리를 팔로업하면서 실시간으로 데이터를 동기화하므로 사용자의 실수 등으로 인해 프라이멤버에서 유실된 경우 세컨더리 멤버에도 유실되기 때문이다. 세컨더리에 지연된 복제를 적용해 이를 완화할 수는 있지만 한계가 있으므로 오프라인 상태의 백업은 필수다.

## 3. 아비터
아비터는 다른 역할을 하는 세컨더리 멤버로, 세컨더리 멤버와 다르게 프라이머리 노드와 데이터 동기화는 수행하지 않으면서, 프라이머리 선출에만 관여한다. 정족수를 채우기 위해 멤버가 필요한 경우에 주로 아비터를 사용한다. 

프라이머리 선출에는 레플리카 셋 멤버 수의 과반수 이상이 응답할 수 있는 상태여야 하는데, 불가능한 상태가 발생했을 때 아비터를 추가하는 것이 용이하다. 아비터가 아닌 멤버를 추가했을 때 초기 동기화 시간이 많이 들기 쉽기 때문이다. 


# 프라이머리 선출
레플리카 셋에 프라이머리 멤버가 없으면 데이터 변경 요청을 처리할 수 없게 되는 건 물론이고, Read Preference 옵션에 따라 때론 읽기 쿼리조차 불가능할 수 있다. 

## 1. 프라이머리 텀
여러 멤버가 동시에 투표를 하면 중복 투표가 발생할 위험이 있다. 그래서 MongoDB 3.2 이전 버전에서는 프라이머리 선출 투표는 30초에 한 번만 실행될 수 있게 설계됐다.  
그리고 중복 투표나 30초 대기 시간의 발생을 줄이고자 2단계 투표를 실행하도록 설계됐다. 사전 투표와 본 투표 두 단계로 나뉜다. 프라이머리가 되려는 세컨더리가 다른 멤버들에게 반대 여부를 확인하고, 반대하지 않으면 본 선거를 시작하는 것이다. 하지만 이는 복잡하여 프라이머리 텀이라는 개념이 도입됐다. 

프라이머리 텀은 사실 투표 식별자이며, 레플리카 셋의 각 멤버들이 프라이머리 선출을 시도할 때마다 1씩 증가하는 논리적인 시간 값이다. 각 멤버들은 투표 요청이 오면 30초 동안 기다리는 것이 아니라 프라이머리 텀 값을 기준으로 자기가 이미 투표를 했는지 아니면 다시 투표에 참여해야하는지 결정할 수 있다.   
그리고 프라이머리 텀은 투표할 때만 사용되는게 아니라, 프라이머리 멤버가 사용자 데이터 변경 요청을 실행한 다음에 변경 내용을 OpLog에 기록할 때마다 현재 프라이머리 텀 값을 같이 기록한다. 그 값으로 특정 OpLog가 어느 멤버가 프라이머리 멤버였을 때의 로그인지 식별한다.

항상 선출이 성공하는 것은 아니다. 실패하면 프라이머리 텀 값만 증가(예를 들어, 값이 3이다)하고 끝나게 된다. 그렇게 실패하면 텀 값을 또다시 증가(그럼 값이 4가 된다)시켜서 다시 새로운 투표를 시작하게 된다.

## 2. 프라이머리 스텝 다운
프라이머리에 장애가 생기거나 없어지는 상황 뿐 아니라 관리자가 의도적으로 프라이머리를 세컨더리로 내리는 것도 가능하다. 

- `rs.stepDown()` 명령으로 프라이머리를 스텝 다운
- `rs.reconfig()` 명령으로 레플리카 셋 멤버의 우선순위 변경

`rs.stepDown()` 명령은 다음의 2개의 인자를 사용할 수 있다.

```
rs.stepDown(stepDownSecs, secondaryCatchUpPeriodSecs)
```

`rs.stepDown()` 명령은 현재 프라이머리인 멤버에서만 실행할 수 있는데, 이 명령이 실행되면 명령을 요청받은 프라이머리는 즉시 프라이머리를 내려놓고 stepDownSecs 파라미터에 지정된 시간 동안 다시 프라이머리가 될 수 없다. 만약 그 시간동안 다른 세컨더리가 프라이머리가 되지 못하면 원래 프라이머리였던게 다시 될 가능성이 높다.

프라이머리가 빨리 선출되어야 사용자 요청을 빠르게 처리할 수 있겠지만, 기존의 프라이머리가 스텝 다운되는 시점에 다른 세컨더리가 그 프라이머리의 OpLog에서 모든 변경 사항을 가져왔다는 걸 보장하기 어렵다. 복제가 지연된 상황에선 많은 시간이 필요할 수 있기 때문에 두번째 인자인 secondaryCatchUpPeriodSecs 의 숫자만큼 새로 선출하지 않고 기다리면서 복제가 동기화되는 걸 기다린다. 다만, 복제가 다 완료되어도 그 값만큼 기다리지는 않고 바로 선출을 시작한다.

`rs.reconfig()` 는 우선순위를 변경하는데 이게 곧 프라이머리 스텝다운을 유발하게 된다(반드시는 아님). 프라이머리 노드는 자신보다 우선순위가 높은 멤버가 나타나면 그걸 인지하고 즉시 프라이머리 롤을 버리고 세컨더리로 전환하게 된다. 그리고 선출이 발생해 가장 높은 우선순위를 가진 멤버가 프라이머리가 된다.

## 3. 프라이머리 선출 시나리오
