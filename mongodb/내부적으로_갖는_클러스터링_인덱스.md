# WiredTiger의 클러스터링 인덱스 구조
## 클러스터링 인덱스 (Primary Index)
- **키**: 내부 Record-Id (RecordId)
- **값**: 실제 도큐먼트의 전체 내용 (BSON 데이터)

## Record-Id의 특징
- WiredTiger는 각 도큐먼트에 대해 내부적으로 고유한 Record-Id를 생성
- 이 Record-Id는 일반적으로 8바이트 정수값
- 사용자가 정의한 `_id` 필드와는 별개의 내부 식별자

## 인덱스 구조의 장점
``` 
클러스터링 인덱스: Record-Id → 전체 도큐먼트
보조 인덱스: 인덱스 키 → Record-Id
```
1. **효율적인 저장**: 보조 인덱스들은 Record-Id만 저장하면 되므로 공간 효율적
2. **빠른 조회**: Record-Id를 통해 클러스터링 인덱스에서 직접 도큐먼트 조회
3. **업데이트 효율성**: 도큐먼트가 업데이트되어도 보조 인덱스의 Record-Id는 변경되지 않음

## 조회 과정
1. 보조 인덱스 검색 → Record-Id 획득
2. 클러스터링 인덱스에서 Record-Id로 도큐먼트 조회
3. 전체 도큐먼트 반환

이러한 구조는 관계형 데이터베이스의 클러스터링 인덱스와 유사한 개념이지만, MongoDB의 도큐먼트 기반 특성에 맞게 최적화되어 있다.

# vs MySQL의 클러스터링 인덱스
## MySQL InnoDB의 클러스터링 인덱스 구조
- **클러스터링 인덱스 (Primary Index)**
  - **키**: Primary Key 값 (사용자 정의 또는 자동 생성된 row_id)
  - **값**: 전체 행(row)의 데이터

## 주요 차이점

| 구분              | MongoDB WiredTiger | MySQL InnoDB     |
|-----------------|--------------------|------------------|
| **클러스터링 인덱스 키** | 내부 Record-Id       | Primary Key 값    |
| **키의 가시성**      | 사용자에게 숨겨짐          | 사용자에게 노출됨        |
| **키 선택**        | 시스템이 자동 생성         | 사용자 정의 또는 시스템 생성 |

## MySQL InnoDB의 상세 구조
``` sql
-- 예시 테이블
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    email VARCHAR(100)
);
```

**클러스터링 인덱스 구조:**
``` 
키: id 값 (1, 2, 3, ...)
값: 전체 행 데이터 (id, name, email)
```

**보조 인덱스 구조:**
``` 
키: 인덱스 컬럼 값
값: Primary Key 값 (Record-Id가 아님!)
```

## 조회 과정 비교
1. **MySQL InnoDB:**
   1. 보조 인덱스 검색 → Primary Key 값 획득
   2. 클러스터링 인덱스에서 Primary Key로 행 조회
2. **MongoDB WiredTiger:**
   1. 보조 인덱스 검색 → Record-Id 획득
   2. 클러스터링 인덱스에서 Record-Id로 도큐먼트 조회

## 핵심 차이점
- **MySQL**: 사용자가 정의한 Primary Key가 물리적 저장 순서를 결정
- **MongoDB**: 내부 Record-Id가 물리적 저장 순서를 결정하며, 사용자의 `_id`와는 독립적

필자는 이러한 차이는 각 데이터베이스의 설계 철학과 사용 패턴에 따른 최적화 결과로 해석한다.
