# MongoDB, WiredTiger 스토리지 엔진, 기본 키와 클러스터링 인덱스
WiredTiger 스토리지 엔진을 사용하는 MongoDB는 클러스터링 인덱스라는 것을 기술 명세로 갖고 있으며 MySQL과 닮은 점이 많지만, 분명히 다른 설계와 구현을 갖고 있다. 다수의 개발자가 MySQL과 InnoDB 스토리지 엔진에 대한 경험이 풍부하고, 필자도 그러하므로 해당 내용을 설명할 때 곁들여서 공부해보자. 

## MySQL InnoDB의 클러스터링 인덱스
InnoDB는 테이블 자체가 클러스터링 인덱스이다. Primary Key 순서대로 실제 데이터가 물리적으로 정렬되어 저장된다.

```
Primary Key 인덱스 (B+Tree)
├─ Leaf Node에 실제 row 데이터 전체 저장
└─ PK로 조회 시 인덱스 탐색 = 데이터 접근 (추가 I/O 없음)

Secondary Index (B+Tree)
├─ Leaf Node에 PK 값만 저장
└─ Secondary Index 조회 시: Index → PK 획득 → PK Index 재탐색
```

### 특징
- PK 변경 시 물리적 재배치 발생 (매우 비용이 큼)
- PK 범위 스캔이 매우 효율적 (연속된 페이지 읽기)
- Secondary Index는 항상 PK를 거쳐야 함 (북마크 룩업)

## MongoDB WiredTiger의 클러스터링 인덱스
WiredTiger는 클러스터링 인덱스가 선택 사항이며, 방식도 다르다.

```
_id 인덱스 (기본)
├─ B-Tree 구조
└─ Leaf Node에 RecordID(내부 위치 포인터) 저장

실제 데이터
└─ 별도 저장소에 삽입 순서대로 저장 (힙 구조)

Clustered Index (선택적)
├─ clusteredIndex 옵션으로 컬렉션 생성 시 지정
└─ _id 또는 다른 필드로 클러스터링 가능
```

### RecordId
- 64비트 정수값
- WiredTiger가 자동 생성
  - 사용자 접근 불가
- 문서가 저장된 물리적 위치를 가리키는 포인터
- 단조 증가하는 값(삽입 순서 반영)
- 사용자가 정의하거나 자동 생성되는 `_id` 필드와는 별개

### 특징
- 기본적으로는 힙 구조 (MySQL MyISAM과 유사)
- 클러스터링을 원하면 명시적으로 clusteredIndex 옵션 사용 
- 클러스터링 키 변경 시에도 InnoDB보다 유연함 (문서 지향)

## 주요 차이점
1. 기본 동작
   1. InnoDB: 무조건 PK 기준 클러스터링 (선택 불가)
   2. WiredTiger: 기본은 비클러스터링, 옵션으로 활성화
2. 데이터 구조
   1. InnoDB: PK 인덱스 = 데이터 (인덱스 구조 자체가 테이블)
   2. WiredTiger: 인덱스와 데이터 분리 (클러스터링 시에도 더 느슨한 결합)
3. Secondary Index 동작
   1. InnoDB: Secondary Index → PK → 데이터 (2단계)
   2. WiredTiger: Index → RecordID → 데이터 (클러스터링 없을 때)
4. 범위 스캔 성능
   1. InnoDB: PK 범위 스캔 시 물리적 순차 읽기로 매우 빠름
   2. WiredTiger: 클러스터링 없으면 랜덤 액세스 발생 가능
5. 유연성
    ```javascript
    // MongoDB - 클러스터링 인덱스 생성
    db.createCollection("users", {
    clusteredIndex: {
    key: { _id: 1 },
    unique: true
    }
    })
    ```
    MySQL에서는 이런 선택권이 없고, 항상 PK로 자동 클러스터링된다.

실무적으로 보면, InnoDB의 강제 클러스터링은 PK 설계를 신중하게 해야 하는 이유이고 (UUID 같은 랜덤 값은 성능 저하), MongoDB는 더 유연하지만 성능 최적화를 위해 명시적으로 클러스터링을 고려해야 하는 구조이다.

