## 간접 참조 방식의 장점
### 1. **문서 크기 변경 시의 유연성**
``` 
직접 참조 방식 (예: MySQL InnoDB):
인덱스 → 실제 데이터 페이지 위치

간접 참조 방식 (WiredTiger):
인덱스 → Record-Id → 실제 데이터 페이지 위치
```
- **직접 참조**: 문서가 커져서 기존 페이지에 맞지 않으면, 모든 인덱스 항목을 업데이트해야 함
- **간접 참조**: Record-Id는 그대로 두고, 내부 클러스터링 인덱스의 값만 새로운 위치로 업데이트

### 2. **페이지 재배치 시의 효율성**
``` markdown
시나리오: 문서 A가 페이지 1에서 페이지 3으로 이동

직접 참조 방식:
- 프라이머리 키 인덱스 업데이트
- 세컨더리 인덱스 1 업데이트
- 세컨더리 인덱스 2 업데이트
- ... (모든 인덱스 업데이트 필요)

간접 참조 방식:
- 내부 클러스터링 인덱스만 업데이트
- 다른 인덱스들은 여전히 같은 Record-Id를 참조
```
### 3. **압축 및 재구성 작업**
``` javascript
// 예시: 문서 업데이트
db.collection.updateOne(
  { _id: ObjectId("...") },
  { $set: { largeField: "매우 큰 데이터..." } }
)
```
- **압축 과정에서 데이터 이동이 발생해도**, 모든 인덱스는 동일한 Record-Id를 계속 참조
- **백그라운드 압축 작업**이 인덱스 일관성에 영향을 주지 않음

### 4. **메모리 효율성**
- 각 인덱스는 실제 데이터 위치 대신 **고정 크기의 Record-Id**만 저장
- 데이터가 이동해도 인덱스 크기는 변하지 않음
- **캐시 효율성** 개선

## 성능 트레이드오프
### 단점: 두 번의 조회
``` 
1. 인덱스 검색 → Record-Id 획득
2. 클러스터링 인덱스 검색 → 실제 문서 데이터
```
### 장점: 변경 작업의 효율성
``` 
- 문서 업데이트 시 인덱스 유지보수 비용 감소
- 백그라운드 압축 작업의 안정성
- 메모리 사용량 최적화
```
이러한 설계는 MongoDB가 **읽기보다는 쓰기 작업의 유연성을 중시**하는 NoSQL 데이터베이스라는 특성과 잘 맞아떨어집니다. 특히 문서 구조가 자주 변경되고, 크기가 가변적인 MongoDB의 사용 패턴에 최적화된 방식이라고 할 수 있습니다.
