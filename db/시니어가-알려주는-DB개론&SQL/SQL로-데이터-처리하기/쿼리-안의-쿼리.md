- ID가 5인 임직원과 같은 프로젝트에 참여한 임직원들의 ID와 이름을 알고 싶다.
  - 이 경우에 FROM 절에 서브쿼리를 사용해 해결할 수 있다. 어떻게 할 수 있을까?
  - ```sql
    SELECT id, name
    FROM employee,
            (
                SELECT DISTINCT empl_id
                FROM works_on
                WHERE empl_id != 5 AND proj_id IN (
                    SELECT proj_id
                    FROM works_on
                    WHERE empl_id = 5
                )
    ) AS DSTINCT_E
    WHERE id = DSTINCT_E.empl_id;
    ```
    이렇게 해결할 수 있다.
- ID가 7 혹은 12인 임직원이 참여한 프로젝트의 ID와 이름을 알고 싶다.
  - IN을 사용해서 작성할 수도 있지만 EXISTS를 사용해 작성해보자. 어떻게 할 수 있겠는가?
  - ```sql
    SELECT p.id, p.name
    FROM projects p
    WHERE EXISTS (
        SELECT *
        FROM works_on w
        WHERE w.proj_id = p.id AND w.empl_id IN (7, 12)
    );
    ```
    이렇게 작성할 수 있다.
  - EXISTS가 사용된 쿼리는 개념적으로 어떻게 이해하면 될까? 아우터 쿼리부터 보는게 더 편하다. 아우터 쿼리를 보면 projects 테이블의 튜플들을 하나씩 확인을 한다. 확인을 하면서 무언가가 존재하는 튜플을 찾는 것이다.
    - 그 무언가가 서브쿼리에 명시되어있는 것이다. 서브쿼리를 확인해보면 projects 테이블에 있는 id값과 works_on 테이블에 있는 proj_id 값이 동일하고, works_on 테이블의 empl_id 값이 7과 12인 튜플을 찾으라는 것이다. 그래서 찾았더니 그에 해당하는 로우 혹은 튜플이 하나라도 있으면 WHERE 절이 TRUE를 리턴하게 되고, 그럼 그에 대한 projects 의 튜플은 선택이 된다.
  - **정리**
    - correlated query: subquery가 바깥쪽 query의 attribute를 참조할 때, correlated subquery라 부름
      - 위의 쿼리에서 EXISTS 키워드의 대상이 되는 서브쿼리가 correlated query이다.
    - EXISTS: subquery의 결과가 최소 하나의 row라도 있다면 TRUE를 반환
    - NOT EXISTS: subquery의 결과가 단 하나의 row도 없다면 TRUE를 반환
- 리더보다 높은 연봉을 받는 부서원을 가진 리더의 ID와 이름, 연봉을 알고 싶다.
  - ```sql
    SELECT e.id, e.name, e.salary
    FROM department d, employee e
    WHERE d.leader_id = e.id AND e.salary < ANY (
        SELECT salary
        FROM employee
        WHERE id <> d.leader_id AND dept_id = e.dept_id
    );
    ```
    `<>` 이 오퍼레이터는 `!=` 로도 쓸 수 있다.
  - **정리**
    - v comparsion_operator ANY (subquery): subquery가 반환한 결과들 중에 단 하나라도 v와의 비교 연산이 TRUE이면 TRUE를 반환한다.
    - SOME도 ANY와 같은 역할을 한다.
- 리더보다 높은 연봉을 받는 부서원을 가진 리더의 ID와 이름, 연봉, 해당 부서 최고 연봉을 알고 싶다.
  - ```sql
    SELECT e.id, e.name, e.salary, 
        (
            SELECT max(salary)
            FROM employee
            WHERE dept_id = e.dept_id
        ) AS dept_max_salary
    FROM department d, employee e
    WHERE d.leader_id = e.id AND e.salary < ANY (
        SELECT salary
        FROM employee
        WHERE id <> d.leader_id AND dept_id = e.dept_id
    );
    ```
    이 예제는 서브쿼리가 SELECT 절에 포함될 수도 있다는 것을 보여준다.
- ID가 13인 임직원과 같은 프로젝트에 한 번도 참여해보지 못한 임직원들의 ID, 이름, 직군을 알고 싶다.
  - ```sql
    SELECT DISTINCT e.id, e.name, e.position
    FROM employee e, works_on w
    WHERE e.id = w.empl_id AND w.proj_id <> ALL (
        SELECT proj_id
        FROM works_on
        WHERE empl_id = 13
    );
    ```
  - **정리**
    - v comparison_operator ALL (subquery): subquery가 반환한 결과들과 v와의 비교 연산이 모두 TRUE라면 TRUE를 반환한다.