# 데이터베이스 정규화 (Database Normalization)
- **목표**: 데이터 중복을 최소화하고, 데이터 무결성을 높이며, 데이터 삽입/삭제/수정 시 발생하는 '이상 현상'을 방제하기 위함.
- **방법**: 테이블을 더 작고 잘 조직된 테이블로 나누고, 테이블 간의 관계를 정의.
- **결과**: 데이터베이스 구조가 효율적이고 관리하기 쉬워짐.

## 1정규형 (1NF)
- 테이블의 모든 속성(컬럼)이 원자 값(더 이상 쪼갤 수 없는 값)을 가져야 함.
## 1정규화 대상
- 다가 속성
  - delimeter와 함께 존재하는 속성
  - eg) 계란, 닭가슴살
- 복합 속성
  - 하나의 단어처럼 보이지만 의미를 뜯어보니 그 속에 쪼갤 수 있는 어떤 단위들이 뭉쳐있는 속성
- 유사한 속성이 반복된 릴레이션(테이블)
- 중첩 릴레이션
- 동일 속성이 여러 릴레이션에 사용된 경우

## 2정규형 (2NF)
- 1NF를 만족하며, 기본키가 아닌 컬럼이 기본키에 완전 함수 종속(부분 함수 종속 제거)되어야 함.
- 두 개 이상으로 구성된 PK에서 발생.
  - 기본키를 구성하는 속성 중에 부분 속성에게 기본키가 아닌 속성이 종속되는 경우.
- (사조직을 꾸리려는) 왕족의 반란. 
### 2정규화 방법
일반 속성 중에서 후보 식별자 전체에 종속적이지 않은 속성을 찾아 기본 엔티티에서 제거하고, 그 속성의 결정자를 주 식별자로 하는 새로운 상위 엔티티를 생성

## 3정규형 (3NF)
- 2NF를 만족하며, 기본키를 제외한 다른 컬럼들이 서로 종속되지 않아야(이행적 종속 제거) 함.
- 호족의 반란.
  - 일반 속성이 사실 기본키이면서 일반 속성인 척하고 숨어서 사조직을 꾸리려고 하는 모양새.

## 추가 정규형, BC 정규형(Boyce-Codd Normal Form)
- 3정규형(3NF)을 보강하여 모든 함수적 종속성 X → Y에서 Y가 후보키가 아니어야 한다는 규칙. 
- 정의: 릴레이션에 존재하는 모든 함수적 종속성 $X\ \rightarrow\ Y$에 대해, $X$가 수퍼키(후보 키)여야 한다.
- 기본 키가 아닌 종속자가 후보키인 경우(처갓집의 반란).
### 왜 필요한가?
- 3정규형에서는 해결되지 않는 결정자(Determiner)에 의한 이상 현상을 해결하기 위해 도입되었다.
- 결정자(X)가 후보 키가 아닌 경우(예: A → B인데 A는 후보 키가 아님) 테이블을 분해하여 **모든 결정자가 후보 키가 되도록 만든다**.

요약하자면, BCNF는 3정규형에서 한 단계 더 나아가 모든 '결정자'가 '후보 키'가 되도록 강제하여 데이터 무결성을 더욱 강화하는 정규화 단계이다.

# 용어 정리
- 결정자: 하나의 속성(컬럼)이 다른 속성의 값을 고유하게 결정하는 관계에서, 값을 결정하는 주체가 되는 속성
- 후보키: 각 행(튜플)을 유일하게 식별할 수 있으면서도 최소한의 속성(컬럼)으로 구성된 키로, 유일성(uniqueness)과 최소성(minimality)을 모두 만족시켜 기본 키(Primary Key)로 선택될 수 있는 '후보'가 되는 속성들의 집합
- 대체키: 테이블의 각 행을 고유하게 식별할 수 있는 여러 후보 키(Candidate Key)들 중에서 기본 키(Primary Key)로 선택되지 않고 남은 키들
- 슈퍼키: 각 행(튜플)을 유하게 식별할 수 있는 속성 또는 속성의 집합
  - 특징:
    - 유일성 만족: 반드시 행을 유일하게 식별해야 함.
    - 최소성 불만족 가능: 유일성을 만족하는 여러 속성을 합친 것이므로, 최소한의 속성으로 구성되지 않아도 됨.
  - 예시: '학생' 테이블에서 '학번'만으로도 유일하지만, '(학번, 이름)', '(학번, 생년월일, 주소)' 등도 모두 슈퍼 키가 될 수 있다. 이 중 최소한의 속성으로 구성된 '(학번)'이 후보 키(Candidate Key)가 된다. 