# SQL에서 JOIN이란?
- 두 개 이상의 table들에 있는 데이터를 한 번에 조회하는 것
- 여러 종류의 JOIN이 존재한다.

# 두 가지 JOIN 방식
ID가 1인 임직원이 속한 부서의 이름을 알아내는 것을 다음과 같이 해낼 수 있다.
```sql
SELECT d.name
FROME employee e, department d
WHERE e.id = 1 AND e.dept_id = d.id;
```

이와 같은 방법으로 조회하는 것을 implicit join이라고 한다.

- implicit join: from절에는 table들만 나열하고 where절에 join condition을 명시하는 방식
  - old-style join syntax
  - where절에 selection condition과 join condition이 같이 있기 때문에 가독성이 떨어진다.
  - 복잡한 join 쿼리가 만들어지기 때문에 실수로 잘못된 쿼리를 작성하기 쉽다.

implicit join의 문제점을 해결하기 위해 SQL 표준에 JOIN을 명시할 수 있는 문법이 추가된다.
```sql
SELECT d.name
FROME employee e
JOIN department d ON e.dept_id = d.id
WHERE e.id = 1;
```

이와 같은 join 방식을 explicit join이라고 한다.

- explicit join: from절에 JOIN 키워드와 함께 joined table들을 명시하는 방식
  - from절에서 ON 뒤에 join condition이 명시된다.
  - 가독성이 좋다
  - 복잡한 join 쿼리가 만들어지더라도 실수할 가능성이 적다.

# INNER JOIN vs OUTER JOIN
```sql
SELECT *
FROM employee e
JOIN department d ON e.dept_id = d.id;
```

이전 예시에서 살펴보았던 explicit join이 사용된 쿼리의 JOIN 키워드 앞에는 INNER라는 키워드가 생략되어 있다.

- INNER JOIN: 두 table에서 join condition을 만족하는 tuple들로 result table을 만드는 join
  - join condition에서 null값을 가지는 tuple은 result table에 포함되지 못한다.
    - join condition이 TRUE인 경우에만 튜플을 가져오기 때문이다. (where절과 동일)

- OUTER JOIN: 두 table에서 join condition을 만족하지 않는 tuple들도 result table에 포함하는 join
  - `FROM table1 LEFT [OUTER] JOIN table2 ON join_condition`
  - `FROM table1 RIGHT [OUTER] JOIN table2 ON join_condition`
  - `FROM table1 FULL [OUTER] JOIN table2 ON join_condition` -> MySQL은 지원하지 않음. Postgres는 지원함.

# equi join
- join condition에 `=`(equality comparator)를 사용하는 join

## equi join에 대한 두 가지 시각
- inner join, outer join에 상관없이 =를 사용한 join이라면 equi join으로 보는 시각
- inner join에 한정해서 =를 사용한 join이라면 equi join으로 보는 시각

# using
```sql
SELECT *
FROM employee e
JOIN department d USING (dept_id);
```

ON을 사용하면 쿼리 결과에 dept_id가 중복으로 두 컬럼에서 출력되고 쿼리문에서도 중복으로 언급되는데 USING 키워드를 사용하면 dept_id가 쿼리 결과에서 첫 번째 컬럼으로, 한 번만 출력되고 쿼리문에서도 한 번만 언급된다.

## 정리
- 두 table이 equi join할 때 join하는 attribute의 이름이 같다면, USING으로 간단하게 작성할 수 있다.
- 이 때 같은 이름의 attribute는 result table에서 한 번만 표시된다.
- 여러 개의 attribute도 USING을 사용할 수 있다.
  - `FROM table1 JOIN ~ USING (attribute(s))`

# natural join
- 두 table에서 같은 이름을 가지는 모든 attribute pair에 대해 equi join을 수행한 걸 말한다.
- join condition을 따로 명시하지 않는다.
- `FROM table1 NATURAL [INNER] JOIN table2`
- `FROM table1 NATURAL LEFT [OUTER] JOIN table2`
- `FROM table1 NATURAL RIGHT [OUTER] JOIN table2`
- `FROM table1 NATURAL FULL [OUTER] JOIN table2`

# cross join
- 두 table의 tuple pair로 만들 수 있는 모든 조합(=Cartesian product)을 result table로 반환한다.
- join condition이 없다.
- implicit cross join: `SELECT * FROM table1, table2`
- explicit cross join: `SELECT * FROM table1 CROSS JOIN table2`

## MySQL에서의 cross join 
- MySQL에서의 cross join은 inner join( = join)이다.
- CROSS JOIN에 ON(or USING)을 같이 쓰면 inner join으로 동작한다.
- INNER JOIN(or JOIN)이 ON(or USING) 없이 사용되면 cross join으로 동작한다.

# self join
- table이 자기 자신에게 join하는 경우

# join 예제
- ID가 1003인 부서에 속하는 임직원 중 리더가 아닌 부서원의 ID, 이름, 연봉을 알고 싶다.
  - ```sql
    SELECT e.id, e.name, e.salary
    FROM employee e JOIN department d ON e.dept_id = d.id
    WHERE e.dept_id = 1003 AND e.id != d.leader_id;
    ```
  - 임직원의 부서 ID와 부서의 ID가 같은 레코드를 INNER JOIN하고, 임직원의 부서 ID가 1003이면서 임직원의 ID가 부서의 리더 ID가 아닌 경우(selection condition)를 조회하는 쿼리.
- ID가 2001인 프로젝트에 참여한 임직원들의 이름과 직군과 소속 부서 이름을 알고 싶다.
  - ```sql
    SELECT e.name AS empl_name,
           e.position AS empl_position,
           d.name AS dept_name
    FROM works_on w JOIN employee e ON w.empl_id = E.id
    LEFT JOIN department d ON e.dept_id = d.id
    WHERE w.proj_id = 2001;
    ```
  - department 테이블을 조인할 때 LEFT JOIN한 이유는, employee 테이블에서 dept_id가 NULL인 경우에 employee 정보가 남아있도록 하기 위함이다.
  - 조인 연산을 다 수행한 후에 WHERE 조건으로 필터링을 수행한다.

