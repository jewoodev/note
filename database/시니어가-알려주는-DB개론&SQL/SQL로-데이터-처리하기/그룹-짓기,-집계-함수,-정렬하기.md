# ORDER BY
- 조회 결과를 특정 attribute(s) 기준으로 정렬하여 가져오고 싶을 때 사용한다.
- default 정렬 방식은 오름차순이다.
- 오름차순 정렬은 ASC로 표기한다.
- 내림차순 정렬은 DESC로 표기한다.

# aggregate function
- 여러 tuple들의 정보를 요약해서 하나의 값으로 추출하는 함수
- 대표적으로 COUNT, SUM, MAX, MIN, AVG 함수가 있다.
- (주로) 관심있는 attribute에 사용된다.
  - e.g) `AVG(salary)`, `MAX(birth_date)`
- NULL값은 제외하고 요약 값을 추출한다.
  - table의 salary 컬럼의 데이터 중 NULL이 있는데 `COUNT(salary)`를 하면 NULL 갯수만큼 결과가 줄어듬.
  - table의 salary 컬럼의 데이터 중 NULL인 로우의 다른 컬럼이 NULL이 아닐 때 `COUNT(*)`를 하면 해당 로우를 제외하지 않음.

## 사용 예시
- 프로젝트 ID가 2002인 프로젝트에 참여한 임직원들의 수와 최대 연봉과 최소 연봉, 평균 연봉을 알고 싶다.
  - ```sql
    SELECT COUNT(*), MAX(salary), MIN(salary), AVG(salary)
    FROM works_on w JOIN employee e ON w.empl_id = e.id
    WHERE w.project_id = 2002;
    ```
  - 수행 순서: JOIN 연산을 수행한 이후 WHERE 조건(selection condition)으로 필터링하고 나서 aggregate function을 수행한다.

# GROUP BY
각 프로젝트에 참여한 임직원들의 수와 최대 연봉과 최소 연봉, 평균 연봉을 알고 싶다면 GROUP BY를 사용해야 한다.
```sql
SELECT w.proj_id, COUNT(*), MAX(salary), MIN(salary), AVG(salary)
FROM works_on w JOIN employee e ON w.empl_id = e.id
GROUP BY w.proj_id;
```

GROUP BY에는 하나 이상의 attribute를 사용할 수 있다.

## 정리
- 관심있는 attribute(s)를 기준으로 그룹을 나눠 그룹별로 aggregate function을 적용하고 싶을 때 사용한다.
- grouping attribute(s): 그룹을 나누는 기준이 되는 attribute(s)
- grouping attribute(s)에 NULL이 있을 땐 NULL값을 가지는 tuple끼리 묶인다.

# HAVING
이번엔 그룹에 적용할 조건을 넣고 싶은 경우를 살펴보자.

프로젝트 참여 인원이 7명 이상인 프로젝트들에 대해서 각 프로젝트에 참여한 임직원 수와 최대 연봉과 최소 연봉과 평균 연봉을 알고 싶다.
```sql
SELECT w.proj_id, COUNT(*), MAX(salary), MIN(salary), AVG(salary)
FROM works_on w JOIN employee e ON w.empl_id = e.id
GROUP BY w.proj_id
HAVING COUNT(*) >= 7;
```

## 정리
- GROUP BY와 함께 사용한다.
- aggregate function의 결과값을 바탕으로 그룹을 필터링하고 싶을 때 사용한다.
- HAVING절에 명시된 조건을 만족하는 그룹만 결과에 포함된다.

## 예제 문제
### 2. 회사 전체 평균 연봉보다 평균 연봉이 적은 부서들의 평균 연봉을 알고 싶다.
```sql
SELECT d.id, AVG(salary) AS dept_avg_salary 
FROM employee e JOIN department d ON e.dept_id = d.id 
GROUP BY d.id
HAVING AVG(salary) < (
    SELECT AVG(salary) FROM employee
);
```

### 3. 각 프로젝트 별로 프로젝트에 참여한 90년대생들의 수와 이들의 평균 연봉을 알고 싶다.
```sql
SELECT w.proj_id, COUNT(empl_id), AVG(salary)
FROM works_on w JOIN employee e ON w.empl_id = e.id
WHERE e.birth_date BETWEEN '1990-01-01' AND '1999-12-31'
GROUP BY w.proj_id;
```

### 4. 프로젝트 참여 인원이 7명 이상인 프로젝트로 한정해서 각 프로젝트별로 프로젝트에 참여한 90년대생들의 수와 이들의 평균 연령을 알고 싶다.
```sql
SELECT proj_id, COUNT(empl_id), AVG(salary)
FROM works_on w JOIN employee e ON w.empl_id = e.id
WHERE e.birth_date BETWEEN '1990-01-01' AND '1999-12-31'
GROUP BY w.proj_id
HAVING COUNT(empl_id) >= 7;
```
이걸로 해결될 것 같지만, 이렇게 해버리면 "90년대생이 7명 이상인~"의 조건으로 필터링이 되버린다. 

```sql
SELECT w.proj_id, COUNT(e.empl_id), AVG(e.salary)
FROM works_on w JOIN employee e ON w.empl_id = e.id
WHERE e.birth_date BETWEEN '1990-01-01' AND '1999-12-31'
    AND w.proj_id EXISTS (
        SELECT w2.proj_id
        FROM works_on w2 
        GROUP BY w2.proj_id
        HAVING COUNT(*) >= 7
    )
GROUP BY w.proj_id;
```
이렇게 풀어봤는데 틀렸다.

```sql
SELECT 
    w.proj_id, 
    COUNT(e.empl_id) AS nineties_count,
    AVG(TIMESTAMPDIFF(YEAR, e.birth_date, CURDATE())) AS avg_age
FROM works_on w 
JOIN employee e ON w.empl_id = e.id
WHERE e.birth_date BETWEEN '1990-01-01' AND '1999-12-31'
    AND w.proj_id IN (
        SELECT w2.proj_id
        FROM works_on w2 
        GROUP BY w2.proj_id
        HAVING COUNT(*) >= 7
    )
GROUP BY w.proj_id;
```
이 풀이가 맞고, 성능이 중요하다면 서브쿼리 대신 윈도우 함수나 조인을 활용할 수 있다.

```sql
-- 서브쿼리 대신 조인을 활용한 쿼리
SELECT 
    w.proj_id,
    COUNT(e.empl_id) AS nineties_count,
    AVG(TIMESTAMPDIFF(YEAR, e.birth_date, CURDATE())) AS avg_age
FROM works_on w 
JOIN employee e ON w.empl_id = e.id
JOIN (
    SELECT proj_id
    FROM works_on
    GROUP BY proj_id
    HAVING COUNT(*) >= 7
) proj_filter ON w.proj_id = proj_filter.proj_id
WHERE e.birth_date BETWEEN '1990-01-01' AND '1999-12-31'
GROUP BY w.proj_id;
```

# SELECT 조회 정리
```sql
SELECT attribute(s) or aggregate_function(s)
FROM table(s)
[WHERE condition(s)]
[GROUP BY group attribute(s)]
[HAVING group condition(s)]
[ORDER BY order attribute(s) ASC|DESC];
```

# SELECT 실행 순서
```
6. SELECT attribute(s) or aggregate_function(s)
1. FROM table(s)
2. [WHERE condition(s)]
3. [GROUP BY group attribute(s)]
4. [HAVING group condition(s)]
5. [ORDER BY order attribute(s) ASC|DESC]
```
- select 쿼리에서 각 절(phrase)의 실행 순서는 개념적인 순서이다.
- select 쿼리의 실제 실행 순서는 각 RDBMS에서 어떻게 구현했는지에 따라 다르다.