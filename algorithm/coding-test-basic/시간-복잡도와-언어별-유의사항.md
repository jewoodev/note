# 효율성
알고리즘 문제를 해결하는 코드를 작성할 때, 코드가 효율성을 가지기 위해서는 다음 중 어떤게 가장 중요할까?

1. 수행 시간
2. 사용한 메모리
3. 코드의 길이

이 중 '코드의 길이'는 전혀 중요하지 않다. 코드의 길이가 길어진다고 시간이 더 많이 걸리고 짧아진다고 더 적게 걸리는게 아니기 때문이다. 코드는 "알아보기 쉽게" 적는 것이 가장 중요하다.

'사용한 메모리'는 '수행 시간'보단 덜 중요하다. 작업을 끝내는데 30일이 걸리는 프로그램이 있는 것과, 실행되기 위해 메모리가 64GB가 필요한 프로그램을 떠올려보자. 후자는 메모리 부품을 돈들여 사면 해결될 수 있지만, 전자는 그게 어렵다. 1일 걸리는 작업 단위로 쪼개서 여러 개의 PC를 사용하면 1일이 걸리게 축소시킬 수 있지만, 모든 경우에 그렇듯 쪼갤 수 없기 때문에 '수행 시간'이 더 중요해지는 것이다. 

여기까지의 내용은 '알고리즘 문제 해결'에 한정지은 것이다. 그래서 그렇게 중요한 시간에 대해서 이야기 하기 위해서는 **문제의 크기**에 대해서 먼저 알아야 한다. 

## 문제의 크기
개발 상황에서 접하게 되는 상황은 '문제를 해결해야 하는 상황'이고, 모든 상황에는 문제의 크기가 존재한다.

그러한 예시들을 살펴보자.

- 쇼핑몰 장바구니 물건의 개수
    - 상품의 개수, 회원의 수
- 게임 동시 접속자 수

위와 같은 문제의 크기를 나타낼 때, **문제의 크기를 보통 N이라고 하고** 이 N에 따라 걸리는 시간이 달라진다. 즉, 문제의 크기에 시간이 영향을 받는다.

웹사이트를 만드는 경우에 10명이 동시 접속하는 사이트를 만드는 것과 10만명이 동시 접속하는 사이트를 만드는 방법에는 매우 큰 차이가 있다. 후자가 더 어렵다.

문제의 크기에 따라서 복잡성이 달라지는 만큼 크기에 따라 알맞은 방법을 선택하는 것이 좋다. '10만명이 동시 접속하는 사이트를 만드는 방법'으로 '10명이 동시 접속하는 사이트'를 만들면 문제는 없지만, 적합한 용도라고 볼 수는 없을 것이다. 그래서 문제의 크기에 따라서 문제를 해결할 방법이 여러 개 있으면 그 중에서 적당한 방법을 선택해서 해결하는 것이 좋은 것이다.

정리하자면 문제를 해결할 때 가장 중요한게 시간이고, "문제의 크기를 보고 어떤 방법을 쓸 때 시간이 얼만큼 들겠다." 예측을 먼저 하는 것이 효율적인 문제 해결을 위한 방법이 되겠다.

그런 예측을 하기 위해 사용하는 것이 **시간 복잡도**이다.

## 시간 복잡도
문제의 크기 N에 대해서 어떤 식이 나오는지 표현해줘야 한다. 시간 복잡도를 사용하는 방법에는 두 가지 방법이 있다.

1. 코드를 일단 작성한 후, 그 코드를 보고 계산하는 방법
2. 코드를 작성하기 전에, 어떤 방법으로 풀건지 그 방법을 이용해서 미리 시간 복잡도를 계산해보고, 만족하면 구현하는 방법  

## 메모리 제한
- 보통 배열의 크기가 크면 '시간 초과가 발생'하는 경우가 많다.
- 불필요한 공간이 없다면, 대부분 메모리 제한은 알아서 지켜진다.
    - 중복되는 값을 계속 저장하게 되지 않는지는 유의해야 한다.

## Java 입/출력
- 입력이 많은 경우(10만 개), BufferedReader를 사용한다.

# 언어별 유의사항
## 시간 초과
```java
class Main {
    public static void main(String[] args) {
        String s;
        int n = 1000000;

        for (int i = 0; i < n; i++) {
            s += "A";
        }
        
        return 0;
    }
}
```
위의 코드는 시간 복잡도가 어떻게 될까? 정답은 O($N^2$)이다. 왜 그렇게 계산되냐면, 자바는 위의 연산을 수행할 때 매번 새로운 문자열을 만들기 때문이다.

즉, `s += "A"` 의 복잡도가 O(N)이 된다. 문자열 A와 문자열 B를 더해 새로운 문자열을 만드는 작업은 O(A의 길이 + B의 길이)이다. 

그래서 총 복잡도는 O(N(N + K))가 되며, 이렇게 효율이 나쁘기 때문에 StringBuilder를 사용해야 한다. 그걸 사용하면 O(N)이 된다. "AA" 뒤에 "A"를 붙이기만 하면 되는 연산 방식으로 바뀌기 때문이다. 