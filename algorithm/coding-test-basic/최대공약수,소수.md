# 최대공약수, 소수
## 최대공약수
```java
public class Main {
    public static int gcd(int x, int y) {
        if (y == 0) {
            return x;
        }
        return gcd(y, x % y);
    }
    
    public static void main(String[] args) {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        
        String[] read = br.readLine().split(" ");
        int a = Integer.parseInt(read[0]);
        int b = Integer.parseInt(read[1]);
        
        int g = gcd(a, b);
        bw.write(g + "\n");
        bw.flush();
    }
}
```

## 소수
1과 그 수 자신 이외의 자연수로는 나눌 수 없는 자연수. 2, 3, 5, 7, 11 따위가 있다.

### 소수와 관련된 알고리즘
1. 어떤 수 N이 소수인지 아닌지 판별하는 방법
    1. 소수의 정의를 활용
        1. 2부터 N-1까지의 수로 나뉘어 떨어지는지 검사하기
            - 2부터 N-1까지의 수로 나눗셈 연산을 해야 하므로, 시간복잡도 O(N)
    2. 약수의 특징을 이용
        - `N/2 + 1`부터 `N - 1`까지의 수 중에 약수가 없음
            - 2 ~ N/2 까지의 수만이 나누어 떨어지는 건지 검사하기
                - 따라서 시간복잡도 O(log(N/2))
    3. 더 빠른 방법, 2 ~ $\sqrt(N)$ 까지의 수로 나뉘어 떨어지는지 검사하기
        -  따라서 시간복잡도 **O($\sqrt{N}$)**
2. N보다 작거나 같은 모든 자연수 중에서 소수를 찾아내는 방법
    1. 1-3번의 방법을 사용 시 O(N$\sqrt{N}$)가 복잡도가 되는데, 이보다 더 빠른 방법이 있다. 바로 '**에라토스테네스의 체**'라는 방법이다.
        1. 2부터 N까지의 모든 수를 써놓는다.
        2. 아직 지워지지 않은 수 중에서 가장 작은 수를 찾는다.
        3. 그 수는 소수이다.
        4. 이제 그 수의 배수를 모두 지운다.
    2. '**골드바흐의 추측**'
        - 2보다 큰 모든 짝수는 두 소수의 합으로 표현 가능하다.
        - 위의 문장에 3을 더하면
        - 5보다 큰 모든 홀수는 세 소수의 합으로 표현 가능하다.
        - 가 되며 두 문장 모두 골드바흐의 추측이다.
        - 아직 증명되지 않은 문제로, $10^{18}$ 이하에서는 참인 것이 증명되었다.
        - 이 방법에서 사용하는 에라토스테네스의 채를 보면 알 수 있듯이, 어떤 수 N이 소수인지 아닌지 판별하기 위해 $\sqrt{N}$ 방법을 사용할 필요가 없다.
            - 에라토스테네스의 결과에서 지워지지 않았으면 소수, 지워졌으면 소수가 아니기 때문이다.

#### 알고리즘 구현 예시
```java
// 1-3번의 방법
class Main {
    static boolean isPrime(int n) {
        if (n < 2) {
            return false;
        }

        for (int i = 2; i * i < n; i++) { // 루트가 아니라 'i의 제곱'으로 범위 체크하는 이유는, 실수가 되면 근삿값이 되기 때문. 정수로 체크하는 것이 보다 더 정확, 좋은 방법
            if (n % i == 0) {
                return false;
            }
        }
        
        return true;
    }
}
```

```java
// 2-1번의 방법
class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        String s = br.readLine().split(" ");
        int n = Integer.parseInt(s[0]);
        int m = Integer.parseInt(s[1]);
        boolean[] check = new boolean[m + 1];

        check[0] = check[1] = true; // check 배열이 true이면 해당 인덱스의 수는 지워진 것

        for (int i = 2; i * i <= m; i++) {
            if (check[i] == true) {
                continue;
            }

            for (int j = i + i; j <= m; j += i) {
                check[j] = true;
            }
        }

        for (int i = 0; i <= m; i++) {
            if (check[i] == false) {
                bw.write(i + "\n");
            }
        }
        
        bw.flush();
    }
}
```

```java
// 2-2번의 방법
class Main {
    static int MAX = 1000000;
    
    public static void main(String[] args) throws IOException {
        List prime = new ArrayList(); // 소수
        int pn = 0; // 소수의 개수
        boolean[] check = new boolean[MAX + 1]; // 에라토스테네스의 체를 쓰기 위한 체크 배열
        
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        
        
    }
}
```