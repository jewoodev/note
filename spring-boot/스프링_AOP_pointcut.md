# 스프링 AOP의 포인트컷

스프링 AOP는 AspectJ의 기술을 가져다 쓴다. AspectJ의 기술은 매우 방대한데 이를 다 공부하려면 삼천포로 빠지게 될 것이다. 스프링이 채택한 기술에만 집중하자.

포인트컷을 설정하기 위한 표현식을 알아보자. 이걸 이용해서 어떤 패키지의 어떤 클래스, 메소드에 적용할 건지, 인자 타입은 어떤 것일 경우에만 매칭할 것인지 표현할 수 있다.

포인트컷의 표현식은 지시자로 시작된다. 표현식을 효율적으로 사용할 수 있도록 특정 케이스마다의 용도에 맞게 다양한 표현식을 구비해두었는데, 그러한 표현식들을 구분지어 사용하기 위한 구분자라고 봐도 좋다.

> 포인트컷 지시자(Pointcut Designator)는 줄여서 PCD라고도 한다. 

지시자의 종류는 아래와 같다. 각 지시자의 설명은 어떤 식으로 조인 포인트를 매칭하는지 서술하고 있다.

- execution: 어떤 메소드에 조인 포인트를 매칭할지 설정 (가장 많이 사용, 기능 복잡)
- within: 특정 타입의 클래스에만 조인 포인트를 매칭 
- args: 특정 타입의 인자를 갖는 인스턴스만 조인 포인트 매칭
- this: 스프링 빈 객체(스프링 AOP 프록시)를 대상으로 하는 조인 포인트 매칭
- target: Target 객체(스프링 AOP 프록시가 가르키는 실제 대상)를 대상으로 하는 조인 포인트 매칭
- @target: 주어진 애노테이션이 있는 타입을 갖는 인스턴스의 모든 메서드에 조인 포인트 매칭, 그래서 부모 타입의 메서드에도 모두 매칭함
- @within: @target과 달리 해당 타입 내에 있는 메서드만 조인 포인트 매칭, 그래서 부모 타입의 메서드에는 매칭 x
- @annotation: 주어진 애노테이션이 적용된 메소드를 대상으로 하는 조인 포인트 매칭

> 조인 포인트는 애플리케이션 실행 흐름에서의 특정 지점(예: 메서드 호출, 예외 발생 등)을 나타내고, 포인트컷은 이러한 조인 포인트 중에서 어떤 지점에 부가 기능(어드바이스)을 적용할지를 필터링한다.  
> 따라서 포인트컷은 조인 포인트를 적용한다는 표현보다 매칭한다는 표현이 더 적합하다.

## execution 지시자의 문법 

```
execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)
```

뒤에 ?가 붙어있는 것은 생략할 수 있다. 그리고 `*`를 사용해서 어떤 것이든 대체될 수 있는 패턴을 지정할 수 있다. 

만약 `public java.lang.String hello.aop.member.MemberServiceImpl.hello(java.lang.String)` 에 execution 지시자를 사용한다면 

`execution(public String hello.aop.member.MemberServiceImpl.hello(String))`이 된다.

생략 가능한 걸 모두 생략하면 `execution(String hello(String))`이 되고 모든 곳에 매칭하려면 `execution(* *(..))`이 된다. 파라미터에 `..`을 주면 파라미터의 타입과 수가 어떤 것이든 상관없다는 뜻이다.

`declaring-type-pattern`은 선언타입이라는 이름으로 패키지 이름을 포함한 선언타입이다. 여기에 `..`을 주면 해당 위치의 패키지와 그 하위 패키지도 포함한다는 뜻이다.

이 지시자는 표현식에 부모 타입을 지정해도 다형성이 적용된 것처럼 자식 타입과 매칭된다. 따라서 부모 타입에 있는 메서드라면 조인 포인트가 매칭되지만 아니라면 매칭되지 않는다.

## within 지시자의 문법

이 지시자는 execution 문법에서 선언타입만 사용하는 방식이라고 보면 된다. 특정 타입이 매칭되면 그 안의 메서드들이 모두 매칭된다.

### execution 지시자와의 차이점

within 지시자는 표현식에 부모 타입을 지정하면 자식 타입이 매칭되지 않는다. 이 점이 execution 지시자를 사용할 때와는 다르다. 

## args 지시자의 문법

문법이 execution 지시자의 args 부분과 같다. 그런데 완전히 똑같진 않고 차이점이 있다. 

> 파라미터 바인딩과 함께 사용된다.

### 타입 매칭 경계와 판단 기준의 차이

execution은 타입이 정확하게 매칭되어야 한다. 클래스에 선언된 정보를 기반으로 판단한다.

args는 부모 타입을 허용한다. 그리고 실제 넘어온 인수를 보고 판단한다.

## @target, @within의 문법

두 지시자의 문법은 동일하다. 아래와 같이 사용하면 된다.

`@target(declaring-type-pattern)`

`@target(hello.aop.member.annotation.ClassAnnotation)`

> 파라미터 바인딩과 함게 사용된다.

## 단독으로 사용하면 안되는 지시자들

그러한 지시자는 `args`, `@args`, `@target` 이다. 이 것들은 실제 인스턴스가 생성되고 실행될 때 어드바이스 적용 여부를 확인할 수 있다. 그래서 이런 지시자가 있으면 스프링은 포인트컷 조건을 충족할 가능성이 있는 모든 빈에 대해 프록시를 생성하고, 실제 메소드가 실행될 때 포인트컷 조건이 맞는지를 검사한다.

그런데 스프링 컨테이너가 프록시를 생성하는 시점이 스프링 컨테이너가 만들어지는 애플리케이션 로딩 시점이다보니 생성되는 스프링 내부의 빈까지 AOP를 적용하는데, 이 때 스프링이 내부에서 사용하는 빈 중에 `final`이 지정된 빈들도 있기 때문에 오류가 발생된다. 따라서 이러한 표현식은 최대한 프록시 적용 대상을 축소하는 표현식과 함께 사용해야 한다.

## bean 지시자의 문법

AspectJ에 없는 Spring 전용 포인트컷 지시자로 다음과 같이 사용할 수 있다.

`bean(orderService) || bean(*Repository)`

Repository 앞에는 *가 붙었으므로 bombRepository가 와도 verbRepository가 와도 매칭된다.

## 매개변수를 전달할 수 있는 지시자들

**this, target, args, @target, @within, @annotation, @args**

이 지시자들은 표현식을 이용해 어드바이스에 매개변수를 전달할 수 있다.

아래는 사용의 예이다.

```java
@Before("execution(* hello.aop.member..*.*(..) && args(arg,..)")
public void logArgs(String arg) {
    log.info("[logArg] arg={}", arg);
}
```

포인트컷 표현식에서의 이름과 매개변수의 이름을 맞추어야 한다. 예시에서는 arg로 맞췄다.

그리고 타입이 메서드에 지정한 타입으로 제한된다. 예시에서는 String이므로 String만 전달할 수 있다.

또, 표현식에 args 지시자로 파라미터 이름과 매핑하지 않고도 `JoinPoint.getArgs();`로 파라미터들을 가져올 수 있다.

다른 지시자로는 다른 객체나 값을 전달받을 수 있다.

this로는 프록시 객체를 전달받는다. target으로 실제 대상 객체를 전달받는다. 

@target과 @within은 타입의 애노테이션을 전달받는다. @annotation은 메서드의 애노테이션을 전달받는다. 그리고 전달받은 애노테이션으로 애노테이션의 인수도 가져올 수 있다.

## this, target

두 지시자는 프록시 객체를 대상으로 하느냐(this), 프록시가 가르키는 실제 객체를 대상으로 하느냐의 차이를 가지고 있다.

> 둘 다 부모 타입도 허용한다. 그리고 `*`같은 패턴을 사용할 수 없다.

그런데 JDK 동적 프록시 기술로 프록시를 생성하게 되면 의도한 바와 다르게 AOP 적용이 되지 않을 수 있다. 

### 언제 적용되지 않을까?

`OrderService` 인터페이스가 있고 `OrderServiceImpl`이 구현체라고 하자. 이 때 `spring.aop.proxy-target-class` 설정값이 false로 적용되어 인터페이스를 기반으로 새로운 구현 클래스를 프록시로 등록된다.
그리고 `this(hello.aop.Member.OrderServiceImpl)`로 포인트컷 표현식을 주게되면 그 프록시는 `OrderServiceImpl`과는 별도의 클래스이기 때문에 매칭되지 않는다. 

### 이렇게 기억하자

프록시를 대상으로 하는 this는 구체 클래스를 지정하면 프록시 생성 전략에 따라 다른 결과가 나올 수 있다고 기억하자.